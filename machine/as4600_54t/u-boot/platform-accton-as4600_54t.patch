Platform support for the Accton as4600_54t

diff --git a/Makefile b/Makefile
index 8dd09a5..c3fab7d 100644
--- a/Makefile
+++ b/Makefile
@@ -328,6 +328,7 @@ LIBS-y += drivers/usb/phy/libusb_phy.o
 LIBS-y += drivers/usb/ulpi/libusb_ulpi.o
 LIBS-y += drivers/video/libvideo.o
 LIBS-y += drivers/watchdog/libwatchdog.o
+LIBS-y += drivers/cpld/altera/libcpld_altera.o
 LIBS-y += common/libcommon.o
 LIBS-y += lib/libfdt/libfdt.o
 LIBS-y += api/libapi.o
diff --git a/arch/powerpc/cpu/mpc85xx/ddr-gen3.c b/arch/powerpc/cpu/mpc85xx/ddr-gen3.c
index ef0dd1d..429274a 100644
--- a/arch/powerpc/cpu/mpc85xx/ddr-gen3.c
+++ b/arch/powerpc/cpu/mpc85xx/ddr-gen3.c
@@ -306,6 +306,8 @@ void fsl_ddr_set_memctl_regs(const fsl_ddr_cfg_regs_t *regs,
 			>> SDRAM_CFG_DBW_SHIFT);
 	timeout = ((total_gb_size_per_controller << (6 - bus_width)) * 100 /
 		(get_ddr_freq(0) >> 20)) << 1;
+
+	timeout *= 2;	/*Kenny Cheng: to prevent D_INIT*/
 #ifdef CONFIG_SYS_FSL_ERRATUM_DDR111_DDR134
 	timeout_save = timeout;
 #endif
@@ -390,6 +392,7 @@ void fsl_ddr_set_memctl_regs(const fsl_ddr_cfg_regs_t *regs,
 
 	/* 9. Poll until dinit is cleared */
 	timeout = timeout_save;
+	timeout *= 2;	/*Kenny Cheng: to prevent timeout*/
 	debug("Need to wait up to %d * 10ms\n", timeout);
 	while ((in_be32(&ddr->sdram_cfg_2) & SDRAM_CFG2_D_INIT) &&
 		(timeout >= 0)) {
diff --git a/arch/powerpc/lib/board.c b/arch/powerpc/lib/board.c
index 5595329..6a7bf4b 100644
--- a/arch/powerpc/lib/board.c
+++ b/arch/powerpc/lib/board.c
@@ -851,15 +851,10 @@ void board_init_r(gd_t *id, ulong dest_addr)
 	sc3_read_eeprom();
 #endif
 
-#if defined(CONFIG_ID_EEPROM) || defined(CONFIG_SYS_I2C_MAC_OFFSET) || \
-    defined(CONFIG_SYS_EEPROM_LOAD_ENV_MAC)
+#if defined(CONFIG_ID_EEPROM) || defined(CONFIG_SYS_I2C_MAC_OFFSET)
 	mac_read_from_eeprom();
 #endif
 
-#ifdef CONFIG_POPULATE_SERIAL_NUMBER
-	populate_serial_number();
-#endif
-
 #ifdef	CONFIG_HERMES
 	if ((gd->board_type >> 16) == 2)
 		bd->bi_ethspeed = gd->board_type & 0xFFFF;
@@ -1008,11 +1003,6 @@ void board_init_r(gd_t *id, ulong dest_addr)
 	last_stage_init();
 #endif
 
-#ifdef CONFIG_ENV_WRITE_DEFAULT_IF_CRC_BAD
-	WATCHDOG_RESET();
-	env_write_default_if_crc_bad();
-#endif
-
 #if defined(CONFIG_CMD_BEDBUG)
 	WATCHDOG_RESET();
 	bedbug_init();
diff --git a/arch/powerpc/lib/bootm.c b/arch/powerpc/lib/bootm.c
index 7088293..3371103 100644
--- a/arch/powerpc/lib/bootm.c
+++ b/arch/powerpc/lib/bootm.c
@@ -293,6 +293,11 @@ static int boot_body_linux(bootm_headers_t *images)
 		ft_board_setup(*of_flat_tree, gd->bd);
 #endif
 
+#ifdef CONFIG_FDT_ENV_SIZE
+		do_fixup_by_prop_u32(*of_flat_tree, "label", "uboot-env", 10,
+				     "env_size", CONFIG_ENV_SIZE, 1);
+#endif
+
 		/* Delete the old LMB reservation */
 		lmb_free(lmb, (phys_addr_t)(u32)*of_flat_tree,
 				(phys_size_t)fdt_totalsize(*of_flat_tree));
diff --git a/board/accton/as4600_54t/Makefile b/board/accton/as4600_54t/Makefile
new file mode 100644
index 0000000..91242a4
--- /dev/null
+++ b/board/accton/as4600_54t/Makefile
@@ -0,0 +1,60 @@
+#
+# Copyright 2004 Freescale Semiconductor.
+# (C) Copyright 2001-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS-y	+= $(BOARD).o $(BOARD)_misc.o
+COBJS-y	+= law.o
+COBJS-y	+= tlb.o
+COBJS-y	+= usb.o
+COBJS-y	+= ddr.o
+COBJS-y	+= cmd_update_cpld.o
+COBJS-y	+= cmd_dram_test.o
+COBJS-$(CONFIG_FASTPATH) += bootf.o
+
+COBJS-y += fan_read_cmd.o
+
+SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS-y))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+clean:
+	rm -f $(OBJS) $(SOBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/accton/as4600_54t/as4600_54t.c b/board/accton/as4600_54t/as4600_54t.c
new file mode 100644
index 0000000..85f7182
--- /dev/null
+++ b/board/accton/as4600_54t/as4600_54t.c
@@ -0,0 +1,599 @@
+/*
+ * Copyright 2004, 2007, 200 Freescale Semiconductor, Inc.
+ *
+ * (C) Copyright 2002 Scott McNutt <smcnutt@artesyncp.com>
+ *
+ * Curt Brune <curt@cumulusnetworks.com>
+ * Vidya Ravipati <vidya@cumulusnetworks.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <config.h>
+#include <pci.h>
+#include <asm/processor.h>
+#include <asm/mmu.h>
+#include <asm/cache.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_pci.h>
+#include <asm/fsl_ddr_sdram.h>
+#include <asm/io.h>
+#include <asm/fsl_serdes.h>
+#include <miiphy.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+#include <fsl_mdio.h>
+#include <tsec.h>
+#include <broadcom_phy.h>
+#include <asm/fsl_law.h>
+#include <asm/mp.h>
+#include <netdev.h>
+
+#include <spd_sdram.h>
+#include <i2c.h>
+#include <sys_eeprom.h>
+#include "board.h"
+#include <version.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static int boot_ok_flag=1;      /*1 OK, 0 fail*/
+int get_boot_ok(void)
+{
+        return boot_ok_flag;
+}
+
+void set_boot_ok(void)
+{
+        boot_ok_flag = 1;
+}
+
+void set_boot_flag_fail(void)
+{
+        boot_ok_flag = 0;
+}
+
+
+extern int check_fix_env(void);
+extern void GPIO_init(void);
+extern void BCM54616S_init(void);
+
+
+/*******************************************************************************
+ *
+ * Early initialization
+ *
+ */
+int board_early_init_f(void)
+{
+#if 0 /* change WDT disable to last_stage_init() */
+    u8 val;
+
+    /* disable watchdog */
+    val = cpld_rd(CPLD_REG_SYS_CONTROL);
+    val &= ~CPLD_WDT_ENABLE;
+    cpld_wr(CPLD_REG_SYS_CONTROL, val);
+#endif
+
+    return 0;
+}
+
+/*******************************************************************************
+ *
+ * Initialize board and the local bus
+ */
+void
+local_bus_init(void)
+{
+    volatile ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+    volatile fsl_lbc_t *lbc = LBC_BASE_ADDR;
+
+    uint clkdiv;
+    sys_info_t sysinfo;
+
+    get_sys_info(&sysinfo);
+    clkdiv = (lbc->lcrr & LCRR_CLKDIV) * 2;
+
+    gur->lbiuiplldcr1 = 0x00078080;
+    if (clkdiv == 16) {
+        gur->lbiuiplldcr0 = 0x7c0f1bf0;
+    } else if (clkdiv == 8) {
+        gur->lbiuiplldcr0 = 0x6c0f1bf0;
+    } else if (clkdiv == 4) {
+        gur->lbiuiplldcr0 = 0x5c0f1bf0;
+    }
+
+    lbc->lcrr |= 0x00030000;
+
+    asm("sync;isync;msync");
+
+    lbc->ltesr = 0xffffffff;	/* Clear LBC error interrupts */
+    lbc->lteir = 0xffffffff;	/* Enable LBC error interrupts */
+}
+
+int checkboard(void)
+{
+
+    u8    cpld_ver;
+
+    cpld_ver = cpld_rd(CPLD_REG_VERSION);
+
+    printf("Board: Accton %s (cpld_ver: %X.%X)\n", CONFIG_BOARDNAME,
+           cpld_ver >> 4, cpld_ver & 0xf);
+
+    local_bus_init();
+
+    return 0;
+}
+
+
+int board_early_init_r(void)
+{
+    const unsigned int flashbase = CONFIG_SYS_FLASH_BASE;
+    const u8 flash_esel = find_tlb_idx((void *)flashbase, 1);
+    char *env;
+    int speed;
+
+    /*
+     * Remap Boot flash region to caching-inhibited
+     * so that flash can be erased properly.
+     */
+
+    /* Flush d-cache and invalidate i-cache of any FLASH data */
+    flush_dcache();
+    invalidate_icache();
+
+    /* invalidate existing TLB entry for flash */
+    disable_tlb(flash_esel);
+
+    set_tlb(1, flashbase, CONFIG_SYS_FLASH_BASE_PHYS,
+            MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+            0, flash_esel, CONFIG_SYS_FLASH_TLB_SIZE, 1);
+
+
+    /* Init system fan, Set system fan duty cycle*/
+    env = getenv("config_fan_speed");
+    speed = DEFAULT_FAN_DUTY_CYCLE;
+    if(env) {
+        speed = simple_strtoul(env, NULL, 10);
+    }
+    board_fan_init(speed);
+
+    return 0;
+}
+
+
+/*
+ *
+ * setup PCI
+ *
+ * Cribbed from board/freescale/mpc8536ds/mpc8536ds.c
+ *
+ */
+
+#ifdef CONFIG_PCI
+void pci_init_board(void)
+{
+    fsl_pcie_init_board(0);
+}
+#endif
+
+/*******************************************************************************
+ *
+ * PCI device tree massaging
+ */
+#if defined(CONFIG_OF_BOARD_SETUP)
+void ft_board_setup(void *blob, bd_t *bd)
+{
+
+    ft_cpu_setup(blob, bd);
+
+#ifdef CONFIG_HAS_FSL_DR_USB
+    fdt_fixup_dr_usb(blob, bd);
+#endif
+
+    FT_FSL_PCI_SETUP;
+}
+#endif
+
+/* apply errata for the front panel mgmt phy */
+int board_phy_config(struct phy_device *phydev)
+{
+    unsigned short shdw;
+    unsigned short ctrl;
+    unsigned short led;
+
+    /*
+     * Overall goal is to disable Auto-Neg in the 1000Base-X MII
+     * Control register.  Need to wind our way through the MII
+     * register indirections to get there.
+     *
+     * See CONFIG_TSEC_TBICR_SETTINGS in board header file.
+     */
+    enum {
+        MIIM_BCM54XX_SHD_LED_SEL_1		= 0x0D,
+        MIIM_BCM54XX_SHD_LED_SEL_2		= 0x0E,
+        MIIM_BCM54XX_SHD_MODE_CTRL		= 0x1f,
+        MIIM_BCM54XX_SHD_MODE_CTRL_SERDES_REG	= 0x0001,
+    };
+
+    enum {
+        MIIM_BCM5461S_SHD_LED_LINKSPD1		= 0x0,
+        MIIM_BCM5461S_SHD_LED_LINKSPD2,
+        MIIM_BCM5461S_SHD_LED_XMITLED,
+        MIIM_BCM5461S_SHD_LED_ACTIVITYLED,
+        MIIM_BCM5461S_SHD_LED_FXLED,
+        MIIM_BCM5461S_SHD_LED_SLAVE,
+        MIIM_BCM5461S_SHD_LED_INTR,
+        MIIM_BCM5461S_SHD_LED_QUALITY,
+        MIIM_BCM5461S_SHD_LED_RCVLED,
+        MIIM_BCM5461S_SHD_LED_RESERVED1,
+        MIIM_BCM5461S_SHD_LED_MULTICOLOR1,
+        MIIM_BCM5461S_SHD_LED_OPENSHORT,
+        MIIM_BCM5461S_SHD_LED_RESERVED2,
+        MIIM_BCM5461S_SHD_LED_RESERVED3,
+        MIIM_BCM5461S_SHD_LED_OFF,
+        MIIM_BCM5461S_SHD_LED_ON,
+    };
+
+    enum {
+        MIIM_BCM5461S_LED1_SHIFT = 0,
+        MIIM_BCM5461S_LED2_SHIFT = 4,
+        MIIM_BCM5461S_LED3_SHIFT = 4,
+        MIIM_BCM5461S_LED4_SHIFT = 0,
+    };
+
+    if (phydev->drv->config)
+        phydev->drv->config(phydev);
+
+    /*
+     * Step 1 -- via the shadow control register (0x1c) access the
+     * "MODE CONTROL" register, selecting the 1000Base-X register
+     * set (SGMII side, facing eTSEC).  Future accesses to offsets
+     * 0x0 - 0xF will hit the 1000Base-X registers.
+     */
+    shdw = MIIM_BCM54XX_SHD_VAL(MIIM_BCM54XX_SHD_MODE_CTRL);
+    phy_write(phydev, MDIO_DEVAD_NONE, MIIM_BCM54XX_SHD, shdw);
+
+    shdw = phy_read(phydev, MDIO_DEVAD_NONE, MIIM_BCM54XX_SHD);
+    shdw |= MIIM_BCM54XX_SHD_MODE_CTRL_SERDES_REG;
+    shdw = MIIM_BCM54XX_SHD_WR_ENCODE(MIIM_BCM54XX_SHD_MODE_CTRL,
+                                      shdw);
+    phy_write(phydev, MDIO_DEVAD_NONE, MIIM_BCM54XX_SHD, shdw);
+
+    /*
+     * Step 2 -- Disable Auto-Neg.  This is a regular access to
+     * the MII control register (0x0), however the 1000Base-X
+     * register set is selected from step 1.
+     */
+    ctrl = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR);
+    ctrl &= ~BMCR_ANENABLE;
+    phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, ctrl);
+
+    /*
+     * Step 3 -- Restore the access to the 1000Base-T register set
+     * (copper, network side) via the shadow control register
+     * (0x1c).  Future accesses to offsets 0x0 - 0xF will hit the
+     * 1000Base-T registers.
+     */
+    shdw &= ~MIIM_BCM54XX_SHD_MODE_CTRL_SERDES_REG;
+    shdw = MIIM_BCM54XX_SHD_WR_ENCODE(MIIM_BCM54XX_SHD_MODE_CTRL,
+                                      shdw);
+    phy_write(phydev, MDIO_DEVAD_NONE, MIIM_BCM54XX_SHD, shdw);
+    /*
+     * Configure PHY LEDs
+     *
+     * The result is the right LED is used for link activity and
+     * the left LED is off.
+     */
+    led = 0xef;
+    led = MIIM_BCM54XX_SHD_WR_ENCODE(MIIM_BCM54XX_SHD_LED_SEL_1,
+                                     led);
+    phy_write(phydev, MDIO_DEVAD_NONE, MIIM_BCM54XX_SHD, led);
+
+    return 0;
+}
+
+#ifdef CONFIG_TSEC_ENET
+int board_eth_init(bd_t *bis)
+{
+    struct fsl_pq_mdio_info mdio_info;
+    struct tsec_info_struct tsec_info[4];
+    int num = 0;
+
+#ifdef CONFIG_TSEC1
+    SET_STD_TSEC_INFO(tsec_info[num], 1);
+    num++;
+#endif
+#ifdef CONFIG_TSEC2
+    SET_STD_TSEC_INFO(tsec_info[num], 2);
+    if (is_serdes_configured(SGMII_TSEC2)) {
+        puts("eTSEC2 is in sgmii mode.\n");
+        tsec_info[num].flags |= TSEC_SGMII;
+    }
+    num++;
+#endif
+#ifdef CONFIG_TSEC3
+    SET_STD_TSEC_INFO(tsec_info[num], 3);
+    if (is_serdes_configured(SGMII_TSEC3)) {
+        puts("eTSEC3 is in sgmii mode.\n");
+        tsec_info[num].flags |= TSEC_SGMII;
+    }
+    num++;
+#endif
+
+    if (!num) {
+        printf("No TSECs initialized\n");
+        return 0;
+    }
+
+    mdio_info.regs = (struct tsec_mii_mng *)CONFIG_SYS_MDIO_BASE_ADDR;
+    mdio_info.name = DEFAULT_MII_NAME;
+
+    fsl_pq_mdio_init(bis, &mdio_info);
+
+    tsec_eth_init(bis, tsec_info, num);
+
+    return pci_eth_init(bis);
+}
+#endif
+
+void board_reset(void)
+{
+    printf("Using CPLD to reset board\n");
+
+    /* active low reset */
+    cpld_wr(CPLD_REG_RESET_CTRL_0, ~CPLD_RESET_SYSTEM_L && 0xFF);
+
+    while (1);
+
+}
+
+
+/*******************************************************************************
+ *
+ * MISC initializations after relocating to RAM.  Full C environment available.
+ * Before configuring network interfaces.
+ *
+ */
+
+int misc_init_r(void)
+{
+    u8 val;
+
+    /*
+     * Take a few things out of reset:
+     *   MGMT 1G PHY
+     *   USB PHY
+     *   USB HUB
+     *   I2C Expander
+     *   I2C Switch
+     */
+
+    /* Step 1 - put 1G mgmt phy, usb and i2c devices into reset */
+    val = cpld_rd(CPLD_REG_RESET_CTRL_0);
+    val &= ~CPLD_RESET_BCM54616S_L;
+    val &= ~CPLD_RESET_USB_PHY_L;
+    cpld_wr(CPLD_REG_RESET_CTRL_0, val);
+
+    val = cpld_rd(CPLD_REG_RESET_CTRL_1);
+    val &= ~CPLD_RESET_I2C_BUFFER_L;
+    cpld_wr(CPLD_REG_RESET_CTRL_1, val);
+
+    val = cpld_rd(CPLD_REG_RESET_CTRL_2);
+    val &= ~CPLD_RESET_USB_FLASH_CTRL_L;
+    val &= ~CPLD_RESET_USB_HUB_L;
+    cpld_wr(CPLD_REG_RESET_CTRL_2, val);
+    udelay(10000);
+
+    /* Step 2 - take 1G mgmt phy, usb and i2c devices out of reset */
+    val = cpld_rd(CPLD_REG_RESET_CTRL_0);
+    val |= CPLD_RESET_BCM54616S_L;
+    val |= CPLD_RESET_USB_PHY_L;
+    cpld_wr(CPLD_REG_RESET_CTRL_0, val);
+
+    val = cpld_rd(CPLD_REG_RESET_CTRL_1);
+    val |= CPLD_RESET_I2C_BUFFER_L;
+    cpld_wr(CPLD_REG_RESET_CTRL_1, val);
+
+    val = cpld_rd(CPLD_REG_RESET_CTRL_2);
+    val |= CPLD_RESET_USB_FLASH_CTRL_L;
+    val |= CPLD_RESET_USB_HUB_L;
+    cpld_wr(CPLD_REG_RESET_CTRL_2, val);
+
+    udelay(10000);
+
+    return 0;
+}
+
+/*******************************************************************************
+ *
+ * MISC initializations after relocating to RAM.  Full C environment available.
+ *
+ * Go through the CPLD register spec and set interesting bits here.
+ */
+extern int populate_env(char *env_name,  u8 type_code);
+extern void env_write_default_if_crc_bad(void);
+
+int last_stage_init(void)
+{
+    u8 led;
+    /*
+     * Set u-boot env which is required by ONIE:
+     */
+
+#if defined(CONFIG_SYS_EEPROM_LOAD_ENV_MAC)
+    mac_read_from_eeprom();
+#endif
+
+#ifdef CONFIG_POPULATE_SERIAL_NUMBER
+    /* serial# */
+    /*populate_serial_number();*/
+    populate_env("serial#", TLV_CODE_SERIAL_NUMBER);
+
+    /* onie_platform */
+    populate_env("onie_platform", TLV_CODE_PLATFORM_NAME);
+
+    /* onie_version */
+    populate_env("onie_version", TLV_CODE_ONIE_VERSION);
+
+#endif
+
+#ifdef CONFIG_ENV_WRITE_DEFAULT_IF_CRC_BAD
+    /* Check u-boot environment variable.
+     * If the env in flash is corrupt then
+     * write the default env with a valid CRC.
+     */
+    env_write_default_if_crc_bad();
+#endif
+
+//#ifdef CONFIG_FIX_VARIABLE
+    /* Update fix env if its value is incorrect */
+    check_fix_env();
+//#endif /* CONFIG_FIX_VARIABLE */
+
+    /* Disable WDT because DUT is in bootloader, not runtime. */
+    board_WDT_set(0);
+    board_ExpMod_set(1);
+    GPIO_init();
+    BCM54616S_init();
+
+    /*
+     * Set the 10 front panel LEDs + 7-segment stack ID to
+     * reasonable values:
+     *
+     *   Diag
+     *   Fan 1/2
+     *   PSU 1/2
+     *   POE
+     *   Module 1/2
+     *   Stack master/slave
+     *   Stack link
+     */
+
+    /*PSU*/
+/*
+PWR 0 (LED_G)	1	1: Power module 0 is not presented
+0: Power module 0 is presented and work well
+PWR 0 (LED_A)	1	1: Power module 0 is not presented
+0: Power module 0 is presented but power good is fail
+*/
+	led = (cpld_rd(CPLD_REG_SYSTEM_LED_CTRL_0) | CPLD_SYS_LED_PWR_0_MASK);	/*Read and set 0x11(off)*/
+	if( (cpld_rd(CPLD_REG_PSU_0_STATUS) & CPLD_PSU_PRESENT_L) == 0)	/*is present*/
+	{
+		if(
+			//((cpld_rd(CPLD_REG_PSU_0_STATUS) & CPLD_PSU_56V_GOOD_L ) != 0) /*not good*/
+			((cpld_rd(CPLD_REG_PSU_0_STATUS) & CPLD_PSU_AC_FAIL_L  ) == 0)	||/*not good*/
+			((cpld_rd(CPLD_REG_PSU_0_STATUS) & CPLD_PSU_12V_GOOD_L ) != 0)	/*not good*/
+		  )
+		{
+			led &= (~CPLD_SYS_LED_PWR_0_AMBER_L);
+		}
+		else	/*good*/
+		{
+			led &= (~CPLD_SYS_LED_PWR_0_GREEN_L);
+		}
+	}
+	cpld_wr(CPLD_REG_SYSTEM_LED_CTRL_0, led);
+
+	led = (cpld_rd(CPLD_REG_SYSTEM_LED_CTRL_0) | CPLD_SYS_LED_PWR_1_MASK);	/*Read and set 0x11(off)*/
+	if( (cpld_rd(CPLD_REG_PSU_1_STATUS) & CPLD_PSU_PRESENT_L) == 0)	/*is present*/
+	{
+		if(
+			//((cpld_rd(CPLD_REG_PSU_1_STATUS) & CPLD_PSU_56V_GOOD_L ) != 0) /*not good*/
+			((cpld_rd(CPLD_REG_PSU_1_STATUS) & CPLD_PSU_AC_FAIL_L  ) == 0)	||/*not good*/
+			((cpld_rd(CPLD_REG_PSU_1_STATUS) & CPLD_PSU_12V_GOOD_L ) != 0)	/*not good*/
+		  )
+		{
+			led &= (~CPLD_SYS_LED_PWR_1_AMBER_L);
+		}
+		else	/*good*/
+		{
+			led &= (~CPLD_SYS_LED_PWR_1_GREEN_L);
+		}
+	}
+
+	cpld_wr(CPLD_REG_SYSTEM_LED_CTRL_0, led);
+
+    /*Module*/
+	led = (cpld_rd(CPLD_REG_SYSTEM_LED_CTRL_1) | CPLD_SYS_LED_MODULE_0_MASK);	/*Read and set 0x11(off)*/
+	if( (cpld_rd(CPLD_REG_MODULE_0_STATUS) & CPLD_MODULE_PRESENT_L) == 0)	/*is present*/
+	{
+		led &= (~CPLD_SYS_LED_MODULE_0_GREEN_L);
+	}
+	else
+	{
+		led &= (~CPLD_SYS_LED_MODULE_0_AMBER_L);
+	}
+	cpld_wr(CPLD_REG_SYSTEM_LED_CTRL_1, led);
+
+
+	led = (cpld_rd(CPLD_REG_SYSTEM_LED_CTRL_1) | CPLD_SYS_LED_MODULE_1_MASK);	/*Read and set 0x11(off)*/
+	if( (cpld_rd(CPLD_REG_MODULE_1_STATUS) & CPLD_MODULE_PRESENT_L) == 0)	/*is present*/
+	{
+		led &= (~CPLD_SYS_LED_MODULE_1_GREEN_L);
+	}
+	else
+	{
+		led &= (~CPLD_SYS_LED_MODULE_1_AMBER_L);
+	}
+	cpld_wr(CPLD_REG_SYSTEM_LED_CTRL_1, led);
+
+    /*FAN*/
+	led = (cpld_rd(CPLD_REG_SYSTEM_LED_CTRL_1) | CPLD_SYS_LED_FAN_0_MASK);	/*Read and set 0x11(off)*/
+	if( (cpld_rd(CPLD_REG_FAN_STATUS) & CPLD_FAN_PRESENT_0_L) == 0)	/*is present*/
+	{
+		led &= (~CPLD_SYS_LED_FAN_0_GREEN_L);
+	}
+	else
+	{
+		led &= (~CPLD_SYS_LED_FAN_0_AMBER_L);
+	}
+	cpld_wr(CPLD_REG_SYSTEM_LED_CTRL_1, led);
+
+	led = (cpld_rd(CPLD_REG_SYSTEM_LED_CTRL_1) | CPLD_SYS_LED_FAN_1_MASK);	/*Read and set 0x11(off)*/
+	if( (cpld_rd(CPLD_REG_FAN_STATUS) & CPLD_FAN_PRESENT_1_L) == 0)	/*is present*/
+	{
+		led &= (~CPLD_SYS_LED_FAN_1_GREEN_L);
+	}
+	else
+	{
+		led &= (~CPLD_SYS_LED_FAN_1_AMBER_L);
+	}
+	cpld_wr(CPLD_REG_SYSTEM_LED_CTRL_1, led);
+
+    /*Everything is ok, Diag LED Green ON*/
+    led = cpld_rd(CPLD_REG_SYSTEM_LED_CTRL_0);
+    led |= CPLD_SYS_LED_DIAG_MASK;
+    if(get_boot_ok())
+	led &= (~CPLD_SYS_LED_DIAG_GREEN_L);
+    else
+	led &= (~CPLD_SYS_LED_DIAG_AMBER_L);
+
+    cpld_wr(CPLD_REG_SYSTEM_LED_CTRL_0, led);
+
+    return 0;
+}
+
+void fdt_fixup_board(void *fdt)
+{
+
+}
diff --git a/board/accton/as4600_54t/as4600_54t_misc.c b/board/accton/as4600_54t/as4600_54t_misc.c
new file mode 100644
index 0000000..80001fe
--- /dev/null
+++ b/board/accton/as4600_54t/as4600_54t_misc.c
@@ -0,0 +1,420 @@
+/*
+ * File:        $(BOARD)_misc.c
+ * Purpose:     To define the specific command and
+ *              function of this board.
+ *
+ * Notes:
+ * History:
+ *  2013/08/26    -- Aaron Lien, Initial version
+ *
+ * Copyright (C) 2013  Accton Corporation
+ */
+#include <stdarg.h>
+#include <common.h>
+#include <command.h>
+#include <miiphy.h>
+#include <linux/ctype.h>
+#include <linux/stddef.h>
+#include "board.h"
+#include <version.h>
+#include <asm/mpc85xx_gpio.h>
+#include "configs/onie_version.h"
+#if 0   //local debug print
+#undef debug
+#define debug(fmt,args...)	printf (fmt ,##args)
+#endif	/* local debug print*/
+
+extern int i2c_set_bus_num(unsigned int bus);
+extern int i2c_probe(uchar chip);
+extern int i2c_write(u8 dev, uint addr, int alen, u8 *data, int length);
+extern int i2c_read(u8 dev, uint addr, int alen, u8 *data, int length);
+
+/*******************************************************************************
+ *
+ * CPU Core
+ *
+ */
+
+/* clock ratio table, (e500 core/CCB) x 10 */
+int TBL_core_ccb_ratio[8]= { 40, 45, 10, 15, 20, 25, 30, 35 };
+
+#define SYSCLK_66	     66666667
+#define SYSCLK_83	     83333333
+#define SYSCLK_100      100000000
+#define DDRCLK_166  	166666666 /* DDRCLK on P1_P2 RDB */
+#define DDRCLK_200  	200000000 /* DDRCLK on P1_P2 RDB */
+#define DDRCLK_333  	333333333 /* DDRCLK on P1_P2 RDB */
+#define DDRCLK_400  	400000000 /* DDRCLK on P1_P2 RDB */
+
+unsigned long get_board_sys_clk(void)
+{
+    int core_ratio, ccb_ratio, core_speed, r, f;
+
+    /* Core clock : CCB clock */
+    core_ratio = (*(uint *)CCSR_GBLUTI_PORPLLSR >> 16) & 0x3F;
+    core_ratio &= 0x07;
+    r = TBL_core_ccb_ratio[core_ratio];
+
+    /* CCB clock : SYSCLK */
+    ccb_ratio = (*(uint *)CCSR_GBLUTI_PORPLLSR >> 1) & 0x1F;
+    r *= ccb_ratio;
+
+    /* Core Speed, MHz */
+    core_speed = (*(uint *)CCSR_GBLUTI_PORDEVSR2 >> 19) & 0x1;
+
+    f = core_speed ? 1200 : 1000;
+    f = (f*10)/r;
+
+    if(f < 70)
+        return SYSCLK_66;
+    else if(f < 90)
+        return SYSCLK_83;
+    else
+        return SYSCLK_100;
+
+}
+
+/*******************************************************************************
+ *
+ * CPLD I/O
+ *
+ */
+u8 cpld_rd(u32 reg)
+{
+    return in_8(((u8 *)CONFIG_SYS_CPLD_BASE + reg));
+}
+
+void cpld_wr(u32 reg, u8 data)
+{
+    out_8(((u8 *)CONFIG_SYS_CPLD_BASE + reg), data);
+}
+
+static void CPLD_write_WDT(uchar bit_mask, uchar val)
+{
+    u8 d;
+
+    d = cpld_rd(CPLD_REG_SYS_CONTROL);
+    d = (d & (~bit_mask)) | val;
+    cpld_wr(CPLD_REG_SYS_CONTROL, d);
+}
+
+/* ------------------------------------------------------------------------
+ * FUNCTION: board_WDT_set
+ * PURPOSE:	Enable/disable watch dog timer.
+ * INPUT:
+ *          state -  0 = disable, 1 = enable.
+ * OUTPUT:	None
+ * RETURN:  None
+ * NOTES:
+ */
+void board_WDT_set(int state)
+{
+    if(state) {
+        CPLD_write_WDT(CPLD_WDT_ENABLE, 1);
+    } else {
+        CPLD_write_WDT(CPLD_WDT_ENABLE, 0);
+    }
+}
+
+/* ------------------------------------------------------------------------
+ * FUNCTION: board_MOD_set
+ * PURPOSE:	Enable/disable Expend Module GPIO
+ * INPUT:
+ *          state -  0 = disable, 1 = enable.
+ * OUTPUT:  None
+ * RETURN:  None
+ * NOTES:
+ */
+void board_ExpMod_set(int state)
+{
+        /*
+         * GPIO
+         * 5 : Output pin, ExpMod0 Power EN_L, low(enable Mod) high(disable Mod);
+         * 6 : Output pin, ExpMod1 Power EN_L, low(enable Mod) high(disable Mod);
+         */
+	if(state)
+	{
+		mpc85xx_gpio_set_low(GPIO_PORT(5));	/*low = enable*/
+		mpc85xx_gpio_set_low(GPIO_PORT(6));
+	}
+	else
+	{ 	mpc85xx_gpio_set_high(GPIO_PORT(5));	/*high = disable*/
+		mpc85xx_gpio_set_high(GPIO_PORT(6));
+	}
+}
+
+/* ------------------------------------------------------------------------
+ * FUNCTION: GPIO_init()
+ * PURPOSE:  Init GPIO
+ * INPUT:   None
+ * OUTPUT:  None
+ * RETURN:  None
+ * NOTES:
+ */
+void GPIO_init(void)
+{
+	/*Set JTAG GPIO to input (High Impedence) while unuse*/
+	/*
+	 * TCK output   GPIO 12
+	 * TDO input    GPIO 13
+	 * TMS output   GPIO 14
+	 * TDI output   GPIO 15
+	 */
+	mpc85xx_gpio_set_in(GPIO_PORT(12));
+	mpc85xx_gpio_set_in(GPIO_PORT(13));
+	mpc85xx_gpio_set_in(GPIO_PORT(14));
+	mpc85xx_gpio_set_in(GPIO_PORT(15));
+}
+
+void BCM54616S_init(void)
+{
+	const char* devname = miiphy_get_current_dev();
+	miiphy_write(devname, 1 ,0x1C, 0xB4E3);/*LED2:always high, 	  LED1:LED- low active*/
+	miiphy_write(devname, 1 ,0x1C, 0xB8EE);/*LED4:LED-A+ 10/100 high, LED3:LED-G+ 1000 high*/
+}
+
+/*******************************************************************************
+ *
+ * Fan control
+ *
+ */
+/* ------------------------------------------------------------------------
+ * FUNCTION: board_get_system_fan_rate
+ * PURPOSE:	Get system fan rate.
+ * INPUT:
+ *          id = system fan ID. (1=FAN1, 2=FAN2)
+ *
+ * OUTPUT:	None
+ * RETURN:
+ *          0 ~ 100 = duty cycle
+ *          -1  = Fail
+ * NOTES:
+ */
+int board_get_system_fan_rate(int id)
+{
+    uchar val, reg;
+    int duty_cycle;
+
+    /* Fan controller, ADT7473 @ channel #2 */
+    i2c_set_bus_num(I2C_CHANNEL_2); /* channel #2 */
+
+
+    if (i2c_probe(I2C_ADDR_FAN) != 0) {
+        printf("[Error] Cannot find fan controller I2C device, slave address = 0x%02X\n", I2C_ADDR_FAN);
+        return -1;
+    }
+    udelay(1000);
+
+    reg = (id == ID_SYS_FAN1) ? I2C_ADT7473_REG_PWM1 : I2C_ADT7473_REG_PWM3;
+
+    /* ADT7473 PWM duty cycle */
+    i2c_read(I2C_ADDR_FAN, reg ,1, &val, 1);
+
+    duty_cycle = ((int)val*100)/255;
+    debug("[duty_cycle] %d\n", duty_cycle);
+
+    return duty_cycle;
+}
+
+/* ------------------------------------------------------------------------
+ * FUNCTION: board_set_system_fan_rate
+ * PURPOSE:	Set system fan rate.
+ * INPUT:
+ *          id = system fan ID. (1=FAN1, 2=FAN2)
+ *          rate = duty cycle (0 ~ 100).
+ *
+ * OUTPUT:	None
+ * RETURN:
+ *          0   = Success
+ *          -1  = Fail
+ *          1   = Abort
+ * NOTES:
+ */
+int board_set_system_fan_rate(int id, int duty_cycle)
+{
+    uchar val, reg;
+
+    if( (duty_cycle < 0) || (duty_cycle > 100)) {
+        duty_cycle = DEFAULT_FAN_DUTY_CYCLE;
+    }
+
+    /* Fan controller, ADT7473 @ channel #2 */
+    i2c_set_bus_num(I2C_CHANNEL_2); /* channel #2 */
+
+    if (i2c_probe(I2C_ADDR_FAN) != 0) {
+        printf("[Error] Cannot find fan controller I2C device, slave address = 0x%02X\n", I2C_ADDR_FAN);
+        return -1;
+    }
+    udelay(1000);
+
+    reg = (id == ID_SYS_FAN1) ? I2C_ADT7473_REG_PWM1 : I2C_ADT7473_REG_PWM3;
+
+    /* ADT7473 PWM duty cycle */
+    val = (uchar)((duty_cycle*255)/100);
+    val = (val == 255) ? val : val+1;  /* round it to the nearest whole number */
+    debug("[val] 0x%02X\n", val);
+    i2c_write(I2C_ADDR_FAN, reg,1,&val,1);
+    udelay(1000);
+
+    return 0;
+}
+
+/* ------------------------------------------------------------------------
+ * FUNCTION: board_fan_init
+ * PURPOSE:	Initialize system fan controller.
+ * INPUT:
+ *          rate = duty cycle (0 ~ 100).
+ *
+ * OUTPUT:	None
+ * RETURN:
+ *          0   = Success
+ *          -1  = Fail
+ *          1   = Abort
+ * NOTES:
+ */
+int board_fan_init(int rate)
+{
+    unsigned char write_data;
+
+    /* Fan controller, ADT7473 @ channel #2 */
+    i2c_set_bus_num(I2C_CHANNEL_2);
+
+    if (i2c_probe(I2C_ADDR_FAN) != 0) {
+        printf("[Error] Cannot find fan controller I2C device, slave address = 0x%02X\n", I2C_ADDR_FAN);
+        return -1;
+    }
+    udelay(1000);
+
+    /* config system */
+    write_data = 0xE2;  /* PWMx configuration value, manual mode.*/
+    i2c_write(I2C_ADDR_FAN,I2C_ADT7473_REG_PWM1_CONF,1,&write_data,1);  /* config system FAN1 @ PWM1 */
+    udelay(1000);
+    i2c_write(I2C_ADDR_FAN,I2C_ADT7473_REG_PWM3_CONF,1,&write_data,1);  /* config system FAN2 @ PWM3 */
+    udelay(1000);
+
+    /* set system fan duty cycle */
+    if(rate > 0) {
+        board_set_system_fan_rate(ID_SYS_FAN1, rate);
+        board_set_system_fan_rate(ID_SYS_FAN2, rate);
+    }
+
+    return 0;
+}
+
+/* ------------------------------------------------------------------------
+ * FUNCTION: check_ver_env
+ * PURPOSE:  check ver in env, fix it if it is not correct.
+ * INPUT:      None
+ *
+ * OUTPUT:     None
+ * RETURN:
+ *          0   = Success
+ *          -1  = Fail
+ *          1   = Abort
+ * NOTES:
+ */
+
+int check_ver_env(void)
+{
+    char *ver_string = getenv("ver");
+    if(ver_string != NULL)
+    {
+        if(strcmp(ver_string,U_BOOT_VERSION_STRING)==0)
+            return 0;
+    }
+
+    printf("- Writing new $ver -\n");
+    setenv("ver",U_BOOT_VERSION_STRING);
+    saveenv();
+    return -1;
+}
+
+/* ------------------------------------------------------------------------
+ * FUNCTION: check_fix_env
+ * PURPOSE:  check env, fix it if it is not correct.
+ * INPUT:      None
+ *
+ * OUTPUT:     None
+ * RETURN:
+ *          0   = Success
+ *          -1  = Fail
+ *          1   = Abort
+ * NOTES:
+ */
+
+#define CHECK_ENV(ENV_NAME,ENV_STRING) \
+    while(1)	\
+    {	\
+	env_string = getenv(ENV_NAME);	\
+	if(env_string != NULL)	\
+	{	\
+		if(strcmp(env_string,ENV_STRING) == 0)	\
+			break;	\
+	}	\
+	need_update = 1;	\
+	setenv(ENV_NAME,ENV_STRING);	\
+	printf("- Updating $" ENV_NAME " -\n");	\
+    }
+
+int check_fix_env(void)
+{
+    int need_update = 0;
+    char *env_string = NULL;
+
+    CHECK_ENV("ver",U_BOOT_VERSION_STRING)
+    CHECK_ENV("platform",PLATFORM_STRING)
+
+    if(need_update == 1)
+	saveenv();
+
+    return 0;
+}
+
+/*******************************************************************************
+ * u-boot command to show system clock infornation.
+ */
+
+static int do_show_clock_info(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    int core_ratio, ccb_ratio, ddr_ratio, core_speed, r, f;
+    sys_info_t sysinfo;
+    char buf[32];
+
+    printf("PORPLLSR = 0x%08X\n", *(uint *)CCSR_GBLUTI_PORPLLSR);
+    printf("PORDEVSR2 = 0x%08X\n", *(uint *)CCSR_GBLUTI_PORDEVSR2);
+
+    /* Core clock : CCB clock */
+    core_ratio = (*(uint *)CCSR_GBLUTI_PORPLLSR >> 16) & 0x3F;
+    printf("Clock ratio of CPU core and CCB = 0x%08X\n", core_ratio);
+    core_ratio &= 0x07;
+    r = TBL_core_ccb_ratio[core_ratio];
+
+    /* CCB clock : SYSCLK */
+    ccb_ratio = (*(uint *)CCSR_GBLUTI_PORPLLSR >> 1) & 0x1F;
+    printf("Clock ratio of CCB and SYSCLK = 0x%08X\n", ccb_ratio);
+    r *= ccb_ratio;
+
+    /* Core Speed, MHz */
+    core_speed = (*(uint *)CCSR_GBLUTI_PORDEVSR2 >> 19) & 0x1;
+    printf("CPU core speed = %sHz\n", core_speed ? "1.2G" : "1G");
+
+    f = core_speed ? 1200 : 1000;
+    printf("System Clock(SYSCLK) = %d MHz\n", (f*10)/r);
+
+    /* DDR clock : DDRCLK */
+    ddr_ratio = (*(uint *)CCSR_GBLUTI_PORPLLSR >> 9) & 0x1F;
+    printf("Clock ratio of DDR complex and DDRCLK = 0x%08X\n", ddr_ratio);
+
+    /* DDR data rate */
+    get_sys_info(&sysinfo);
+    printf("Configuration of DDR data rate = %s MT/s\n",
+           strmhz(buf, sysinfo.freqDDRBus));
+
+    return 0;
+}
+
+U_BOOT_CMD(
+    clkinfo, CONFIG_SYS_MAXARGS, 1,	do_show_clock_info,
+    "clkinfo\t- show clock information.",
+    ""
+);
diff --git a/board/accton/as4600_54t/board.h b/board/accton/as4600_54t/board.h
new file mode 100644
index 0000000..c0db3ca
--- /dev/null
+++ b/board/accton/as4600_54t/board.h
@@ -0,0 +1,235 @@
+/*
+ * File:        board.h
+ * Purpose:     To define the specific function call of this board.
+ *
+ * Notes:
+ * History:
+ *  2013/08/26    -- Aaron Lien, Initial version
+ *
+ * Copyright (C) 2013  Accton Corporation
+ */
+
+#ifndef __BOARD_H__
+#define __BOARD_H__
+
+/////////////////////////////////////////////////////////////////////////
+/* CPU */
+#define CONFIG_CPU_GBLUTI_BAR (CONFIG_SYS_CCSRBAR+0xE0000)
+#define CCSR_GBLUTI_PORPLLSR     CONFIG_CPU_GBLUTI_BAR
+#define CCSR_GBLUTI_PORDEVSR2    (CONFIG_CPU_GBLUTI_BAR+0x14)
+
+/////////////////////////////////////////////////////////////////////////
+/* CPLD */
+#define CPLD_REG_VERSION           (0x00)
+#  define CPLD_VERSION_H_MASK        (0xF0)
+#  define CPLD_VERSION_H_SHIFT       (4)
+#  define CPLD_VERSION_L_MASK        (0x0F)
+#  define CPLD_VERSION_L_SHIFT       (0)
+
+#define CPLD_REG_RESET_CTRL_0      (0x01) /* all resets active low */
+#  define CPLD_RESET_SYSTEM_L		(1 << 7)
+#  define CPLD_RESET_CPU_HRESET_L	(1 << 6)
+#  define CPLD_RESET_CPU_SRESET_L	(1 << 5)
+#  define CPLD_RESET_CPU_TRST_L		(1 << 4)
+#  define CPLD_RESET_NOR_FLASH_L	(1 << 3)
+#  define CPLD_RESET_USB_PHY_L		(1 << 1)
+#  define CPLD_RESET_BCM54616S_L	(1 << 0) /* Front panel mgmt PHY */
+
+#define CPLD_REG_RESET_CTRL_1      (0x02) /* all resets active low */
+#  define CPLD_RESET_I2C_BUFFER_L	(1 << 7)
+#  define CPLD_RESET_RTC_L		(1 << 6)
+#  define CPLD_RESET_POE_CONTROLLER_L	(1 << 5)
+#  define CPLD_RESET_LED_SHIFTER_L	(1 << 4)
+#  define CPLD_RESET_BCM56540_L		(1 << 3) /* Switch ASIC */
+#  define CPLD_RESET_BCM84754_L		(1 << 2) /* 4x10G PHY */
+#  define CPLD_RESET_BCM54280_0_L	(1 << 1) /* 8x1G PHY BCM54280 0, 1, 2 */
+#  define CPLD_RESET_BCM54280_1_L	(1 << 0) /* 8x1G PHY BCM54280 3, 4, 5 */
+
+#define CPLD_REG_RESET_CTRL_2      (0x03) /* all resets active low */
+#  define CPLD_RESET_MODULE_0_L		(1 << 7)
+#  define CPLD_RESET_MODULE_1_L		(1 << 6)
+#  define CPLD_RESET_MODULE_0_QSFP_L	(1 << 5)
+#  define CPLD_RESET_MODULE_1_QSFP_L	(1 << 4)
+#  define CPLD_RESET_DDR_GROUP0_L	(1 << 3)
+#  define CPLD_RESET_DDR_GROUP1_L	(1 << 2)
+#  define CPLD_RESET_USB_FLASH_CTRL_L	(1 << 1)
+#  define CPLD_RESET_USB_HUB_L		(1 << 0)
+
+/* LEDs are active low */
+#define CPLD_REG_SYSTEM_LED_CTRL_0  (0x04)
+#  define CPLD_SYS_LED_DIAG_MASK	(0xC0)
+#    define CPLD_SYS_LED_DIAG_GREEN_L		(1 << 7)
+#    define CPLD_SYS_LED_DIAG_AMBER_L		(1 << 6)
+#  define CPLD_SYS_LED_POE_MASK		(0x30)
+#    define CPLD_SYS_LED_POE_GREEN_L		(1 << 5)
+#    define CPLD_SYS_LED_POE_AMBER_L		(1 << 4)
+#  define CPLD_SYS_LED_PWR_0_MASK	(0x0C)
+#    define CPLD_SYS_LED_PWR_0_GREEN_L		(1 << 3)
+#    define CPLD_SYS_LED_PWR_0_AMBER_L		(1 << 2)
+#  define CPLD_SYS_LED_PWR_1_MASK	(0x03)
+#    define CPLD_SYS_LED_PWR_1_GREEN_L		(1 << 1)
+#    define CPLD_SYS_LED_PWR_1_AMBER_L		(1 << 0)
+
+#define CPLD_REG_SYSTEM_LED_CTRL_1  (0x05)
+#  define CPLD_SYS_LED_FAN_0_MASK	(0xC0)
+#    define CPLD_SYS_LED_FAN_0_GREEN_L		(1 << 7)
+#    define CPLD_SYS_LED_FAN_0_AMBER_L		(1 << 6)
+#  define CPLD_SYS_LED_FAN_1_MASK	(0x30)
+#    define CPLD_SYS_LED_FAN_1_GREEN_L		(1 << 5)
+#    define CPLD_SYS_LED_FAN_1_AMBER_L		(1 << 4)
+#  define CPLD_SYS_LED_MODULE_0_MASK	(0x0C)
+#    define CPLD_SYS_LED_MODULE_0_GREEN_L	(1 << 3)
+#    define CPLD_SYS_LED_MODULE_0_AMBER_L	(1 << 2)
+#  define CPLD_SYS_LED_MODULE_1_MASK	(0x03)
+#    define CPLD_SYS_LED_MODULE_1_GREEN_L	(1 << 1)
+#    define CPLD_SYS_LED_MODULE_1_AMBER_L	(1 << 0)
+
+#define CPLD_REG_SYSTEM_LED_CTRL_2  (0x06)
+#  define CPLD_SYS_LED_STACKING_1_MASK	(0xC0)
+#    define CPLD_SYS_LED_STACKING_GREEN_L	(1 << 7)
+#    define CPLD_SYS_LED_STACKING_AMBER_L	(1 << 6)
+#  define CPLD_SYS_LED_STACK_LINK_MASK	(0x30)
+#    define CPLD_SYS_LED_STACK_LINK_GREEN_L	(1 << 5)
+#    define CPLD_SYS_LED_STACK_LINK_AMBER_L	(1 << 4)
+
+#define CPLD_REG_SYS_CONTROL		(0x07)
+#  define CPLD_WDT_ENABLE			(1 << 7)
+#  define CPLD_WDT_STATUS			(1 << 6)
+#  define CPLD_WDT_KICK				(1 << 5)
+
+#define CPLD_REG_7SEGMENT_LED		(0x09)
+
+#define CPLD_REG_SFPP_PRESENT		(0x0a)
+#  define CPLD_SFPP_PRESENT_PORT_0		(1 << 7)
+#  define CPLD_SFPP_PRESENT_PORT_1		(1 << 6)
+#  define CPLD_SFPP_PRESENT_PORT_2		(1 << 5)
+#  define CPLD_SFPP_PRESENT_PORT_3		(1 << 4)
+
+#define CPLD_REG_SFPP_RX_LOS		(0x0b)
+#  define CPLD_SFPP_RX_LOS_PORT_0		(1 << 7)
+#  define CPLD_SFPP_RX_LOS_PORT_1		(1 << 6)
+#  define CPLD_SFPP_RX_LOS_PORT_2		(1 << 5)
+#  define CPLD_SFPP_RX_LOS_PORT_3		(1 << 4)
+
+#define CPLD_REG_SFPP_TX_FAIL		(0x0c)
+#  define CPLD_SFPP_TX_FAIL_PORT_0		(1 << 7)
+#  define CPLD_SFPP_TX_FAIL_PORT_1		(1 << 6)
+#  define CPLD_SFPP_TX_FAIL_PORT_2		(1 << 5)
+#  define CPLD_SFPP_TX_FAIL_PORT_3		(1 << 4)
+
+#define CPLD_REG_SFPP_TX_DISABLE	(0x0d)
+#  define CPLD_SFPP_TX_DISABLE_PORT_0		(1 << 7)
+#  define CPLD_SFPP_TX_DISABLE_PORT_1		(1 << 6)
+#  define CPLD_SFPP_TX_DISABLE_PORT_2		(1 << 5)
+#  define CPLD_SFPP_TX_DISABLE_PORT_3		(1 << 4)
+
+#define CPLD_REG_SFPP_SPEED		(0x0e)
+#  define CPLD_SFPP_SPEED_PORT_0		(1 << 7)  /* 0 - 1G, 1 - 10G */
+#  define CPLD_SFPP_SPEED_PORT_1		(1 << 6)
+#  define CPLD_SFPP_SPEED_PORT_2		(1 << 5)
+#  define CPLD_SFPP_SPEED_PORT_3		(1 << 4)
+
+#define CPLD_REG_FAN_STATUS		(0x0f)
+/*Kenny Cheng: Not follow HW spec*/
+//#  define CPLD_FAN_PRESENT_0_L			(1 << 7) /* 0 - present */
+//#  define CPLD_FAN_PRESENT_1_L			(1 << 6) /* 1 - not present */
+#  define CPLD_FAN_PRESENT_1_L			(1 << 7) /* 0 - present */
+#  define CPLD_FAN_PRESENT_0_L			(1 << 6) /* 1 - not present */
+#  define CPLD_FAN_DIRECTION_0_L		(1 << 5) /* 0 - back to front */
+#  define CPLD_FAN_DIRECTION_1_L		(1 << 4) /* 1 - front to back */
+
+#define CPLD_REG_PUSH_BUTTON_STATUS	(0x10)
+#  define CPLD_PB_STATUS_NON_STACKING		(1 << 7)
+#  define CPLD_PB_STATUS_STACKING_MASTER	(1 << 6)
+#  define CPLD_PB_STATUS_STACKING_SLAVE		(1 << 5)
+
+#define CPLD_REG_POE_STATUS		(0x11)
+#  define CPLD_POE_SYSTEM_VALID_L		(1 << 7)
+
+#define CPLD_REG_POE_CONTROL		(0x12)
+#  define CPLD_POE_ENABLE			(1 << 7)
+
+#define CPLD_REG_PSU_1_STATUS		(0x13)
+#  define CPLD_PSU_PRESENT_L			(1 << 7)
+#  define CPLD_PSU_AC_FAIL_L			(1 << 6) /* 0 - input fail */
+#  define CPLD_PSU_56V_GOOD_L			(1 << 5)
+#  define CPLD_PSU_12V_GOOD_L			(1 << 4)
+#  define CPLD_PSU_FAN_FAIL_L			(1 << 3) /* 0 - fan fail */
+#  define CPLD_PSU_ALERT_L			(1 << 2) /* 0 - need to read module EEPROM */
+
+#define CPLD_REG_PSU_0_STATUS		(0x14)
+#  define CPLD_PSU_PRESENT_L			(1 << 7)
+#  define CPLD_PSU_AC_FAIL_L			(1 << 6) /* 0 - input fail */
+#  define CPLD_PSU_56V_GOOD_L			(1 << 5)
+#  define CPLD_PSU_12V_GOOD_L			(1 << 4)
+#  define CPLD_PSU_FAN_FAIL_L			(1 << 3) /* 0 - fan fail */
+#  define CPLD_PSU_ALERT_L			(1 << 2) /* 0 - need to read module EEPROM */
+
+#define CPLD_REG_RPS_POWER_STATUS	(0x15)
+#  define CPLD_RPS_PRESENT_L			(1 << 7)
+#  define CPLD_RPS_FAIL_L			(1 << 6) /* 0 - RPS fail */
+
+#define CPLD_REG_MODULE_0_STATUS	(0x16)
+#  define CPLD_MODULE_PRESENT_L			(1 << 7)
+
+#define CPLD_REG_MODULE_1_STATUS	(0x17)
+#  define CPLD_MODULE_PRESENT_L			(1 << 7)
+
+u8 cpld_rd(u32 reg);
+void cpld_wr(u32 reg, u8 data);
+void board_WDT_set(int state);
+void board_ExpMod_set(int state);
+
+/////////////////////////////////////////////////////////////////////////
+/* I2C */
+#define I2C_CHANNEL_1               0x00
+#define I2C_CHANNEL_2               0x01
+
+/* I2C bus switch */
+#define I2C_ADDR_PCA9548            0x70
+
+/* channel 1 devices */
+#define I2C_ADDR_SFP                0x50    /* port 49~52 */
+#define I2C_ADDR_DS100BR            0x56
+#define I2C_ADDR_PD69100            0x20
+#define I2C_ADDR_TMP75              0x49
+#define I2C_ADDR_ADT7473            0x2E
+
+/* channel 2 devices */
+#define I2C_ADDR_FAN                0x2E
+#define I2C_ADDR_EXPMOD_0           0x54
+#define I2C_ADDR_EXPMOD_1           0x55
+#define I2C_ADDR_PSU_0              0x51
+#define I2C_ADDR_PSU_1              0x52
+#define I2C_ADDR_RTC_DS1672         0x68
+
+/////////////////////////////////////////////////////////////////////////
+/* FAN */
+enum FAN_ID_E{
+    ID_SYS_FAN1=1,
+    ID_SYS_FAN2,
+    ID_SYS_FAN_TOTAL
+};
+
+#define DEFAULT_FAN_DUTY_CYCLE 100
+
+#define FAN_DUTY_CYCLE_LOW          25
+#define FAN_DUTY_CYCLE_1            50
+#define FAN_DUTY_CYCLE_2            75
+#define FAN_DUTY_CYCLE_MAX          100
+
+#define I2C_ADT7473_REG_PWM1        0x30
+#define I2C_ADT7473_REG_PWM2        0x31
+#define I2C_ADT7473_REG_PWM3        0x32
+#define I2C_ADT7473_REG_PWM1_CONF   0x5C
+#define I2C_ADT7473_REG_PWM2_CONF   0x5D
+#define I2C_ADT7473_REG_PWM3_CONF   0x5E
+
+
+int board_fan_init(int rate);
+int board_get_system_fan_rate(int id);
+int board_set_system_fan_rate(int id, int duty_cycle);
+
+#define GPIO_PORT(x) (0x80000000>>(x))
+
+#endif /* __BOARD_H__ */
diff --git a/board/accton/as4600_54t/bootf.c b/board/accton/as4600_54t/bootf.c
new file mode 100644
index 0000000..72b40b1
--- /dev/null
+++ b/board/accton/as4600_54t/bootf.c
@@ -0,0 +1,54 @@
+/*
+* File:        bootf.c
+* Purpose:     To boot the fastpath application image.
+*
+* Notes:
+* History:
+*  2012/03/08    -- Aaron Lien, Initial version
+*
+* Copyright (C) 2012  Accton Corporation & authors.
+*/
+#include <common.h>
+#include "fastpath.h"
+
+
+/* STK image = {STK header + uImage}*/
+static int do_bootf(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    char * local_argv[3];
+    ulong	addr;
+    char str_addr[30], tmp[30];
+    stkFileHeader_t *header;
+
+    /* <addr> */
+    addr = CONFIG_SYS_LOAD_ADDR;		/* Default Load Address */
+    if(argc >= 2)
+        addr = simple_strtoul(argv[1], NULL, 16);
+
+    header = (stkFileHeader_t *)addr;
+
+    addr += header->stk_header_size;    /* uImage start address */
+    sprintf(str_addr, "0x%08lX", addr);
+
+    /* <fdt#> */
+    if(argc >=3)
+        sprintf(tmp, "-f%s", argv[2]);
+    else
+        sprintf(tmp, "-f%d", CONFIG_FDT_INDEX);
+
+    /* <ex.> bootm 0x1000074 -f<fdt#> */
+    local_argv[0] = "bootm";
+    local_argv[1] = str_addr;
+    local_argv[2] = tmp;
+
+    return do_bootm(NULL, 0, 3, local_argv);
+}
+
+U_BOOT_CMD(
+    bootf, CONFIG_SYS_MAXARGS, 1,	do_bootf,
+    "bootf\t- boot FASTPATH application image from memory.",
+    "[<addr> [<fdt#>]] - boot FASTPATH application image stored in memory.\n"
+    "\taddr: image address in memory.\n"
+    "\tfdt#: image# of flat device tree in FASTPATH image.\n"
+    "\n\tThe default fdt# is 4 which indicates the fdt is at image#4."
+);
diff --git a/board/accton/as4600_54t/cmd_dram_test.c b/board/accton/as4600_54t/cmd_dram_test.c
new file mode 100644
index 0000000..0200ca0
--- /dev/null
+++ b/board/accton/as4600_54t/cmd_dram_test.c
@@ -0,0 +1,487 @@
+#include <common.h>
+#include <command.h>
+
+#define diag_printf printf
+
+/**************************************************************
+ * diag_mem
+ *************************************************************/
+#define DIAG_MEM_TOTAL_SIZE         (0x80000000UL)
+#define DIAG_MEM_BASE_ADDR          (0x0UL)
+#define DIAG_MEM_MAX_ADDR           (DIAG_MEM_BASE_ADDR + DIAG_MEM_TOTAL_SIZE)
+
+#define DIAG_MEM_ADDRESS_ALIGN_WORD (4UL)
+#define DIAG_MEM_BACKUP_BUF_SIZE    (128UL*1024UL)
+
+#define DIAG_MEM_PATTERN_FIVE       (0x55555555UL)
+#define DIAG_MEM_PATTERN_ALPHA      (0xAAAAAAAAUL)
+
+static char diag_mem_backup_buf[DIAG_MEM_BACKUP_BUF_SIZE];
+static int last_percent = 0;
+static ulong timer_keep = 0;
+static ulong timer_change = 0;
+void show_progress(ulong startAddr, ulong endAddr, ulong currentAddr)
+{
+	ulong current_timer = get_timer(0);
+	//printf("%08X",currentAddr);
+	if((current_timer - timer_keep) > timer_change)
+	{
+		int percent = ((currentAddr - startAddr)) / (((endAddr-startAddr))/100);
+		if(percent != last_percent || (current_timer - timer_keep) > 1000)
+		{
+			printf("\r%08lX : %d%%",currentAddr,percent);
+			last_percent = percent;
+
+			if(timer_change == 0)
+			{
+				timer_change = (current_timer - timer_keep);//first timer range
+			}
+
+			timer_keep = current_timer;
+		}
+	}
+}
+
+int diagMemAddressBusTest(ulong startAddr, ulong endAddr)
+{
+    register ulong blockStartAddr;
+    register ulong blockSize;
+
+    register ulong pattern     = (ulong) DIAG_MEM_PATTERN_ALPHA;
+    register ulong antipattern = (ulong) DIAG_MEM_PATTERN_FIVE;
+
+    register ulong currAddr;
+    register ulong* ptrBackup;
+
+    register ulong ret = 0;
+	register ulong errorAddr = 0;
+
+    for(blockStartAddr=startAddr; blockStartAddr<endAddr; blockStartAddr+=DIAG_MEM_BACKUP_BUF_SIZE)
+    {
+        if(endAddr-blockStartAddr > DIAG_MEM_BACKUP_BUF_SIZE)
+        {
+            blockSize = DIAG_MEM_BACKUP_BUF_SIZE;
+        }
+        else
+        {
+            blockSize = endAddr-blockStartAddr;
+        }
+
+        ptrBackup = (ulong*)diag_mem_backup_buf;
+        for(currAddr=blockStartAddr; currAddr<blockStartAddr+blockSize; currAddr+=4, ptrBackup++)
+        {
+			if( (currAddr >= 0)
+                && (currAddr < 0x1000) )
+            {
+                continue;
+            }
+
+            if( (currAddr >= (ulong)(diagMemAddressBusTest))
+                && (currAddr < (ulong)(0x1000+diagMemAddressBusTest)) )
+            {
+                continue;
+            }
+
+            if( (currAddr >= (ulong)(diag_mem_backup_buf))
+                && (currAddr < (ulong)(DIAG_MEM_BACKUP_BUF_SIZE+diag_mem_backup_buf)) )
+            {
+                continue;
+            }
+
+			if( (currAddr >= (ulong)(0x7Fd00000)) 	/*Skip U-boot, might be protected*/
+                && (currAddr < (ulong)(0x80000000)) )
+            {
+                continue;
+            }
+
+            *ptrBackup = *((ulong*)currAddr);
+
+            *((ulong*)currAddr) = pattern;
+        }
+
+        //ptrBackup = (ulong*)diag_mem_backup_buf;	/*Kenny Cheng remove*/
+        for(currAddr=blockStartAddr; currAddr<blockStartAddr+blockSize; currAddr+=4)//, ptrBackup++) /*Kenny Cheng Remove */
+        {
+			if( (currAddr >= 0)
+                && (currAddr < 0x1000) )
+            {
+                continue;
+            }
+
+            if( (currAddr >= (ulong)(diagMemAddressBusTest))
+                && (currAddr < (ulong)(0x1000+diagMemAddressBusTest)) )
+            {
+                continue;
+            }
+
+            if( (currAddr >= (ulong)(diag_mem_backup_buf))
+                && (currAddr < (ulong)(DIAG_MEM_BACKUP_BUF_SIZE+diag_mem_backup_buf)) )
+            {
+                continue;
+            }
+
+			if( (currAddr >= (ulong)(0x7Fd00000)) 	/*Skip U-boot, might be protected*/
+                && (currAddr < (ulong)(0x80000000)) )
+            {
+                continue;
+            }
+
+            if( pattern != *((ulong*)currAddr) )
+            {
+				errorAddr = currAddr;
+                ret++;
+            }
+
+            *((ulong*)currAddr) = antipattern;
+        }
+
+        ptrBackup = (ulong*)diag_mem_backup_buf;
+        for(currAddr=blockStartAddr; currAddr<blockStartAddr+blockSize; currAddr+=4, ptrBackup++)
+        {
+			if( (currAddr >= 0)
+                && (currAddr < 0x1000) )
+            {
+                continue;
+            }
+
+            if( (currAddr >= (ulong)(diagMemAddressBusTest))
+                && (currAddr < (ulong)(0x1000+diagMemAddressBusTest)) )
+            {
+                continue;
+            }
+
+            if( (currAddr >= (ulong)(diag_mem_backup_buf))
+                && (currAddr < (ulong)(DIAG_MEM_BACKUP_BUF_SIZE+diag_mem_backup_buf)) )
+            {
+                continue;
+            }
+
+			if( (currAddr >= (ulong)(0x7Fd00000)) 	/*Skip U-boot, might be protected*/
+                && (currAddr < (ulong)(0x80000000)) )
+            {
+                continue;
+            }
+
+            if( antipattern != *((ulong*)currAddr) )
+            {
+				errorAddr = currAddr;
+                ret++;
+            }
+
+            *((ulong*)currAddr) = *ptrBackup;
+        }
+
+        if(ctrlc())
+        {
+            return -1;
+        }
+		else
+		{
+			/*show_progress(startAddr,endAddr,currAddr);*/
+		}
+    }
+
+	/*show_progress(startAddr,endAddr,blockStartAddr);*/
+
+    if(ret != 0)
+	{
+		diag_printf("errorAddr = 0x%08lX\n",errorAddr);
+        return -1;
+    }
+	else
+        return 0;
+}
+
+int diagMemDataBusTest(ulong startAddr, ulong endAddr)
+{
+    register ulong currAddr;
+    register ulong backup;
+    register ulong pattern;
+
+    /* Data Bust Test */
+    for(currAddr=startAddr; currAddr<endAddr; currAddr+=4)
+    {
+		if( (currAddr >= 0)
+         && (currAddr < 0x1000) )
+        {
+              continue;
+        }
+
+        if( (currAddr >= (ulong)(diagMemDataBusTest))
+            && (currAddr < (ulong)(0x1000+diagMemDataBusTest)) )
+        {
+            continue;
+        }
+
+        /* Perform a walking 1's test at the given address. */
+        for(pattern=1; pattern!=0; pattern<<=1)
+        {
+            backup = *((ulong*)currAddr);
+
+            /* Write the test pattern. */
+            *((ulong*)currAddr) = pattern;
+
+            /* Read it back (immediately is okay for this test). */
+            if(*((ulong*)currAddr) != pattern)
+            {
+                *((ulong*)currAddr) = backup;
+
+                diag_printf("(pattern = 0x%08lX)...", pattern);
+                return -1;
+            }
+
+            *((ulong*)currAddr) = backup;
+        }
+
+        if(ctrlc())
+        {
+            return -1;
+        }
+		else
+		{
+				/*show_progress(startAddr,endAddr,currAddr);*/
+		}
+    }
+
+	/*show_progress(startAddr,endAddr,currAddr);*/
+
+    return 0;
+}
+
+int do_diag_dram_func(ulong startAddr, ulong endAddr)
+{
+    /* address alignment */
+    startAddr -= (startAddr % DIAG_MEM_ADDRESS_ALIGN_WORD);
+    endAddr -= (endAddr % DIAG_MEM_ADDRESS_ALIGN_WORD);
+    //startAddr = (startAddr & ~(DIAG_MEM_ADDRESS_ALIGN_WORD-1));
+    //endAddr = (endAddr & ~(DIAG_MEM_ADDRESS_ALIGN_WORD-1));
+
+    diag_printf("START Address: 0x%08lX\n", startAddr);
+    diag_printf("END Address: 0x%08lX\n", endAddr);
+	last_percent = 0;
+	timer_change = 0;
+	timer_keep = get_timer(0);
+    diag_printf("Data Bus Test...\n");
+
+    if(diagMemDataBusTest(startAddr, endAddr) == 0)
+    {
+        diag_printf("\r%08lx~%08lx 100%% OK!\n",startAddr,endAddr);
+    }
+    else
+    {
+        diag_printf("FAIL!\n");
+	return -2;
+    }
+
+    last_percent = 0;
+    timer_change = 0;
+	timer_keep = get_timer(0);
+    diag_printf("Address Bus Test...\n");
+
+    if(diagMemAddressBusTest(startAddr, endAddr) == 0)
+    {
+        diag_printf("\r%08lx~%08lx 100%% OK!\n",startAddr,endAddr);
+    }
+    else
+    {
+        diag_printf("FAIL!\n");
+	return -3;
+    }
+
+	return 0;
+
+
+}
+
+int do_diag_dram_func_quick(ulong startAddr, ulong endAddr)
+{
+	register ulong blockStartAddr;
+    register ulong blockSize;
+
+    register ulong currAddr;
+    register ulong* ptrBackup;
+
+    register ulong ret = 0;
+	register ulong errorAddr = 0;
+
+    /* alignment */
+    startAddr -= (startAddr % DIAG_MEM_ADDRESS_ALIGN_WORD);
+    endAddr -= (endAddr % DIAG_MEM_ADDRESS_ALIGN_WORD);
+    //startAddr = (startAddr & ~(DIAG_MEM_ADDRESS_ALIGN_WORD-1));
+    //endAddr = (endAddr & ~(DIAG_MEM_ADDRESS_ALIGN_WORD-1));
+
+    for(blockStartAddr=startAddr; blockStartAddr<endAddr; blockStartAddr+=DIAG_MEM_BACKUP_BUF_SIZE)
+    {
+        if(endAddr-blockStartAddr > DIAG_MEM_BACKUP_BUF_SIZE)
+        {
+            blockSize = DIAG_MEM_BACKUP_BUF_SIZE;
+        }
+        else
+        {
+            blockSize = endAddr-blockStartAddr;
+        }
+
+        ptrBackup = (ulong*)diag_mem_backup_buf;
+        for(currAddr=blockStartAddr; currAddr<blockStartAddr+blockSize; currAddr+=4, ptrBackup++)
+        {
+	    if( (currAddr >= 0)
+                && (currAddr < 0x1000) )
+            {
+                continue;
+            }
+
+            if( (currAddr >= (ulong)(diagMemAddressBusTest))
+                && (currAddr < (ulong)(0x1000+diagMemAddressBusTest)) )
+            {
+                continue;
+            }
+
+            if( (currAddr >= (ulong)(diag_mem_backup_buf))
+                && (currAddr < (ulong)(DIAG_MEM_BACKUP_BUF_SIZE+diag_mem_backup_buf)) )
+            {
+                continue;
+            }
+
+	    if( (currAddr >= (ulong)(0x7Fd00000)) 	/*Skip diag log area*/
+                && (currAddr < (ulong)(0x80000000)) )
+            {
+                continue;
+            }
+
+            *ptrBackup = *((ulong*)currAddr);
+
+            *((ulong*)currAddr) = 0xAAAAAAAA;
+        }
+
+        ptrBackup = (ulong*)diag_mem_backup_buf;
+        for(currAddr=blockStartAddr; currAddr<blockStartAddr+blockSize; currAddr+=4, ptrBackup++)
+        {
+			if( (currAddr >= 0)
+                && (currAddr < 0x1000) )
+            {
+                continue;
+            }
+
+            if( (currAddr >= (ulong)(diagMemAddressBusTest))
+                && (currAddr < (ulong)(0x1000+diagMemAddressBusTest)) )
+            {
+                continue;
+            }
+
+            if( (currAddr >= (ulong)(diag_mem_backup_buf))
+                && (currAddr < (ulong)(DIAG_MEM_BACKUP_BUF_SIZE+diag_mem_backup_buf)) )
+            {
+                continue;
+            }
+
+			if( (currAddr >= (ulong)(0x7Fd00000)) 	/*Skip diag log area*/
+                && (currAddr < (ulong)(0x80000000)) )
+            {
+                continue;
+            }
+
+            if( 0xAAAAAAAA != *((ulong*)currAddr) )
+            {
+				errorAddr = currAddr;
+                ret++;
+            }
+
+            *((ulong*)currAddr) = *ptrBackup;
+        }
+
+        if(ctrlc())
+        {
+            return -1;
+        }
+		else
+		{
+			//diag_printf("\r%08X : %d%%",blockStartAddr,((blockStartAddr - startAddr)) / (((endAddr-startAddr))/100));
+		}
+    }
+
+	//diag_printf("\r%08X : %d%%",blockStartAddr,((blockStartAddr - startAddr)) / (((endAddr-startAddr))/100));
+
+    if(ret != 0)
+	{
+		diag_printf("\rerrorAddr = 0x%08lX\n",errorAddr);
+        return -1;
+    }
+	else
+	{
+		diag_printf("\r%08lX~%08lX 100%% OK!\n",startAddr,endAddr);
+        return 0;
+	}
+}
+
+int do_diag_dram_cmd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    ulong start = 0;
+    ulong end = 0;
+    int ret = 0;
+	ulong time_start = get_timer(0);
+    ulong time_end = 0;
+
+    if(argc < 3)
+    {
+        diag_printf("Usage:\n%s\n", cmdtp->usage);
+        return -1;
+    }
+	else if(argc >= 4)
+	{
+		if(strcmp("full",argv[3]) == 0)
+		{
+			start = simple_strtoul(argv[1], NULL, 16);
+			end = simple_strtoul(argv[2], NULL, 16);
+
+			if( start>DIAG_MEM_MAX_ADDR || end>DIAG_MEM_MAX_ADDR || start>=end)
+			{
+				diag_printf("invalid range");
+				return -1;
+			}
+
+			ret = do_diag_dram_func(start, end);
+		}
+		else
+		{
+			diag_printf("Usage:\n%s\n", cmdtp->usage);
+			return -1;
+		}
+	}
+	else
+	{
+		start = simple_strtoul(argv[1], NULL, 16);
+		end = simple_strtoul(argv[2], NULL, 16);
+
+		if( start>DIAG_MEM_MAX_ADDR || end>DIAG_MEM_MAX_ADDR || start>=end)
+		{
+			diag_printf("invalid range");
+			return -1;
+		}
+
+		ret = do_diag_dram_func_quick(start, end);
+	}
+
+
+    if(ret == 0)
+    {
+        diag_printf("DRAM test Success!\n");
+    }
+    else
+    {
+        diag_printf("DRAM test Fail!\n");
+    }
+
+	time_end = get_timer(0);
+	diag_printf("\nTime spend = %ldms\n",time_end-time_start);
+	return ret;
+}
+
+U_BOOT_CMD(
+    dram_test, 4, 0, do_diag_dram_cmd,
+    "memory test from startAddr to endAddr",
+    "dram_test <startAddr> <endAddr> [full]\n"
+    "Syntax:\n"
+    "    diag_dram <startAddr> <endAddr> [full]\n"
+    "Example:\n"
+    "    diag_dram 0x2000 0x1ffffffc\n"
+);
diff --git a/board/accton/as4600_54t/cmd_update_cpld.c b/board/accton/as4600_54t/cmd_update_cpld.c
new file mode 100644
index 0000000..02d3b9c
--- /dev/null
+++ b/board/accton/as4600_54t/cmd_update_cpld.c
@@ -0,0 +1,506 @@
+#include <common.h>
+#include <command.h>
+#include <malloc.h>
+#include <jbiport.h>
+#include <jbiexprt.h>
+#include "board.h"
+#include <asm/mpc85xx_gpio.h>
+
+#define CS_CPLD_JTAG_EXT    1   /* CPLD JTAG external connector pins */
+#define CS_CPLD_JTAG_GPIO   0   /* CPLD JTAG from GPIO pins */
+
+#define CFG_CPLD_REAL_TIME_ISP   /* Real-Time ISP (Real-Time in-system programmability) */
+/* AS4600_54T */
+/*
+ * TCK output 	GPIO 12
+ * TDO input	GPIO 13
+ * TMS output	GPIO 14
+ * TDI output 	GPIO 15
+ */
+
+/*******************************/
+/* GPIO */
+/*******************************/
+static void GPIO_Init(void)
+{
+	/*Set TCK TMS TDI to output port*/
+	//*(volatile unsigned int *)(0xFF70FC00) |= 0x000B0000;//12,14,15;
+	//*(volatile unsigned int *)(0xFF70FC00) &= (~0x00040000);//13
+
+	mpc85xx_gpio_set_low(GPIO_PORT(12));	/*TCK pull low*/
+	mpc85xx_gpio_set_high(GPIO_PORT(14));	/*TMS pull high*/
+	mpc85xx_gpio_set_high(GPIO_PORT(15));	/*TDI pull high*/
+	mpc85xx_gpio_set_in(GPIO_PORT(13));
+}
+
+/*Set port to high impedence while unuse*/
+static void GPIO_Finish(void)
+{
+	/*Set TCK TMS TDI to input port(High Impedence) */
+	//*(volatile unsigned int *)(0xFF70FC00) &= (~0x000F0000);//12,13,14,15;
+	mpc85xx_gpio_set_in(GPIO_PORT(12));
+	mpc85xx_gpio_set_in(GPIO_PORT(14));
+	mpc85xx_gpio_set_in(GPIO_PORT(15));
+	mpc85xx_gpio_set_in(GPIO_PORT(13));
+}
+
+static void CPLD_select_JTAG_channel(int mode)
+{
+	return ;
+}
+
+static void set_tdi(int val)	//15
+{
+	if(val == 0)
+		//*(volatile unsigned int *)(0xFF70FC08) &= (~0x00010000);
+		mpc85xx_gpio_set_low(GPIO_PORT(15));
+	else
+		mpc85xx_gpio_set_high(GPIO_PORT(15));
+		//*(volatile unsigned int *)(0xFF70FC08) |= (0x00010000);
+}
+
+static void set_tms(int val)	//14
+{
+	if(val == 0)
+		//*(volatile unsigned int *)(0xFF70FC08) &= (~0x00020000);
+		mpc85xx_gpio_set_low(GPIO_PORT(14));
+	else
+		//*(volatile unsigned int *)(0xFF70FC08) |= (0x00020000);
+		mpc85xx_gpio_set_high(GPIO_PORT(14));
+}
+
+static void set_tck(int val)	//12
+{
+	if(val == 0)
+		//*(volatile unsigned int *)(0xFF70FC08) &= (~0x00080000);
+		mpc85xx_gpio_set_low(GPIO_PORT(12));
+	else
+		//*(volatile unsigned int *)(0xFF70FC08) |= (0x00080000);
+		mpc85xx_gpio_set_high(GPIO_PORT(12));
+
+}
+
+static int get_tdo(void)	//13
+{
+	//if(( (*(volatile unsigned int *)(0xFF70FC08)) & 0x00040000) == 0)
+	if( !!mpc85xx_gpio_get(GPIO_PORT(13)) == 0)
+		return 0;
+	else
+		return 1;
+}
+
+
+int jbi_jtag_io(int tms, int tdi, int read_tdo)
+{
+    int tdo = 0;
+
+    /* TDI & TMS */
+	(tdi) ? set_tdi(1) : set_tdi(0);
+	(tms) ? set_tms(1) : set_tms(0);
+
+	/* TDO */
+    if(read_tdo)
+        tdo = get_tdo();
+
+	jbi_delay(2);
+    /* TCK */
+    set_tck(1);
+	jbi_delay(2);
+    set_tck(0);
+	jbi_delay(2);
+    return tdo;
+}
+
+/*******************************/
+/*******************************/
+
+void jbi_delay(long microseconds)
+{
+    while(microseconds-- > 0){
+        udelay(1);
+		udelay(1);/* more time */
+    }
+}
+
+void jbi_message(char *message_text)
+{
+    printf("%s\n", message_text);
+}
+
+void jbi_export_integer(char *key, long value)
+{
+    printf("Export: key = \"%s\", value = %ld\n", key, value);
+}
+
+void jbi_export_boolean_array(char *key, unsigned char *data, long count)
+{
+    long i;
+
+    printf("Export: key = \"%s\", %ld bits, value =\n", key, count);
+    for(i=0; i < count; i++)
+        printf("%02X ", data[i]);
+
+    printf("\n");
+}
+
+void *jbi_malloc(unsigned int size)
+{
+    void *ptr;
+
+    ptr = malloc(size);
+    if(!ptr)
+        printf("%s: request memory failed ! [addr]0x%08X, [size]0x%p\n", __FUNCTION__, size, ptr);
+
+    return ptr;
+}
+
+void jbi_free(void *ptr)
+{
+    if(ptr){
+        free(ptr);
+    }else{
+        debug("%s: reject free() with null pointer ! [addr]0x%p\n", __FUNCTION__, ptr);
+    }
+
+}
+
+/////////////////////////////////////////////////////////////////////////
+static char *error_text[] = {
+    /* JBIC_SUCCESS            0 */ "success",
+    /* JBIC_OUT_OF_MEMORY      1 */ "out of memory",
+    /* JBIC_IO_ERROR           2 */ "file access error",
+    /* JAMC_SYNTAX_ERROR       3 */ "syntax error",
+    /* JBIC_UNEXPECTED_END     4 */ "unexpected end of file",
+    /* JBIC_UNDEFINED_SYMBOL   5 */ "undefined symbol",
+    /* JAMC_REDEFINED_SYMBOL   6 */ "redefined symbol",
+    /* JBIC_INTEGER_OVERFLOW   7 */ "integer overflow",
+    /* JBIC_DIVIDE_BY_ZERO     8 */ "divide by zero",
+    /* JBIC_CRC_ERROR          9 */ "CRC mismatch",
+    /* JBIC_INTERNAL_ERROR    10 */ "internal error",
+    /* JBIC_BOUNDS_ERROR      11 */ "bounds error",
+    /* JAMC_TYPE_MISMATCH     12 */ "type mismatch",
+    /* JAMC_ASSIGN_TO_CONST   13 */ "assignment to constant",
+    /* JAMC_NEXT_UNEXPECTED   14 */ "NEXT unexpected",
+    /* JAMC_POP_UNEXPECTED    15 */ "POP unexpected",
+    /* JAMC_RETURN_UNEXPECTED 16 */ "RETURN unexpected",
+    /* JAMC_ILLEGAL_SYMBOL    17 */ "illegal symbol name",
+    /* JBIC_VECTOR_MAP_FAILED 18 */ "vector signal name not found",
+    /* JBIC_USER_ABORT        19 */ "execution cancelled",
+    /* JBIC_STACK_OVERFLOW    20 */ "stack overflow",
+    /* JBIC_ILLEGAL_OPCODE    21 */ "illegal instruction code",
+    /* JAMC_PHASE_ERROR       22 */ "phase error",
+    /* JAMC_SCOPE_ERROR       23 */ "scope error",
+    /* JBIC_ACTION_NOT_FOUND  24 */ "action not found",
+};
+
+#define MAX_ERROR_CODE (int)((sizeof(error_text)/sizeof(error_text[0]))+1)
+
+static int check_cpld_file_CRC(uchar *data, ulong length)
+{
+    JBI_RETURN_TYPE crc_result = JBIC_SUCCESS;
+    unsigned short expected_crc = 0;
+    unsigned short actual_crc = 0;
+
+    if( (!data) || (length == 0))
+        return -1;
+
+    crc_result = jbi_check_crc(data, length, &expected_crc, &actual_crc);
+
+    switch (crc_result) {
+        case JBIC_SUCCESS:
+            printf("CRC matched: CRC value = %04X\n", actual_crc);
+            break;
+
+        case JBIC_CRC_ERROR:
+            printf("CRC mismatch: expected %04X, actual %04X\n",
+                   expected_crc, actual_crc);
+            break;
+
+        case JBIC_UNEXPECTED_END:
+            printf("Expected CRC not found, actual CRC value = %04X\n",actual_crc);
+            break;
+
+        case JBIC_IO_ERROR:
+            printf("Error: File format is not recognized.\n");
+            break;
+
+        default:
+            printf("CRC function returned error code %d\n", crc_result);
+            break;
+    }
+
+    return crc_result;
+}
+
+static void show_cpld_file_info(uchar *file_buffer, ulong file_length)
+{
+    int format_version = 0;
+    int action_count = 0;
+    int procedure_count = 0;
+    int index = 0;
+    char *action_name = NULL;
+    char *description = NULL;
+    JBI_PROCINFO *procedure_list = NULL;
+    JBI_PROCINFO *procptr = NULL;
+    long offset = 0L;
+    char value[257] = {0};
+    char key[33] = {0};
+
+
+    /*	Display file format version */
+    jbi_get_file_info(file_buffer, file_length,
+                      &format_version, &action_count, &procedure_count);
+
+    printf("File format is %s ByteCode format\n",
+           (format_version == 2) ? "Jam STAPL" : "pre-standardized Jam 1.1");
+
+    /* Dump out NOTE fields */
+    while (jbi_get_note(file_buffer, file_length,
+                        &offset, key, value, 256) == 0) {
+        printf("NOTE \"%s\" = \"%s\"\n", key, value);
+    }
+
+    /* Dump the action table */
+    if ((format_version == 2) && (action_count > 0)) {
+        printf("\nActions available in this file:\n");
+
+        for (index = 0; index < action_count; ++index) {
+            jbi_get_action_info(file_buffer, file_length,
+                                index, &action_name, &description, &procedure_list);
+
+            if (description == NULL) {
+                printf("%s\n", action_name);
+            } else {
+                printf("%s \"%s\"\n", action_name, description);
+            }
+
+
+            procptr = procedure_list;
+            while (procptr != NULL) {
+                if (procptr->attributes != 0) {
+                    printf("    %s (%s)\n", procptr->name,
+                           (procptr->attributes == 1) ?
+                           "optional" : "recommended");
+                }
+
+
+                procedure_list = procptr->next;
+                jbi_free(procptr);
+                procptr = procedure_list;
+            }
+        }
+
+        /* add a blank line before execution messages */
+        printf("\n");
+    }
+}
+
+static int update_cpld(uchar *data, ulong length)
+{
+    JBI_RETURN_TYPE exec_result = JBIC_SUCCESS;
+    char *action = "PROGRAM";   //"VERIFY";      /* programmed and verified */
+    int reset_jtag = 1;             /* 1 = reset JTAG TAP after use */
+    char *init_list[10];
+    char *exit_string = NULL;
+    long error_address = 0L;
+    int exit_code = 0;
+    int format_version = 0;
+
+    init_list[0] = NULL;        /* STAPL-based .jbc files only */
+    #ifdef CFG_CPLD_REAL_TIME_ISP
+        reset_jtag = 0;     /* do not reset JTAG TAP after use */
+
+        /* Real-Time ISP (without CPLD reset) => jam -aPROGRAM -dDO_BYPASS_UFM=1 -dDO_REAL_TIME_ISP=1 */
+        init_list[0] = "DO_BYPASS_UFM=1";
+        init_list[1] = "DO_REAL_TIME_ISP=1";
+        init_list[2] = NULL;
+    #else
+        reset_jtag = 1;     /* 1 = reset JTAG TAP after use */
+        init_list[0] = NULL;
+    #endif
+
+    if( (!data) || (length == 0))
+        return -1;
+
+    exec_result = jbi_execute(data, length, NULL,	0, action, init_list, reset_jtag,
+                              &error_address, &exit_code, &format_version);
+
+    if (exec_result == JBIC_SUCCESS) {
+        if (format_version == 2) {
+            switch (exit_code) {
+                case  0:
+                    exit_string = "Success";
+                    break;
+                case  1:
+                    exit_string = "Checking chain failure";
+                    break;
+                case  2:
+                    exit_string = "Reading IDCODE failure";
+                    break;
+                case  3:
+                    exit_string = "Reading USERCODE failure";
+                    break;
+                case  4:
+                    exit_string = "Reading UESCODE failure";
+                    break;
+                case  5:
+                    exit_string = "Entering ISP failure";
+                    break;
+                case  6:
+                    exit_string = "Unrecognized device";
+                    break;
+                case  7:
+                    exit_string = "Device revision is not supported";
+                    break;
+                case  8:
+                    exit_string = "Erase failure";
+                    break;
+                case  9:
+                    exit_string = "Device is not blank";
+                    break;
+                case 10:
+                    exit_string = "Device programming failure";
+                    break;
+                case 11:
+                    exit_string = "Device verify failure";
+                    break;
+                case 12:
+                    exit_string = "Read failure";
+                    break;
+                case 13:
+                    exit_string = "Calculating checksum failure";
+                    break;
+                case 14:
+                    exit_string = "Setting security bit failure";
+                    break;
+                case 15:
+                    exit_string = "Querying security bit failure";
+                    break;
+                case 16:
+                    exit_string = "Exiting ISP failure";
+                    break;
+                case 17:
+                    exit_string = "Performing system test failure";
+                    break;
+                default:
+                    exit_string = "Unknown exit code";
+                    break;
+            }
+        } else {
+            switch (exit_code) {
+                case 0:
+                    exit_string = "Success";
+                    break;
+                case 1:
+                    exit_string = "Illegal initialization values";
+                    break;
+                case 2:
+                    exit_string = "Unrecognized device";
+                    break;
+                case 3:
+                    exit_string = "Device revision is not supported";
+                    break;
+                case 4:
+                    exit_string = "Device programming failure";
+                    break;
+                case 5:
+                    exit_string = "Device is not blank";
+                    break;
+                case 6:
+                    exit_string = "Device verify failure";
+                    break;
+                case 7:
+                    exit_string = "SRAM configuration failure";
+                    break;
+                default:
+                    exit_string = "Unknown exit code";
+                    break;
+            }
+        }
+
+        debug("Exit code = %d... \n", exit_code);
+        printf("%s\n", exit_string);
+        return 0;
+    } else if ((format_version == 2) &&
+               (exec_result == JBIC_ACTION_NOT_FOUND)) {
+        if ((action == NULL) || (*action == '\0')) {
+            printf("Error: no action specified for Jam STAPL file.\nProgram terminated.\n");
+        } else {
+            printf("Error: action \"%s\" is not supported for this Jam STAPL file.\nProgram terminated.\n", action);
+        }
+    } else if (exec_result < MAX_ERROR_CODE) {
+        printf("Error at address %ld: %s.\nProgram terminated.\n",
+               error_address, error_text[exec_result]);
+    } else {
+        printf("Unknown error code %d\n", exec_result);
+    }
+
+    return -1;
+}
+
+static int do_diag_update_cpld(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    //char offset[50];
+    //char *arg[5];
+    ulong length=0, cpld_buf=0;
+    //unsigned char *watchdogcpd;
+
+    if(argc < 2) {
+        return -1;
+    }
+
+    if(argc >= 3)
+        cpld_buf = simple_strtoul(argv[2], NULL, 16);
+
+    if(argc >= 4)
+        length = simple_strtoul(argv[3], NULL, 10);
+    else
+        length = simple_strtoul(getenv("filesize"), NULL, 16);
+
+
+    /* Show information of CPLD code */
+    if(strcmp(argv[1], "-v") == 0) {
+        /* Check CRC */
+        if(check_cpld_file_CRC((uchar *)cpld_buf, length) != JBIC_SUCCESS) {
+            printf("*** CRC checksum error on downloaded CPLD code !!!\n");
+            return -1;
+        }
+
+        show_cpld_file_info((uchar *)cpld_buf, length);
+        return 0;
+    }
+
+    /* Update CPLD code */
+    if(strcmp(argv[1], "-u") == 0) {
+        debug("Update CPLD code from memory buffer 0x%08lX\n", cpld_buf);
+
+        /* Check CRC */
+        if(check_cpld_file_CRC((uchar *)cpld_buf, length) != JBIC_SUCCESS) {
+            printf("*** CRC checksum error on downloaded CPLD code !!!\n");
+            return -1;
+        }
+
+
+        GPIO_Init();
+
+        CPLD_select_JTAG_channel(CS_CPLD_JTAG_GPIO);
+        printf("Updating cpld code...\n");
+		update_cpld((uchar *)cpld_buf, length);
+        CPLD_select_JTAG_channel(CS_CPLD_JTAG_EXT);
+
+	GPIO_Finish();
+    }
+
+    return 0;
+}
+
+
+U_BOOT_CMD(
+    update_cpld, 4, 0,	do_diag_update_cpld,
+    "Update CPLD code",
+    "Update cpld code from gpio\n"
+    "Syntax:\n"
+    "    update_cpld <-u|-v> <address> [size]\n"
+    "Example:\n"
+    "    update_cpld -u 0x10000000 0xed43\n"
+);
diff --git a/board/accton/as4600_54t/ddr.c b/board/accton/as4600_54t/ddr.c
new file mode 100644
index 0000000..b15e1b4
--- /dev/null
+++ b/board/accton/as4600_54t/ddr.c
@@ -0,0 +1,184 @@
+/*
+ * Copyright 2009-2010 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+#include <asm/immap_85xx.h>
+#include <asm/processor.h>
+#include <asm/fsl_ddr_sdram.h>
+#include <asm/io.h>
+#include <asm/fsl_law.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+extern void fsl_ddr_set_memctl_regs(const fsl_ddr_cfg_regs_t *regs,
+				   unsigned int ctrl_num);
+
+#define DATARATE_400MHZ 400000000
+#define DATARATE_533MHZ 533333333
+#define DATARATE_667MHZ 666666666
+#define DATARATE_800MHZ 800000000
+
+
+/* Default settings for "stable" mode */
+#define CONFIG_SYS_DDR_CS0_BNDS		0x0000007F
+#define CONFIG_SYS_DDR_CS0_CONFIG	0x80044302
+#define CONFIG_SYS_DDR_TIMING_3		0x00030000
+#define CONFIG_SYS_DDR_TIMING_0		0x003a0104
+#define CONFIG_SYS_DDR_TIMING_1_667	0x6f6b0644      /* DDR data rate = 667MHz */
+#define CONFIG_SYS_DDR_TIMING_1_800	0x6f6bf644      /* DDR data rate = 800MHz */
+#define CONFIG_SYS_DDR_TIMING_2		0x0fa888d0
+#define CONFIG_SYS_DDR_MODE_1		0x00421222
+#define CONFIG_SYS_DDR_MODE_2		0x04000000
+#define CONFIG_SYS_DDR_MODE_CTRL	0x00000000
+#define CONFIG_SYS_DDR_INTERVAL		0x0a280100
+#define CONFIG_SYS_DDR_DATA_INIT	0xDEADBEEF
+#define CONFIG_SYS_DDR_CLK_CTRL		0x02000000
+#define CONFIG_SYS_DDR_TIMING_4		0x00220001
+#define CONFIG_SYS_DDR_TIMING_5		0x03402400
+#define CONFIG_SYS_DDR_ZQ_CNTL		0x00000000 /* double check */
+#define CONFIG_SYS_DDR_WRLVL_CNTL	0x8645f607
+#define CONFIG_SYS_DDR_CONTROL		0xe7000000 /* ECC enable, Type = DDR3 */
+#define CONFIG_SYS_DDR_CONTROL_2		0x24401011
+#define CONFIG_SYS_DDR_CDR1		0x00000000
+#define CONFIG_SYS_DDR_CDR2		0x00000000
+#define CONFIG_SYS_DDR_ERR_INT_EN	0x00000000
+#define CONFIG_SYS_DDR_ERR_DIS		0x00000000
+#define CONFIG_SYS_DDR_SBE		0x00000000 /* should be 0x00010000 */
+
+fsl_ddr_cfg_regs_t ddr_cfg_regs_667 = {
+	.cs[0].bnds = CONFIG_SYS_DDR_CS0_BNDS,
+	.cs[0].config = CONFIG_SYS_DDR_CS0_CONFIG,
+	.timing_cfg_3 = CONFIG_SYS_DDR_TIMING_3,
+	.timing_cfg_0 = CONFIG_SYS_DDR_TIMING_0,
+	.timing_cfg_1 = CONFIG_SYS_DDR_TIMING_1_667,
+	.timing_cfg_2 = CONFIG_SYS_DDR_TIMING_2,
+	.ddr_sdram_cfg = CONFIG_SYS_DDR_CONTROL,
+	.ddr_sdram_cfg_2 = CONFIG_SYS_DDR_CONTROL_2,
+	.ddr_sdram_mode = CONFIG_SYS_DDR_MODE_1,
+	.ddr_sdram_mode_2 = CONFIG_SYS_DDR_MODE_2,
+	.ddr_sdram_md_cntl = CONFIG_SYS_DDR_MODE_CTRL,
+	.ddr_sdram_interval = CONFIG_SYS_DDR_INTERVAL,
+	.ddr_data_init = CONFIG_SYS_DDR_DATA_INIT,
+	.ddr_sdram_clk_cntl = CONFIG_SYS_DDR_CLK_CTRL,
+	.timing_cfg_4 = CONFIG_SYS_DDR_TIMING_4,
+	.timing_cfg_5 = CONFIG_SYS_DDR_TIMING_5,
+	.ddr_zq_cntl = CONFIG_SYS_DDR_ZQ_CNTL,
+	.ddr_wrlvl_cntl = CONFIG_SYS_DDR_WRLVL_CNTL,
+	.ddr_cdr1 = CONFIG_SYS_DDR_CDR1,
+    .ddr_cdr2 = CONFIG_SYS_DDR_CDR2,
+    .err_int_en = CONFIG_SYS_DDR_ERR_INT_EN,
+    .err_disable = CONFIG_SYS_DDR_ERR_DIS
+};
+
+fsl_ddr_cfg_regs_t ddr_cfg_regs_800 = {
+	.cs[0].bnds = CONFIG_SYS_DDR_CS0_BNDS,
+	.cs[0].config = CONFIG_SYS_DDR_CS0_CONFIG,
+	.timing_cfg_3 = CONFIG_SYS_DDR_TIMING_3,
+	.timing_cfg_0 = CONFIG_SYS_DDR_TIMING_0,
+	.timing_cfg_1 = CONFIG_SYS_DDR_TIMING_1_800,
+	.timing_cfg_2 = CONFIG_SYS_DDR_TIMING_2,
+	.ddr_sdram_cfg = CONFIG_SYS_DDR_CONTROL,
+	.ddr_sdram_cfg_2 = CONFIG_SYS_DDR_CONTROL_2,
+	.ddr_sdram_mode = CONFIG_SYS_DDR_MODE_1,
+	.ddr_sdram_mode_2 = CONFIG_SYS_DDR_MODE_2,
+	.ddr_sdram_md_cntl = CONFIG_SYS_DDR_MODE_CTRL,
+	.ddr_sdram_interval = CONFIG_SYS_DDR_INTERVAL,
+	.ddr_data_init = CONFIG_SYS_DDR_DATA_INIT,
+	.ddr_sdram_clk_cntl = CONFIG_SYS_DDR_CLK_CTRL,
+	.timing_cfg_4 = CONFIG_SYS_DDR_TIMING_4,
+	.timing_cfg_5 = CONFIG_SYS_DDR_TIMING_5,
+	.ddr_zq_cntl = CONFIG_SYS_DDR_ZQ_CNTL,
+	.ddr_wrlvl_cntl = CONFIG_SYS_DDR_WRLVL_CNTL,
+	.ddr_cdr1 = CONFIG_SYS_DDR_CDR1,
+    .ddr_cdr2 = CONFIG_SYS_DDR_CDR2,
+    .err_int_en = CONFIG_SYS_DDR_ERR_INT_EN,
+    .err_disable = CONFIG_SYS_DDR_ERR_DIS
+};
+
+/*
+ * Fixed sdram init -- doesn't use serial presence detect.
+ */
+
+phys_size_t fixed_sdram (void)
+{
+	sys_info_t sysinfo;
+	char buf[32];
+	fsl_ddr_cfg_regs_t ddr_cfg_regs;
+	phys_size_t ddr_size;
+	struct cpu_type *cpu;
+
+	get_sys_info(&sysinfo);
+	printf("fixed_sdram Configuring DDR for %s MT/s data rate\n",
+				strmhz(buf, sysinfo.freqDDRBus));
+
+	if(sysinfo.freqDDRBus <= DATARATE_667MHZ)
+		memcpy(&ddr_cfg_regs, &ddr_cfg_regs_667, sizeof(ddr_cfg_regs));
+	else if(sysinfo.freqDDRBus <= DATARATE_800MHZ)
+		memcpy(&ddr_cfg_regs, &ddr_cfg_regs_800, sizeof(ddr_cfg_regs));
+	else
+		panic("Unsupported DDR data rate %s MT/s data rate\n",
+					strmhz(buf, sysinfo.freqDDRBus));
+
+	cpu = gd->cpu;
+	ddr_size = CONFIG_SYS_SDRAM_SIZE * (1UL<<20);
+
+
+	fsl_ddr_set_memctl_regs(&ddr_cfg_regs, 0);
+
+    /* DDR LAW */
+	if (set_ddr_laws(CONFIG_SYS_DDR_SDRAM_BASE,
+			 CONFIG_SYS_SDRAM_SIZE * (1U<<20),
+			 LAW_TRGT_IF_DDR) < 0) {
+		printf("ERROR setting Local Access Windows for DDR\n");
+		return 0;
+	};
+
+
+	return ddr_size;
+}
+
+#if 0
+phys_size_t initdram(int board_type)
+{
+	phys_size_t dram_size = 0;
+	struct cpu_type *cpu;
+#if defined(CONFIG_SYS_RAMBOOT) && defined(CONFIG_SYS_FSL_BOOT_DDR)
+	cpu = gd->cpu;
+	/* P1020 and it's derivatives support max 32bit DDR width */
+	if (cpu->soc_ver == SVR_P1020 || cpu->soc_ver == SVR_P1020_E ||
+		cpu->soc_ver == SVR_P1011 || cpu->soc_ver == SVR_P1011_E)
+		return (CONFIG_SYS_SDRAM_SIZE * 1024 * 1024) / 2;
+	else
+		return CONFIG_SYS_SDRAM_SIZE * 1024 * 1024;
+#endif
+	dram_size = fixed_sdram();
+
+	set_ddr_laws(0, dram_size, LAW_TRGT_IF_DDR_1);
+
+	dram_size = setup_ddr_tlbs(dram_size / 0x100000);
+	dram_size *= 0x100000;
+
+	puts("DDR: ");
+	return dram_size;
+}
+#endif
diff --git a/board/accton/as4600_54t/fan_read_cmd.c b/board/accton/as4600_54t/fan_read_cmd.c
new file mode 100644
index 0000000..918e9d3
--- /dev/null
+++ b/board/accton/as4600_54t/fan_read_cmd.c
@@ -0,0 +1,471 @@
+
+
+#include <common.h>
+#include <i2c.h>
+
+u8 cpld_rd(u32 reg);
+void cpld_wr(u32 reg, u8 data);
+
+#define I2C_ADDR_ADT7473 0x2E
+#define I2C_ADDR_W83782G 0x29
+#define CPLD_REG_SYSTEM 0x3
+#define CPLD_REG_PSU1 0x2
+#define CPLD_REG_PSU2 0x1
+
+#define I2C_ADDR_REAR_FAN_DIR 0x73
+/**
+ * FAN test interface
+ * 1) get pwm
+ * 2) set pwm
+ * 3) show rpm
+ * 4) show fan status
+ * 5) *set direction
+ */
+static int ADT7473_get_pwm(int *pwm)
+{
+	//if(i2c_path_open(&i2c_root,"/PCA9548_A/ADT7473") != MSG_I2C_PASS)
+	//{
+	//	printf("ADT7473 i2c device Not Present\n");
+	//	return 1;
+	//}
+	i2c_read(I2C_ADDR_ADT7473, 0x30,1,(unsigned char *)pwm, 1);
+
+	return 0;
+}
+
+static int ADT7473_set_pwm(int pwm)
+{
+	//if(i2c_path_open(&i2c_root,"/PCA9548_A/ADT7473") != MSG_I2C_PASS)
+	//{
+	//	printf("ADT7473 i2c device Not Present\n");
+	//	return 1;
+	//}
+	unsigned char write_data = 0xE2;
+	write_data = 0xE2;  /* PWMx configuration value, manual mode.*/
+	i2c_write(I2C_ADDR_ADT7473,0x5C,1,&write_data,1);  /* config FAN @ PWM1 */
+	udelay(1000000);
+	write_data=pwm;
+	i2c_write(I2C_ADDR_ADT7473,0x30,1,&write_data,1);  /* FAN @ PWM1 */
+	i2c_write(I2C_ADDR_ADT7473,0x32,1,&write_data,1);  /* FAN @ PWM1 */
+	return 0;
+}
+
+static int ADT7473_show_rpm(void)
+{
+	//if(i2c_path_open(&i2c_root,"/PCA9548_A/ADT7473") != MSG_I2C_PASS)
+	//{
+	//	printf("ADT7473 i2c device Not Present\n");
+	//	return 1;
+	//}
+
+	unsigned char taco_L=0,taco_H=0;
+	int TACO = 0;
+	int stop_fan=0;
+
+	udelay(100000);
+
+	i2c_read(I2C_ADDR_ADT7473, 0x28,1,&taco_L,1);
+	i2c_read(I2C_ADDR_ADT7473, 0x29,1,&taco_H,1);
+	udelay(100000);
+	i2c_read(I2C_ADDR_ADT7473, 0x28,1,&taco_L,1);
+	i2c_read(I2C_ADDR_ADT7473, 0x29,1,&taco_H,1);
+	TACO = ((taco_H<<8) | taco_L);
+	printf("TACO1=(%02x %02x) RPM=%u\n",taco_H,taco_L,(TACO==0xFFFF)? 0 : 90000*60/TACO);
+	if(TACO == 0xFFFF)
+		stop_fan += 1;
+
+	udelay(100000);
+
+	i2c_read(I2C_ADDR_ADT7473, 0x2A,1,&taco_L,1);
+	i2c_read(I2C_ADDR_ADT7473, 0x2B,1,&taco_H,1);
+	udelay(100000);
+	i2c_read(I2C_ADDR_ADT7473, 0x2A,1,&taco_L,1);
+	i2c_read(I2C_ADDR_ADT7473, 0x2B,1,&taco_H,1);
+	TACO = ((taco_H<<8) | taco_L);
+	printf("TACO2=(%02x %02x) RPM=%u\n",taco_H,taco_L,(TACO==0xFFFF)? 0 : 90000*60/TACO);
+	if(TACO == 0xFFFF)
+		stop_fan += 1;
+
+	udelay(100000);
+
+	i2c_read(I2C_ADDR_ADT7473, 0x2C,1,&taco_L,1);
+	i2c_read(I2C_ADDR_ADT7473, 0x2D,1,&taco_H,1);
+	udelay(100000);
+	i2c_read(I2C_ADDR_ADT7473, 0x2C,1,&taco_L,1);
+	i2c_read(I2C_ADDR_ADT7473, 0x2D,1,&taco_H,1);
+	TACO = ((taco_H<<8) | taco_L);
+	printf("TACO3=(%02x %02x) RPM=%u\n",taco_H,taco_L,(TACO==0xFFFF)? 0 : 90000*60/TACO);
+	if(TACO == 0xFFFF)
+		stop_fan += 1;
+
+	udelay(100000);
+
+	i2c_read(I2C_ADDR_ADT7473, 0x2E,1,&taco_L,1);
+	i2c_read(I2C_ADDR_ADT7473, 0x2F,1,&taco_H,1);
+	udelay(100000);
+	i2c_read(I2C_ADDR_ADT7473, 0x2E,1,&taco_L,1);
+	i2c_read(I2C_ADDR_ADT7473, 0x2F,1,&taco_H,1);
+	TACO = ((taco_H<<8) | taco_L);
+	printf("TACO4=(%02x %02x) RPM=%u\n",taco_H,taco_L,(TACO==0xFFFF)? 0 : 90000*60/TACO);
+	if(TACO == 0xFFFF)
+		stop_fan += 1;
+
+	if(stop_fan == 0)
+		return 0;
+	else	/*some fans are stop*/
+	{
+		unsigned char read_data = 0;
+		i2c_read(I2C_ADDR_ADT7473,0x30,1,&read_data,1);  /* FAN @ PWM1 */
+		if(read_data >=0 && read_data <= 10)	/*allowd min pwm*/
+			return 0;
+		else
+			return 1;
+	}
+}
+
+static int I2C_show_fan_status(void)
+{
+	//if(i2c_path_open(&i2c_root,"/PCA9548_A/REAR_FAN_DIR") != MSG_I2C_PASS)
+	//{
+	//	printf("REAR_FAN_DIR i2c device Not Present\n");
+	//	return 1;
+	//}
+
+	unsigned char direction,i;
+	i2c_read(I2C_ADDR_REAR_FAN_DIR, 0,1,&direction,1);	/*Input port register 0, Output port register 1, Configuration register 3: 0=output,1=input(default)*/
+
+	for(i=0;i<4;i++)
+	{
+		printf("FAN %d: %s\n",i,(direction&0x1)?"FtoR(1)":"RtoF(0)");
+		direction >>= 1;
+	}
+
+	return 0;
+}
+
+/*
+static int I2C_set_fan_direction(int id, int dir)
+{
+	if(i2c_path_open(&i2c_root,"/PCA9548_A/REAR_FAN_DIR") != MSG_I2C_PASS)
+	{
+		printf("REAR_FAN_DIR i2c device Not Present\n");
+		return 1;
+	}
+
+
+	char rw_data = 0;
+	i2c_read(I2C_ADDR_REAR_FAN_DIR, 1,1,&rw_data,1);
+
+	if(dir == 0)
+		rw_data &= ~(1<<(id-1));
+	else
+		rw_data |= (1<<(id-1));
+
+	i2c_write(I2C_ADDR_REAR_FAN_DIR, 1, 1, &rw_data, 1);
+}*/
+
+#ifdef W8372G
+static int W83782G_set_pwm(int pwm)
+{
+	unsigned char val;
+
+    if( (pwm < 0) || (pwm > 100))
+        pwm = 100;
+
+	/*check i2c path*/
+	//if(i2c_path_open(&i2c_root,"/PCA9548_A/HW Monitor(W83782G)") != MSG_I2C_PASS)
+	//	return DIAG_FAIL;
+
+    /* W83782G I2C slave addr=0x29 @ channel #1-7 */
+    //i2c_set_bus_num(I2C_CHANNEL_1); /* channel #1 */
+    //val= 0x80;
+    //i2c_write(I2C_ADDR_PCA9548,0,1,&val,1);
+    //udelay(1000);
+
+	//if (i2c_probe(I2C_ADDR_W83782G) != 0){
+    //    debug("[Error] Cannot find W83782G device, slave address = 0x%02X\n", I2C_ADDR_W83782G);
+    //    return -1;
+    //}
+    //udelay(1000);
+
+    /* W83782G PWMOUT1 - 0x5B (bank 0) */
+    i2c_read(I2C_ADDR_W83782G, 0x4e,1, &val, 1);
+    val &= ~0x07;
+    udelay(1000);
+    i2c_write(I2C_ADDR_W83782G, 0x4e,1,&val,1);
+    udelay(1000);
+
+    val = (unsigned char)((pwm*255)/100);
+    val = (val == 255) ? val : val+1;  /* round it to the nearest whole number */
+    debug("[val] 0x%02X\n", val);
+    i2c_write(I2C_ADDR_W83782G, 0x5B,1,&val,1);
+    udelay(1000);
+
+	return 0;
+}
+#endif
+
+#ifdef W8372G
+static int W83782G_get_pwm(int *pwm)
+{
+	unsigned char val;
+    int duty_cycle;
+
+	/*check i2c path*/
+	//if(i2c_path_open(&i2c_root,"/PCA9548_A/HW Monitor(W83782G)") != MSG_I2C_PASS)
+	//	return 1;
+
+    /* W83782G I2C slave addr=0x29 @ channel #1-7 */
+    //i2c_set_bus_num(I2C_CHANNEL_1); /* channel #1 */
+    //val= 0x80;
+    //i2c_write(I2C_ADDR_PCA9548,0,1,&val,1);
+    //udelay(1000);
+
+
+	//if (i2c_probe(I2C_ADDR_W83782G) != 0){
+    //     debug("[Error] Cannot find W83782G device, slave address = 0x%02X\n", I2C_ADDR_W83782G);
+    //     return -1;
+    // }
+    // udelay(1000);
+
+    /* W83782G PWMOUT1 - 0x5B (bank 0) */
+    i2c_read(I2C_ADDR_W83782G, 0x4e,1, &val, 1);
+    val &= ~0x07;
+    udelay(1000);
+    i2c_write(I2C_ADDR_W83782G, 0x4e,1,&val,1);
+    udelay(1000);
+
+    i2c_read(I2C_ADDR_W83782G, 0x5B,1,&val,1);
+
+    duty_cycle = ((int)val*100)/255;
+    debug("[duty_cycle] %d\n", duty_cycle);
+
+    return duty_cycle;
+}
+
+#endif
+
+#ifdef W8372G
+int W83782G_show_rpm(int n)
+{
+	int rpm=0;
+	unsigned char val=0;
+	int total_counter=0;
+	unsigned char fan_divisor = 0;
+	//if(i2c_path_open(&i2c_root,"/PCA9548_A/HW Monitor(W83782G)") != MSG_I2C_PASS)
+	//	return DIAG_FAIL;
+
+	i2c_read(I2C_ADDR_W83782G, 0x47,1, &val, 1);/*read FAN1 devisor bit 0 and 1*/
+	fan_divisor = (val&0x30)>>4;
+	i2c_read(I2C_ADDR_W83782G, 0x5D,1, &val, 1);/*read FAN1 devisor bit 2*/
+	fan_divisor |= ((val&0x20)>>3);
+
+	printf("divisor = %d\n",fan_divisor);
+	switch(fan_divisor)
+	{
+		case 0:
+			rpm = 8800;
+			break;
+		case 1:
+			rpm = 4400;
+			break;
+		case 2:
+			rpm = 2200;
+			break;
+		case 3:
+			rpm = 1100;
+			break;
+		case 4:
+			rpm = 550;
+			break;
+		case 5:
+			rpm = 275;
+			break;
+		case 6:
+			rpm = 137;
+			break;
+		case 7:
+			rpm = 68;
+			break;
+	}
+
+	int i=0;
+	for(i=0;i<20;i++)
+	{
+		i2c_read(I2C_ADDR_W83782G, 0x28,1, &val, 1);/*read counter 20 times*/
+		total_counter += val;
+	}
+	rpm = total_counter/20;
+
+	return rpm;
+
+}
+
+#endif
+/* ------------------------------------------------------------------------
+ * FUNCTION NAME: board_test_fan
+ * PURPOSE:	To verify RTC function.
+ * INPUT:
+ *          n - (reserved)
+ * OUTPUT:	None
+ * RETURN:
+ *          0   = Success
+ *          -1  = Fail
+ *          1   = Abort
+ * NOTES:
+ */
+int CPLD_show_fan_status(int n)
+{
+    int s, ret;
+
+    ret = 0;
+
+//------------
+	s = cpld_rd(CPLD_REG_SYSTEM);
+
+	printf("CPLD[SYSFAN]=0x%.2x SYS FAN ",s);
+	if((s&0x4) == 0)
+	{
+		printf("Present ");
+		if((s&0x8) == 0)
+		{
+			printf("Status:Normal ");
+			if(s&0x10)
+				printf("[FtoR]\n");
+			else
+				printf("[RtoF]\n");
+		}
+		else
+		{
+			printf("Status:Fail\n");
+			ret = 1;
+		}
+	}
+	else
+	{
+		printf("NOT present\n");
+		ret = 1;
+	}
+//----------
+#if 0	/*Don't care power fan*/
+	s = CPLD_read(CPLD_REG_PSU1);
+	printf("CPLD[PSU1]=0x%.2x PSU1 FAN ",s);
+	if((s&0x1) == 0)
+	{
+		printf("Present ");
+		if(s&0x4)
+		{
+			printf("Status:Normal ");
+			if(s&0x10)
+				printf("[FtoR]\n");
+			else
+				printf("[RtoF]\n");
+		}
+		else
+		{
+			printf("Status:Fail\n");
+			ret = 1;
+		}
+	}
+	else
+	{
+		printf("NOT present\n");
+		ret = 1;
+	}
+//-----------
+	s = CPLD_read(CPLD_REG_PSU2);
+	printf("CPLD[PSU2]=0x%.2x PSU2 FAN ",s);
+	if((s&0x1) == 0)
+	{
+		printf("Present ");
+		if(s&0x4)
+		{
+			printf("Status:Normal ");
+			if(s&0x10)
+				printf("[FtoR]\n");
+			else
+				printf("[RtoF]\n");
+		}
+		else
+		{
+			printf("Status:Fail\n");
+			ret = 1;
+		}
+	}
+	else
+	{
+		printf("NOT present\n");
+		ret = 1;
+	}
+#endif
+    return ret;
+}
+
+int bgsf(int *duty_cycle)
+{
+	int pwm=0;
+	ADT7473_get_pwm(&pwm);
+	//W83782G_get_pwm(&pwm);
+	*duty_cycle = (pwm * 100 / 255);
+	return 0;
+}
+
+int bssf(int duty_cycle)
+{
+	int pwm = (int)((duty_cycle*255)/100);	/*pwm = 0~255*/
+	return ADT7473_set_pwm(pwm);
+	//W83782G_set_pwm(pwm);
+}
+
+int board_show_system_fan_rpm(void)
+{
+	//printf("rpm=%d",W83782G_show_rpm(0));
+	return ADT7473_show_rpm();
+}
+
+int board_show_system_fan_status(void)
+{
+	//return CPLD_show_fan_status(0);
+	return I2C_show_fan_status();
+}
+
+int do_diag_fan_cmd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int ret = 0;
+	int speed = 0;
+	ret = board_show_system_fan_status();
+
+	if(ret == 0)
+		board_show_system_fan_rpm();
+
+	if(argc == 2 && ret == 0)
+	{
+			speed = simple_strtoul(argv[1], NULL, 10);
+			if(speed >= 0 && speed <= 100)
+			{
+				printf("Set fan rate %d %%\n",speed);
+				ret += bssf(speed);
+				udelay(3000000);
+
+				board_show_system_fan_rpm();
+			}
+			else
+			{
+				ret = 1;
+				printf("Usage:\n%s\n", cmdtp->help);
+			}
+	}
+
+	return ret;
+}
+
+
+U_BOOT_CMD(
+    diag_fan, 3, 0, do_diag_fan_cmd,
+    "Check FAN status and/or Set Control Speed",
+    "diag_fan <0~100>\n"
+    "Syntax:\n"
+    "    diag_fan <0~100>\n"
+    "Example:\n"
+    "    diag_fan 70\n"
+);
diff --git a/board/accton/as4600_54t/fastpath.h b/board/accton/as4600_54t/fastpath.h
new file mode 100644
index 0000000..d0cd09b
--- /dev/null
+++ b/board/accton/as4600_54t/fastpath.h
@@ -0,0 +1,54 @@
+/*
+ * File:        fastpath.h
+ * Purpose:     Fastpath boot image data structure.
+ *
+ * Notes:
+ * History:
+ *  2013/08/23    -- Aaron Lien, Initial version
+ *
+ * Copyright (C) 2013  Accton Corporation & authors.
+ */
+
+#ifndef __FASTPATH_
+#define __FASTPATH_
+
+#define DIM_MAX_BOOTCFG_LINE_SIZE       128
+#define DIM_MAX_FILENAME_SIZE           40
+
+/* boot Image descriptor. Each Image is described as below */
+typedef struct _dim_image
+{
+    /* Mandatory information */
+    char    currentState[15];                   /* active / backup */
+    char    nextState[15];                      /* active / backup */
+    char    fileName[DIM_MAX_FILENAME_SIZE];    /* on the fs */
+    char    numErrors[5];           /* Num of tries w/ errors    */
+    char    descr[DIM_MAX_BOOTCFG_LINE_SIZE]; /* text description */
+} dimImageInfo_t;
+
+
+/* STK image header */
+typedef struct stkFileHeader_s{
+ unsigned short crc;
+ unsigned short tag1;
+ unsigned long tag2;
+
+ unsigned long num_components; /* Number of OPR and tgz files in the STK image (may be 0) */
+
+ unsigned long file_size; /* Total number of bytes in the STK file */
+
+ unsigned char rel;
+ unsigned char ver;
+ unsigned char maint_level;
+ unsigned char build_num;
+
+ unsigned long stk_header_size; /* Number of bytes in the STk header */
+
+ unsigned char reserved[64];    /* Reserved for future use */
+
+}stkFileHeader_t;
+
+#define STK_TAG1    0xAA55
+#define STK_TAG2    0x2288BB66
+
+#endif  /* __FASTPATH_ */
diff --git a/board/accton/as4600_54t/law.c b/board/accton/as4600_54t/law.c
new file mode 100644
index 0000000..530d65f
--- /dev/null
+++ b/board/accton/as4600_54t/law.c
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ *
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/fsl_law.h>
+#include <asm/mmu.h>
+
+
+/*
+ * LAW(Local Access Window) configuration:
+ *
+ * 0  LAW0  FLASH                     0xef80_0000~0xefff_ffff	     8 Mbyte
+ * 1  LAW1  CPLD		      0xea00_0000~0xea00_00FF	     < 4K
+ * 2  LAW2  PCIe1 MEM		      0xa000_0000~0xbfff_ffff	     512 MByte
+ * 3  LAW3  PCIe1 IO		      0xffc2_0000~0xffc2_ffff	     64 K
+ *
+ * Notes:
+ *    CCSRBAR and L2-as-SRAM don't need a configured Local Access Window.
+ *    If flash is 8M at default position (last 8M), no LAW needed.
+ *
+ */
+
+struct law_entry law_table[] = {
+	SET_LAW(CONFIG_SYS_FLASH_BASE,     LAW_SIZE_8M,   LAW_TRGT_IF_LBC),
+	SET_LAW(CONFIG_SYS_CPLD_BASE,      LAW_SIZE_4K,   LAW_TRGT_IF_LBC),
+};
+
+int num_law_entries = ARRAY_SIZE(law_table);
diff --git a/board/accton/as4600_54t/tlb.c b/board/accton/as4600_54t/tlb.c
new file mode 100644
index 0000000..0c95c5f
--- /dev/null
+++ b/board/accton/as4600_54t/tlb.c
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc.
+ *
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+
+struct fsl_e_tlb_entry tlb_table[] = {
+	/* TLB 0 - for temp stack in cache */
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 4 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 8 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 12 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+
+	/* TLB 1 */
+	/* *I*** - Covers boot page */
+	SET_TLB_ENTRY(1, 0xfffff000, 0xfffff000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 0, BOOKE_PAGESZ_4K, 1),
+
+	/* *I*G* - CCSRBAR */
+	SET_TLB_ENTRY(1, CONFIG_SYS_CCSRBAR, CONFIG_SYS_CCSRBAR_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 1, BOOKE_PAGESZ_1M, 1),
+
+	/* W**G* - Flash, localbus */
+	/* This will be changed to *I*G* after relocation to RAM. */
+	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE_PHYS,
+		      MAS3_SX|MAS3_SR, MAS2_W|MAS2_G,
+		      0, 2, CONFIG_SYS_FLASH_TLB_SIZE, 1),
+
+	/* *I*G* - PCIe1 MEM -- first 256M */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_MEM_VIRT, CONFIG_SYS_PCIE1_MEM_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 3, BOOKE_PAGESZ_256M, 1),
+
+	/* *I*G* - PCIe1 MEM -- second 256M */
+	SET_TLB_ENTRY(1, (CONFIG_SYS_PCIE1_MEM_VIRT + 0x10000000),
+		      (CONFIG_SYS_PCIE1_MEM_PHYS + 0x10000000),
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 4, BOOKE_PAGESZ_256M, 1),
+
+	/* *I*G* - PCIe1 I/O */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_IO_VIRT, CONFIG_SYS_PCIE1_IO_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 5, BOOKE_PAGESZ_256K, 1),
+
+	/* *I*G* - CPLD */
+	SET_TLB_ENTRY(1, CONFIG_SYS_CPLD_BASE, CONFIG_SYS_CPLD_BASE,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 6, BOOKE_PAGESZ_1K, 1),
+
+};
+
+int num_tlb_entries = ARRAY_SIZE(tlb_table);
diff --git a/board/accton/as4600_54t/usb.c b/board/accton/as4600_54t/usb.c
new file mode 100644
index 0000000..c1f6d26
--- /dev/null
+++ b/board/accton/as4600_54t/usb.c
@@ -0,0 +1,78 @@
+/*
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <environment.h>
+#include <usb.h>
+#include <i2c.h>
+#include <part.h>
+
+static int do_usbiddev(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int devno;
+	int target = -1;
+	block_dev_desc_t *blk_dev;
+	char val[2];
+
+	/*
+	 * The internal USB NAND flash drive is connected to the
+	 * internal hub such that the NAND device always appears as
+	 * the *last* mass storage device.
+	 *
+	 * Sure this is dependent on the depth-first USB topology
+	 * enumeration strategy, but that is not going to change.
+	 */
+	for (devno = 0; ; ++devno) {
+		blk_dev = usb_stor_get_dev(devno);
+		if (blk_dev == NULL)
+			break;
+		if ( (blk_dev->if_type == IF_TYPE_USB) &&
+		     !blk_dev->removable &&
+		     ((blk_dev->type & 0x1F) == DEV_TYPE_HARDDISK) ) {
+			target = devno;
+		}
+	}
+
+	if (target == -1) {
+		printf("Error: Unable to detect internal USB flash device.\n");
+		printf("Perhaps you forgot to run 'usb start' ?\n");
+		return 1;
+	}
+
+	if (target > 9) {
+		printf("Error: Unexpectedly large device number: %d.\n", target);
+		return 1;
+	}
+
+	val[0] = '0' + target;
+	val[1] = 0;
+
+	setenv("usbdev", val);
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	usbiddev,	3,	1,	do_usbiddev,
+	"Identify internal USB NAND flash device number and set\n"
+	"environment variable 'usbdev' to that number.",
+	""
+);
diff --git a/boards.cfg b/boards.cfg
index e4b0d44..4e75ca6 100644
--- a/boards.cfg
+++ b/boards.cfg
@@ -703,6 +703,7 @@ kmvect1                      powerpc     mpc83xx     km83xx              keymile
 tuge1                        powerpc     mpc83xx     km83xx              keymile        -           tuxx1:KM_DISABLE_APP2,TUGE1
 tuxx1                        powerpc     mpc83xx     km83xx              keymile
 kmsupx5                      powerpc     mpc83xx     km83xx              keymile        -           tuxx1:KM_DISABLE_APP2,KMSUPX5
+AS4600_54T                   powerpc     mpc85xx     as4600_54t          accton         -           AS4600_54T:ONIE_PLATFORM_REV=0
 sbc8548                      powerpc     mpc85xx     sbc8548             -              -           sbc8548
 sbc8548_PCI_33               powerpc     mpc85xx     sbc8548             -              -           sbc8548:PCI,33
 sbc8548_PCI_33_PCIE          powerpc     mpc85xx     sbc8548             -              -           sbc8548:PCI,33,PCIE
diff --git a/common/cmd_sys_eeprom.c b/common/cmd_sys_eeprom.c
index 91cceb3..260c179 100644
--- a/common/cmd_sys_eeprom.c
+++ b/common/cmd_sys_eeprom.c
@@ -2,7 +2,20 @@
  * See file CREDITS for list of people who contributed to this
  * project.
  *
- * SPDX-License-Identifier:	GPL-2.0+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
  */
 
 #include <common.h>
@@ -12,6 +25,8 @@
 
 #include "sys_eeprom.h"
 
+DECLARE_GLOBAL_DATA_PTR;
+
 /* File scope function prototypes */
 static bool is_checksum_valid(u8 *eeprom);
 static int read_eeprom(u8 *eeprom);
@@ -225,8 +240,8 @@ static struct tlv_code_desc tlv_code_list[] = {
 	{ TLV_CODE_DEVICE_VERSION, "Device Version"},
 	{ TLV_CODE_LABEL_REVISION, "Label Revision"},
 	{ TLV_CODE_PLATFORM_NAME , "Platform Name"},
-	{ TLV_CODE_ONIE_VERSION	 , "Loader Version"},
-	{ TLV_CODE_MAC_SIZE	 , "MAC Addresses"},
+	{ TLV_CODE_ONIE_VERSION	 , "ONIE Version"},
+	{ TLV_CODE_MAC_SIZE	 , "MAC Address Size"},
 	{ TLV_CODE_MANUF_NAME	 , "Manufacturer"},
 	{ TLV_CODE_MANUF_COUNTRY , "Country Code"},
 	{ TLV_CODE_VENDOR_NAME	 , "Vendor Name"},
@@ -1031,8 +1046,6 @@ int mac_read_from_eeprom(void)
 	u8 macbase[6];
 	tlvinfo_header_t * eeprom_hdr = (tlvinfo_header_t *) eeprom;
 
-	puts("EEPROM: ");
-
 	if (read_eeprom(eeprom)) {
 		printf("Read failed.\n");
 		return -1;
@@ -1052,18 +1065,35 @@ int mac_read_from_eeprom(void)
 
 	for (i = 0; i < min(maccount, CONFIG_SYS_EEPROM_MAX_NUM_ETH_PORTS); i++) {
 		if (is_valid_ether_addr(macbase)) {
-			char ethaddr[18];
+			char ethaddr[18], *env;
 			char enetvar[11];
 
 			sprintf(ethaddr, "%02X:%02X:%02X:%02X:%02X:%02X",
 				macbase[0], macbase[1], macbase[2],
 				macbase[3], macbase[4], macbase[5]);
 			sprintf(enetvar, i ? "eth%daddr" : "ethaddr", i);
+
+#if 1
+			/* aaron_lien, 2013/08/05,
+			 * Initialize $ethaddr if it is blank or
+			 * if the current value is different from non-volatile board information
+			 * then change it.
+			 */
+			env = getenv(enetvar);
+			if (!env) {
+				setenv(enetvar, ethaddr);
+			} else {
+				if(strcmp(env, ethaddr))
+					setenv(enetvar, ethaddr);
+			}
+
+#else
 			/* Only initialize environment variables that are blank
 			 * (i.e. have not yet been set)
 			 */
 			if (!getenv(enetvar))
 				setenv(enetvar, ethaddr);
+#endif
 
 			macbase[5]++;
 			if (macbase[5] == 0) {
@@ -1080,7 +1110,7 @@ int mac_read_from_eeprom(void)
 		}
 	}
 
-	printf("%s v%u len=%u\n", eeprom_hdr->signature, eeprom_hdr->version,
+	debug("%s v%u len=%u\n", eeprom_hdr->signature, eeprom_hdr->version,
 	       be16_to_cpu(eeprom_hdr->totallen));
 
 	return 0;
@@ -1088,6 +1118,7 @@ int mac_read_from_eeprom(void)
 
 #endif /* CONFIG_SYS_EEPROM_LOAD_ENV_MAC */
 
+#if 0
 #ifdef CONFIG_POPULATE_SERIAL_NUMBER
 
 /**
@@ -1127,3 +1158,65 @@ int populate_serial_number(void)
 }
 
 #endif /* CONFIG_POPULATE_SERIAL_NUMBER */
+#else
+/* ------------------------------------------------------------------------
+ * FUNCTION NAME: populate_mac_address
+ * PURPOSE:	Read the MAC addresses from non-volatile device and
+ *          set the appropriate environment variables for each one read.
+ * INPUT:   None
+ * OUTPUT:	None
+ * RETURN:
+ *          0   = Success
+ *          -1  = Fail
+ * NOTES:
+ *  The environment variables are only set if they haven't been set already or
+ *  if the current value is different from non-volatile board information.
+ */
+int populate_mac_address(void)
+{
+    char * env;
+    int ret = -1;
+
+    if(mac_read_from_eeprom())
+        return -1;
+
+    env = getenv("ethaddr");
+    if (!env)
+        ret = eth_getenv_enetaddr("ethaddr", gd->bd->bi_enetaddr);
+
+    return ret;
+}
+
+/* ------------------------------------------------------------------------
+ * FUNCTION NAME: populate_env
+ * PURPOSE:	Read the board information from non-volatile device and
+ *          set the appropriate environment variable.
+ * INPUT:   None
+ * OUTPUT:	None
+ * RETURN:
+ *          0   = Success
+ *          -1  = Fail
+ * NOTES:
+ *  The environment variable is set always.
+ */
+int populate_env(char *env_name,  u8 type_code)
+{
+    char env_str_buf[257];
+    int index;
+    tlvinfo_tlv_t * tlv_item;
+
+    if (read_eeprom(eeprom)) {
+        printf("[Error] Failed to read board information.\n");
+        return -1;
+    }
+
+    if (tlvinfo_find_tlv(eeprom, type_code, &index)) {
+        tlv_item = (tlvinfo_tlv_t *) &eeprom[index];
+        memcpy(env_str_buf, tlv_item->value, tlv_item->length);
+        env_str_buf[tlv_item->length] = 0;
+        setenv(env_name, env_str_buf);
+    }
+
+    return 0;
+}
+#endif
diff --git a/common/image.c b/common/image.c
index 95498e6..2edd747 100644
--- a/common/image.c
+++ b/common/image.c
@@ -830,6 +830,16 @@ int boot_get_ramdisk(int argc, char * const argv[], bootm_headers_t *images,
 	*rd_start = 0;
 	*rd_end = 0;
 
+#ifdef CONFIG_FASTPATH
+	if(argc >= 3 && strncmp(argv[2], "-f", 2) ==  0) {
+		/* Look for a "-f" which indicates to skip FASTPATH image block.*/
+		debug ("## Using FASTPATH application image\n");
+
+		/* At next line, we expect this image is a legacy mult-component image. */
+		argc=2;
+     }
+#endif
+
 	/*
 	 * Look for a '-' which indicates to ignore the
 	 * ramdisk argument
@@ -1675,7 +1685,7 @@ int boot_get_fdt(int flag, int argc, char * const argv[],
 			image_check_type(&images->legacy_hdr_os_copy,
 						IH_TYPE_MULTI)) {
 
-		ulong fdt_data, fdt_len;
+		ulong fdt_data, fdt_len, fdt_idx;
 
 		/*
 		 * Now check if we have a legacy multi-component image,
@@ -1685,8 +1695,14 @@ int boot_get_fdt(int flag, int argc, char * const argv[],
 			"component Image at %08lX\n",
 			(ulong)images->legacy_hdr_os);
 
-		image_multi_getimg(images->legacy_hdr_os, 2, &fdt_data,
-					&fdt_len);
+		fdt_idx=2;  /* default fdt index = 2 */
+#ifdef CONFIG_FASTPATH
+		if (argc >= 3 && strncmp(argv[2], "-f", 2) ==  0) {
+			fdt_idx = simple_strtoul(&argv[2][2], NULL, 10);  /* fdt image # */
+			debug("fdt is at image#%ld, argv[2]=%s\n", fdt_idx, argv[2]);
+		}
+#endif
+		image_multi_getimg(images->legacy_hdr_os, fdt_idx, &fdt_data, &fdt_len);
 		if (fdt_len) {
 
 			fdt_blob = (char *)fdt_data;
diff --git a/common/main.c b/common/main.c
index d43c6ae..782a28d 100644
--- a/common/main.c
+++ b/common/main.c
@@ -399,12 +399,6 @@ void main_loop (void)
 	}
 #endif  /* CONFIG_MODEM_SUPPORT */
 
-#ifdef CONFIG_VERSION_VARIABLE
-	{
-		setenv ("ver", version_string);  /* set version variable */
-	}
-#endif /* CONFIG_VERSION_VARIABLE */
-
 #ifdef CONFIG_SYS_HUSH_PARSER
 	u_boot_hush_start ();
 #endif
diff --git a/common/usb_storage.c b/common/usb_storage.c
index fb322b4..e54e98a 100644
--- a/common/usb_storage.c
+++ b/common/usb_storage.c
@@ -162,7 +162,8 @@ struct us_data {
  * enough free heap space left, but the SCSI READ(10) and WRITE(10) commands are
  * limited to 65535 blocks.
  */
-#define USB_MAX_XFER_BLK	65535
+/*#define USB_MAX_XFER_BLK	65535*/
+#define USB_MAX_XFER_BLK	20 /*Use smallest XFER BLK*/
 #else
 #define USB_MAX_XFER_BLK	20
 #endif
diff --git a/config.mk b/config.mk
index b7cd481..f2dcf32 100644
--- a/config.mk
+++ b/config.mk
@@ -55,7 +55,7 @@ endif
 
 # clean the slate ...
 PLATFORM_RELFLAGS =
-PLATFORM_CPPFLAGS =
+PLATFORM_CPPFLAGS += -I${TOPDIR}/drivers/cpld/altera
 PLATFORM_LDFLAGS =
 
 #########################################################################
diff --git a/drivers/cpld/altera/Makefile b/drivers/cpld/altera/Makefile
new file mode 100644
index 0000000..f194b34
--- /dev/null
+++ b/drivers/cpld/altera/Makefile
@@ -0,0 +1,46 @@
+#
+# (C) Copyright 2000-2007
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	:= $(obj)libcpld_altera.o
+
+COBJS-y += jbicomp.o jbijtag.o jbimain.o
+
+COBJS	:= $(COBJS-y)
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/drivers/cpld/altera/jbicomp.c b/drivers/cpld/altera/jbicomp.c
new file mode 100644
index 0000000..3ad94b1
--- /dev/null
+++ b/drivers/cpld/altera/jbicomp.c
@@ -0,0 +1,416 @@
+/****************************************************************************/
+/*																			*/
+/*	Module:			jbicomp.c												*/
+/*																			*/
+/*					Copyright (C) Altera Corporation 1997-2001				*/
+/*																			*/
+/*	Description:	Contains the code for compressing and uncompressing		*/
+/*					Boolean array data.										*/
+/*																			*/
+/*					This algorithm works by searching previous bytes in the */
+/*					data that match the current data. If a match is found,	*/
+/*					then the offset and length of the matching data can		*/
+/*					replace the actual data in the output.					*/
+/*																			*/
+/*	Revisions:		2.2  fixed /W4 warnings									*/
+/*																			*/
+/****************************************************************************/
+
+#include "jbiport.h"
+#include "jbiexprt.h"
+#include "jbicomp.h"
+
+#define	SHORT_BITS			16
+#define	CHAR_BITS			8
+#define	DATA_BLOB_LENGTH	3
+#define	MATCH_DATA_LENGTH	8192
+#define JBI_ACA_REQUEST_SIZE 1024
+#define JBI_ACA_BUFFER_SIZE	(MATCH_DATA_LENGTH + JBI_ACA_REQUEST_SIZE)
+
+unsigned long jbi_in_length = 0L;
+unsigned long jbi_in_index = 0L;	/* byte index into compressed array */
+unsigned int jbi_bits_avail = CHAR_BITS;
+
+#if PORT == DOS
+int jbi_current_variable_id = -1;
+int jbi_current_page = -1;
+int jbi_version = 0;
+unsigned long jbi_out_length = 0L;
+unsigned int jbi_out_index = 0;	/* byte index into jbi_aca_out_buffer[] */
+unsigned long jbi_aca_in_offset = 0L;
+unsigned char jbi_aca_out_buffer[JBI_ACA_BUFFER_SIZE];
+#endif
+
+/****************************************************************************/
+/*																			*/
+/*	The following functions implement incremental decompression of Boolean	*/
+/*	array data, using a small memory window.								*/
+/*																			*/
+/*	This algorithm works by searching previous bytes in the data that match	*/
+/*	the current data. If a match is found, then the offset and length of	*/
+/*	the matching data can replace the actual data in the output.			*/
+/*																			*/
+/*	Memory usage is reduced by maintaining a "window" buffer which contains	*/
+/*	the uncompressed data for one 8K page, plus some extra amount specified	*/
+/*	by JBI_ACA_REQUEST_SIZE.  The function jbi_uncompress_page() is used to	*/
+/*	request a subrange of the uncompressed data, starting at a particular	*/
+/*	bit position and extending a maximum of JBI_ACA_REQUEST_SIZE bytes.		*/
+/*																			*/
+/****************************************************************************/
+
+/****************************************************************************/
+/*																			*/
+
+unsigned int jbi_bits_required(unsigned int n)
+
+/*																			*/
+/*	Description:	Calculate the minimum number of bits required to		*/
+/*					represent n.											*/
+/*																			*/
+/*	Returns:		Number of bits.											*/
+/*																			*/
+/****************************************************************************/
+{
+	unsigned int result = SHORT_BITS;
+
+	if (n == 0)
+	{
+		result = 1;
+	}
+	else
+	{
+		/* Look for the highest non-zero bit position */
+		while ((n & (1 << (SHORT_BITS - 1))) == 0)
+		{
+			n <<= 1;
+			--result;
+		}
+	}
+
+	return (result);
+}
+
+/****************************************************************************/
+/*																			*/
+
+unsigned int jbi_read_packed
+(
+#if PORT!=DOS
+	unsigned char *buffer,
+#endif
+	unsigned int bits
+)
+
+/*																			*/
+/*	Description:	Read the next value from the input array "buffer".		*/
+/*					Read only "bits" bits from the array. The amount of		*/
+/*					bits that have already been read from "buffer" is		*/
+/*					stored internally to this function.					 	*/
+/*																			*/
+/*	Returns:		Up to 16 bit value. -1 if buffer overrun.				*/
+/*																			*/
+/****************************************************************************/
+{
+	unsigned int result = 0;
+	unsigned int shift = 0;
+	unsigned int databyte = 0;
+
+	while (bits > 0)
+	{
+#if PORT==DOS
+		databyte = GET_BYTE(jbi_aca_in_offset + jbi_in_index);
+#else
+		databyte = buffer[jbi_in_index];
+#endif
+		result |= (((databyte >> (CHAR_BITS - jbi_bits_avail))
+			& (0xFF >> (CHAR_BITS - jbi_bits_avail))) << shift);
+
+		if (bits <= jbi_bits_avail)
+		{
+			result &= (0xFFFF >> (SHORT_BITS - (bits + shift)));
+			jbi_bits_avail -= bits;
+			bits = 0;
+		}
+		else
+		{
+			++jbi_in_index;
+			shift += jbi_bits_avail;
+			bits -= jbi_bits_avail;
+			jbi_bits_avail = CHAR_BITS;
+		}
+	}
+
+	return (result);
+}
+
+#if PORT==DOS
+
+/****************************************************************************/
+/*																			*/
+
+void jbi_uncompress_next_page(int version)
+
+/*																			*/
+/*	Description:	Uncompresses one page of compressed data, using			*/
+/*					data page as reference for repeated sections.			*/
+/*					Overwrites previous page of data in buffer.				*/
+/*																			*/
+/*	Returns:		TRUE for success, FALSE if error encountered			*/
+/*																			*/
+/****************************************************************************/
+{
+	unsigned int i, j, offset, length;
+	unsigned int end_index;
+	unsigned long tmp_in_index = jbi_in_index;
+	unsigned int tmp_out_index = jbi_out_index;
+	unsigned int tmp_bits_avail = jbi_bits_avail;
+	unsigned int prev[3];
+	unsigned long long_end;
+	unsigned int match_data_length = MATCH_DATA_LENGTH;
+
+	if (version > 0) --match_data_length;
+
+	if (jbi_current_page < 0)
+	{
+		/* this is the first page of the array */
+		jbi_current_page = 0;
+		jbi_in_index = 4;	/* skip over length field */
+		jbi_out_index = 0;
+		end_index = (jbi_out_length < JBI_ACA_BUFFER_SIZE) ?
+			(unsigned int) jbi_out_length : JBI_ACA_BUFFER_SIZE;
+	}
+	else
+	{
+		/* this is not the first page */
+		++jbi_current_page;
+		jbi_out_index -= MATCH_DATA_LENGTH;
+		long_end = jbi_out_length -
+			((long) jbi_current_page * (long) MATCH_DATA_LENGTH);
+		end_index = (long_end < JBI_ACA_BUFFER_SIZE) ?
+			(unsigned int) long_end : JBI_ACA_BUFFER_SIZE;
+
+		/* copy extra data from end of circular buffer to beginning */
+		for (i = 0; i < jbi_out_index; ++i)
+		{
+			jbi_aca_out_buffer[i] = jbi_aca_out_buffer[i + MATCH_DATA_LENGTH];
+		}
+	}
+
+	while (jbi_out_index < end_index)
+	{
+		/* save state so we can undo the last packet when we reach the end */
+		tmp_in_index = jbi_in_index;
+		tmp_out_index = jbi_out_index;
+		tmp_bits_avail = jbi_bits_avail;
+
+		/* A 0 bit indicates literal data. */
+		if (jbi_read_packed(1) == 0)
+		{
+			for (i = 0; i < DATA_BLOB_LENGTH; ++i)
+			{
+				if (jbi_out_index < end_index)
+				{
+					if (version == 0)
+					{
+						prev[i] = jbi_aca_out_buffer[jbi_out_index] & 0xff;
+					}
+					jbi_aca_out_buffer[jbi_out_index++] =
+						(unsigned char) jbi_read_packed(CHAR_BITS);
+				}
+			}
+		}
+		else
+		{
+			/* A 1 bit indicates offset/length to follow. */
+			offset = jbi_read_packed(jbi_bits_required(
+				(jbi_current_page > 0) ? match_data_length :
+				(jbi_out_index > match_data_length ? match_data_length :
+				jbi_out_index)));
+			length = jbi_read_packed(CHAR_BITS);
+
+			if ((version == 0) && (offset == match_data_length + 3))
+			{
+				jbi_aca_out_buffer[jbi_out_index++] = (unsigned char) prev[0];
+				jbi_aca_out_buffer[jbi_out_index++] = (unsigned char) prev[1];
+				jbi_aca_out_buffer[jbi_out_index++] = (unsigned char) prev[2];
+				length -= 3;
+			}
+
+			for (i = 0; i < length; ++i)
+			{
+				if (jbi_out_index < end_index)
+				{
+					if (offset > jbi_out_index)
+					{
+						j = jbi_out_index + MATCH_DATA_LENGTH - offset;
+					}
+					else j = jbi_out_index - offset;
+					jbi_aca_out_buffer[jbi_out_index] = jbi_aca_out_buffer[j];
+					++jbi_out_index;
+				}
+			}
+
+			if (version == 0)
+			{
+				prev[0] = jbi_aca_out_buffer[jbi_out_index - 3] & 0xff;
+				prev[1] = jbi_aca_out_buffer[jbi_out_index - 2] & 0xff;
+				prev[2] = jbi_aca_out_buffer[jbi_out_index - 1] & 0xff;
+			}
+		}
+	}
+
+	/* restore the state before the previous packet */
+	jbi_in_index = tmp_in_index;
+	jbi_out_index = tmp_out_index;
+	jbi_bits_avail = tmp_bits_avail;
+}
+
+/****************************************************************************/
+/*																			*/
+
+void jbi_uncompress_page
+(
+	int variable_id,
+	int page,
+	int version
+)
+
+/*																			*/
+/*	Description:	Uncompress requested page of variable data.  Stores		*/
+/*					uncompressed data in jbi_aca_out_buffer[].				*/
+/*																			*/
+/*	Returns:		TRUE if successful, otherwise FALSE if:					*/
+/*						1) variable is not a compressed array				*/
+/*						2) compressed data is illegal or corrupted			*/
+/*						3) requested page is beyond the end of the array	*/
+/*						4) internal error in the code						*/
+/*																			*/
+/****************************************************************************/
+{
+	unsigned long symbol_table;
+	unsigned long data_section;
+	unsigned long offset;
+	unsigned long value;
+	int delta = version * 2;
+
+	if (variable_id != jbi_current_variable_id)
+	{
+		/* initialize to uncompress the desired variable */
+		symbol_table = GET_DWORD(16 + (version * 8));
+		data_section = GET_DWORD(20 + (version * 8));
+		offset = symbol_table + ((11 + delta) * variable_id);
+		value = GET_DWORD(offset + 3 + delta);
+		jbi_current_variable_id = variable_id;
+		jbi_current_page = -1;
+		jbi_bits_avail = CHAR_BITS;
+		jbi_in_length = GET_DWORD(offset + 7 + delta);
+		jbi_out_length =
+			(((unsigned long) GET_BYTE(data_section + value)) |
+			(((unsigned long) GET_BYTE(data_section + value + 1)) << 8) |
+			(((unsigned long) GET_BYTE(data_section + value + 2)) << 16) |
+			(((unsigned long) GET_BYTE(data_section + value + 3)) << 24));
+		jbi_in_index = 4;	/* skip over length field */
+		jbi_out_index = 0;
+		jbi_aca_in_offset = data_section + value;
+	}
+
+	/* to look back at an earlier page, start over at the beginning */
+	if (page < jbi_current_page)
+	{
+		jbi_current_page = -1;
+		jbi_in_index = 4;	/* skip over length field */
+		jbi_bits_avail = CHAR_BITS;
+	}
+
+	/* uncompress sequentially up to the desired page */
+	while (page > jbi_current_page)
+	{
+		jbi_uncompress_next_page(version);
+	}
+}
+
+#else
+
+/****************************************************************************/
+/*																			*/
+
+unsigned long jbi_uncompress
+(
+	unsigned char *in,
+	unsigned long in_length,
+	unsigned char *out,
+	unsigned long out_length,
+	int version
+)
+
+/*																			*/
+/*	Description:	Uncompress data in "in" and write result to	"out".		*/
+/*																			*/
+/*	Returns:		Length of uncompressed data. -1 if:						*/
+/*						1) out_length is too small							*/
+/*						2) Internal error in the code						*/
+/*						3) in doesn't contain ACA compressed data.			*/
+/*																			*/
+/****************************************************************************/
+{
+	unsigned long i, j, data_length = 0L;
+	unsigned int offset, length;
+	unsigned int match_data_length = MATCH_DATA_LENGTH;
+
+	if (version > 0) --match_data_length;
+
+	jbi_in_length = in_length;
+	jbi_bits_avail = CHAR_BITS;
+	jbi_in_index = 0L;
+	for (i = 0; i < out_length; ++i) out[i] = 0;
+
+	/* Read number of bytes in data. */
+	for (i = 0; i < sizeof (in_length); ++i)
+	{
+		data_length = data_length | ((unsigned long)
+			jbi_read_packed(in, CHAR_BITS) << (i * CHAR_BITS));
+	}
+
+	if (data_length > out_length)
+	{
+		data_length = 0L;
+	}
+	else
+	{
+		i = 0;
+		while (i < data_length)
+		{
+			/* A 0 bit indicates literal data. */
+			if (jbi_read_packed(in, 1) == 0)
+			{
+				for (j = 0; j < DATA_BLOB_LENGTH; ++j)
+				{
+					if (i < data_length)
+					{
+						out[i] = (unsigned char) jbi_read_packed(in, CHAR_BITS);
+						i++;
+					}
+				}
+			}
+			else
+			{
+				/* A 1 bit indicates offset/length to follow. */
+				offset = jbi_read_packed(in, jbi_bits_required((short) (i > match_data_length ? match_data_length : i)));
+				length = jbi_read_packed(in, CHAR_BITS);
+
+				for (j = 0; j < length; ++j)
+				{
+					if (i < data_length)
+					{
+						out[i] = out[i - offset];
+						i++;
+					}
+				}
+			}
+		}
+	}
+
+	return (data_length);
+}
+
+#endif
diff --git a/drivers/cpld/altera/jbicomp.h b/drivers/cpld/altera/jbicomp.h
new file mode 100644
index 0000000..69dc0a9
--- /dev/null
+++ b/drivers/cpld/altera/jbicomp.h
@@ -0,0 +1,37 @@
+/****************************************************************************/
+/*																			*/
+/*	Module:			jbicomp.h												*/
+/*																			*/
+/*					Copyright (C) Altera Corporation 1997-2001				*/
+/*																			*/
+/*	Description:	Contains the function prototypes for compressing		*/
+/*					and uncompressing Boolean array data.					*/
+/*																			*/
+/****************************************************************************/
+
+#ifndef INC_JBICOMP_H
+#define INC_JBICOMP_H
+
+#if PORT==DOS
+
+void jbi_uncompress_page
+(
+	int variable_id,
+	int page,
+	int version
+);
+
+#else
+
+unsigned long jbi_uncompress
+(
+	unsigned char *in,
+	unsigned long in_length,
+	unsigned char *out,
+	unsigned long out_length,
+	int version
+);
+
+#endif /* PORT==DOS */
+
+#endif /* INC_JBICOMP_H */
diff --git a/drivers/cpld/altera/jbiexprt.h b/drivers/cpld/altera/jbiexprt.h
new file mode 100644
index 0000000..6d6a401
--- /dev/null
+++ b/drivers/cpld/altera/jbiexprt.h
@@ -0,0 +1,224 @@
+/****************************************************************************/
+/*																			*/
+/*	Module:			jbiexprt.h												*/
+/*																			*/
+/*					Copyright (C) Altera Corporation 1998-2001				*/
+/*																			*/
+/*	Description:	Jam STAPL ByteCode Player Export Header File			*/
+/*																			*/
+/*	Revisions:																*/
+/*																			*/
+/****************************************************************************/
+
+#ifndef INC_JBIEXPRT_H
+#define INC_JBIEXPRT_H
+
+/****************************************************************************/
+/*																			*/
+/*	Return codes from most JBI functions									*/
+/*																			*/
+/****************************************************************************/
+
+#define JBI_RETURN_TYPE int
+
+#define JBIC_SUCCESS            0
+#define JBIC_OUT_OF_MEMORY      1
+#define JBIC_IO_ERROR           2
+/* #define JAMC_SYNTAX_ERROR       3 */
+#define JBIC_UNEXPECTED_END     4
+#define JBIC_UNDEFINED_SYMBOL   5
+/* #define JAMC_REDEFINED_SYMBOL   6 */
+#define JBIC_INTEGER_OVERFLOW   7
+#define JBIC_DIVIDE_BY_ZERO     8
+#define JBIC_CRC_ERROR          9
+#define JBIC_INTERNAL_ERROR    10
+#define JBIC_BOUNDS_ERROR      11
+/* #define JAMC_TYPE_MISMATCH     12 */
+/* #define JAMC_ASSIGN_TO_CONST   13 */
+/* #define JAMC_NEXT_UNEXPECTED   14 */
+/* #define JAMC_POP_UNEXPECTED    15 */
+/* #define JAMC_RETURN_UNEXPECTED 16 */
+/* #define JAMC_ILLEGAL_SYMBOL    17 */
+#define JBIC_VECTOR_MAP_FAILED 18
+#define JBIC_USER_ABORT        19
+#define JBIC_STACK_OVERFLOW    20
+#define JBIC_ILLEGAL_OPCODE    21
+/* #define JAMC_PHASE_ERROR       22 */
+/* #define JAMC_SCOPE_ERROR       23 */
+#define JBIC_ACTION_NOT_FOUND  24
+
+/****************************************************************************/
+/*																			*/
+/*	Macro Definitions														*/
+/*																			*/
+/****************************************************************************/
+
+/*
+*	For DOS port, program data is stored in a set of 16K pages, accessed
+*	through a pointer table.  For 32-bit version, the buffer is continuous.
+*	The macro GET_BYTE gets a single byte for either case.
+*/
+#if PORT==DOS
+#define PROGRAM_PTR unsigned char **
+#else
+#define PROGRAM_PTR unsigned char *
+#endif
+
+#if PORT==DOS
+#define GET_BYTE(x) (jbi_program[(x) >> 14L][(x) & 0x3fffL])
+#else
+#define GET_BYTE(x) (program[x])
+#endif
+
+#define GET_WORD(x) \
+	(((((unsigned short) GET_BYTE(x)) << 8) & 0xFF00) | \
+	(((unsigned short) GET_BYTE((x)+1)) & 0x00FF))
+
+#define GET_DWORD(x) \
+	(((((unsigned long) GET_BYTE(x)) << 24L) & 0xFF000000L) | \
+	((((unsigned long) GET_BYTE((x)+1)) << 16L) & 0x00FF0000L) | \
+	((((unsigned long) GET_BYTE((x)+2)) << 8L) & 0x0000FF00L) | \
+	(((unsigned long) GET_BYTE((x)+3)) & 0x000000FFL))
+
+/****************************************************************************/
+/*																			*/
+/*	Structured Types														*/
+/*																			*/
+/****************************************************************************/
+
+typedef struct JBI_PROCINFO_STRUCT
+{
+	char *name;
+	unsigned char attributes;
+	struct JBI_PROCINFO_STRUCT *next;
+}
+JBI_PROCINFO;
+
+/****************************************************************************/
+/*																			*/
+/*	Global Data Prototypes													*/
+/*																			*/
+/****************************************************************************/
+
+#if PORT==DOS
+extern unsigned char jbi_aca_out_buffer[8192 + 1024];
+#endif
+
+extern PROGRAM_PTR jbi_program;
+
+extern char *jbi_workspace;
+
+extern long jbi_workspace_size;
+
+/****************************************************************************/
+/*																			*/
+/*	Function Prototypes														*/
+/*																			*/
+/****************************************************************************/
+
+JBI_RETURN_TYPE jbi_execute
+(
+	PROGRAM_PTR program,
+	long program_size,
+	char *workspace,
+	long workspace_size,
+	char *action,
+	char **init_list,
+	int reset_jtag,
+	long *error_address,
+	int *exit_code,
+	int *format_version
+);
+
+JBI_RETURN_TYPE jbi_get_note
+(
+	PROGRAM_PTR program,
+	long program_size,
+	long *offset,
+	char *key,
+	char *value,
+	int length
+);
+
+JBI_RETURN_TYPE jbi_check_crc
+(
+	PROGRAM_PTR program,
+	long program_size,
+	unsigned short *expected_crc,
+	unsigned short *actual_crc
+);
+
+JBI_RETURN_TYPE jbi_get_file_info
+(
+	PROGRAM_PTR program,
+	long program_size,
+	int *format_version,
+	int *action_count,
+	int *procedure_count
+);
+
+JBI_RETURN_TYPE jbi_get_action_info
+(
+	PROGRAM_PTR program,
+	long program_size,
+	int index,
+	char **name,
+	char **description,
+	JBI_PROCINFO **procedure_list
+);
+
+int jbi_jtag_io
+(
+	int tms,
+	int tdi,
+	int read_tdo
+);
+
+void jbi_message
+(
+	char *message_text
+);
+
+void jbi_export_integer
+(
+	char *key,
+	long value
+);
+
+void jbi_export_boolean_array
+(
+	char *key,
+	unsigned char *data,
+	long count
+);
+
+void jbi_delay
+(
+	long microseconds
+);
+
+int jbi_vector_map
+(
+	int signal_count,
+	char **signals
+);
+
+int jbi_vector_io
+(
+	int signal_count,
+	long *dir_vect,
+	long *data_vect,
+	long *capture_vect
+);
+
+void *jbi_malloc
+(
+	unsigned int size
+);
+
+void jbi_free
+(
+	void *ptr
+);
+
+#endif /* INC_JBIEXPRT_H */
diff --git a/drivers/cpld/altera/jbijtag.c b/drivers/cpld/altera/jbijtag.c
new file mode 100644
index 0000000..728ab6a
--- /dev/null
+++ b/drivers/cpld/altera/jbijtag.c
@@ -0,0 +1,1675 @@
+/****************************************************************************/
+/*																			*/
+/*	Module:			jbijtag.c												*/
+/*																			*/
+/*					Copyright (C) Altera Corporation 1998-2001				*/
+/*																			*/
+/*	Description:	Contains JTAG interface functions						*/
+/*																			*/
+/*	Revisions:		2.2  updated state transition paths						*/
+/*					2.0  added multi-page scan code for 16-bit PORT			*/
+/*																			*/
+/****************************************************************************/
+
+#include "jbiport.h"
+#include "jbiexprt.h"
+#include "jbicomp.h"
+#include "jbijtag.h"
+
+#define NULL 0
+
+char *jbi_workspace = NULL;
+long jbi_workspace_size = 0L;
+
+/****************************************************************************/
+/*																			*/
+/*	Enumerated Types														*/
+/*																			*/
+/****************************************************************************/
+
+/* maximum JTAG IR and DR lengths (in bits) */
+#define JBIC_MAX_JTAG_IR_PREAMBLE   256
+#define JBIC_MAX_JTAG_IR_POSTAMBLE  256
+#define JBIC_MAX_JTAG_IR_LENGTH     512
+#define JBIC_MAX_JTAG_DR_PREAMBLE  1024
+#define JBIC_MAX_JTAG_DR_POSTAMBLE 1024
+#define JBIC_MAX_JTAG_DR_LENGTH    2048
+
+/*
+*	Global variable to store the current JTAG state
+*/
+JBIE_JTAG_STATE jbi_jtag_state = JBI_ILLEGAL_JTAG_STATE;
+
+/*
+*	Store current stop-state for DR and IR scan commands
+*/
+JBIE_JTAG_STATE jbi_drstop_state = IDLE;
+JBIE_JTAG_STATE jbi_irstop_state = IDLE;
+
+/*
+*	Store current padding values
+*/
+unsigned int jbi_dr_preamble  = 0;
+unsigned int jbi_dr_postamble = 0;
+unsigned int jbi_ir_preamble  = 0;
+unsigned int jbi_ir_postamble = 0;
+unsigned int jbi_dr_length    = 0;
+unsigned int jbi_ir_length    = 0;
+unsigned char *jbi_dr_preamble_data  = NULL;
+unsigned char *jbi_dr_postamble_data = NULL;
+unsigned char *jbi_ir_preamble_data  = NULL;
+unsigned char *jbi_ir_postamble_data = NULL;
+unsigned char *jbi_dr_buffer         = NULL;
+unsigned char *jbi_ir_buffer         = NULL;
+
+/*
+*	This structure shows, for each JTAG state, which state is reached after
+*	a single TCK clock cycle with TMS high or TMS low, respectively.  This
+*	describes all possible state transitions in the JTAG state machine.
+*/
+struct JBIS_JTAG_MACHINE
+{
+	JBIE_JTAG_STATE tms_high;
+	JBIE_JTAG_STATE tms_low;
+} jbi_jtag_state_transitions[] =
+{
+/* RESET     */	{ RESET,	IDLE },
+/* IDLE      */	{ DRSELECT,	IDLE },
+/* DRSELECT  */	{ IRSELECT,	DRCAPTURE },
+/* DRCAPTURE */	{ DREXIT1,	DRSHIFT },
+/* DRSHIFT   */	{ DREXIT1,	DRSHIFT },
+/* DREXIT1   */	{ DRUPDATE,	DRPAUSE },
+/* DRPAUSE   */	{ DREXIT2,	DRPAUSE },
+/* DREXIT2   */	{ DRUPDATE,	DRSHIFT },
+/* DRUPDATE  */	{ DRSELECT,	IDLE },
+/* IRSELECT  */	{ RESET,	IRCAPTURE },
+/* IRCAPTURE */	{ IREXIT1,	IRSHIFT },
+/* IRSHIFT   */	{ IREXIT1,	IRSHIFT },
+/* IREXIT1   */	{ IRUPDATE,	IRPAUSE },
+/* IRPAUSE   */	{ IREXIT2,	IRPAUSE },
+/* IREXIT2   */	{ IRUPDATE,	IRSHIFT },
+/* IRUPDATE  */	{ DRSELECT,	IDLE }
+};
+
+/*
+*	This table contains the TMS value to be used to take the NEXT STEP on
+*	the path to the desired state.  The array index is the current state,
+*	and the bit position is the desired endstate.  To find out which state
+*	is used as the intermediate state, look up the TMS value in the
+*	jbi_jtag_state_transitions[] table.
+*/
+unsigned short jbi_jtag_path_map[16] =
+{
+/*    RST     RTI    SDRS     CDR     SDR    E1DR     PDR    E2DR       */
+	0x0001, 0xFFFD, 0xFE01, 0xFFE7, 0xFFEF, 0xFF0F, 0xFFBF, 0xFFFF,
+/*    UDR    SIRS     CIR     SIR    E1IR     PIR    E2IR     UIR       */
+	0xFEFD, 0x0001, 0xF3FF, 0xF7FF, 0x87FF, 0xDFFF, 0xFFFF, 0x7FFD
+};
+
+/*
+*	Flag bits for jbi_jtag_io() function
+*/
+#define TMS_HIGH   1
+#define TMS_LOW    0
+#define TDI_HIGH   1
+#define TDI_LOW    0
+#define READ_TDO   1
+#define IGNORE_TDO 0
+
+/****************************************************************************/
+/*																			*/
+
+JBI_RETURN_TYPE jbi_init_jtag()
+
+/*																			*/
+/****************************************************************************/
+{
+	/* initial JTAG state is unknown */
+	jbi_jtag_state = JBI_ILLEGAL_JTAG_STATE;
+
+	/* initialize global variables to default state */
+	jbi_drstop_state = IDLE;
+	jbi_irstop_state = IDLE;
+	jbi_dr_preamble  = 0;
+	jbi_dr_postamble = 0;
+	jbi_ir_preamble  = 0;
+	jbi_ir_postamble = 0;
+	jbi_dr_length    = 0;
+	jbi_ir_length    = 0;
+
+	if (jbi_workspace != NULL)
+	{
+		jbi_dr_preamble_data = (unsigned char *) jbi_workspace;
+		jbi_dr_postamble_data = &jbi_dr_preamble_data[JBIC_MAX_JTAG_DR_PREAMBLE / 8];
+		jbi_ir_preamble_data = &jbi_dr_postamble_data[JBIC_MAX_JTAG_DR_POSTAMBLE / 8];
+		jbi_ir_postamble_data = &jbi_ir_preamble_data[JBIC_MAX_JTAG_IR_PREAMBLE / 8];
+		jbi_dr_buffer = &jbi_ir_postamble_data[JBIC_MAX_JTAG_IR_POSTAMBLE / 8];
+		jbi_ir_buffer = &jbi_dr_buffer[JBIC_MAX_JTAG_DR_LENGTH / 8];
+	}
+	else
+	{
+		jbi_dr_preamble_data  = NULL;
+		jbi_dr_postamble_data = NULL;
+		jbi_ir_preamble_data  = NULL;
+		jbi_ir_postamble_data = NULL;
+		jbi_dr_buffer         = NULL;
+		jbi_ir_buffer         = NULL;
+	}
+
+	return (JBIC_SUCCESS);
+}
+
+/****************************************************************************/
+/*																			*/
+
+JBI_RETURN_TYPE jbi_set_drstop_state
+(
+	JBIE_JTAG_STATE state
+)
+
+/*																			*/
+/****************************************************************************/
+{
+	jbi_drstop_state = state;
+
+	return (JBIC_SUCCESS);
+}
+
+/****************************************************************************/
+/*																			*/
+
+JBI_RETURN_TYPE jbi_set_irstop_state
+(
+	JBIE_JTAG_STATE state
+)
+
+/*																			*/
+/****************************************************************************/
+{
+	jbi_irstop_state = state;
+
+	return (JBIC_SUCCESS);
+}
+
+/****************************************************************************/
+/*																			*/
+
+JBI_RETURN_TYPE jbi_set_dr_preamble
+(
+	unsigned int count,
+	unsigned int start_index,
+	unsigned char *preamble_data
+)
+
+/*																			*/
+/****************************************************************************/
+{
+	JBI_RETURN_TYPE status = JBIC_SUCCESS;
+	unsigned int i;
+	unsigned int j;
+
+	if (jbi_workspace != NULL)
+	{
+		if (count > JBIC_MAX_JTAG_DR_PREAMBLE)
+		{
+			status = JBIC_OUT_OF_MEMORY;
+		}
+		else
+		{
+			jbi_dr_preamble = count;
+		}
+	}
+	else
+	{
+		if (count > jbi_dr_preamble)
+		{
+			jbi_free(jbi_dr_preamble_data);
+			jbi_dr_preamble_data = (unsigned char *) jbi_malloc((count + 7) >> 3);
+
+			if (jbi_dr_preamble_data == NULL)
+			{
+				status = JBIC_OUT_OF_MEMORY;
+			}
+			else
+			{
+				jbi_dr_preamble = count;
+			}
+		}
+		else
+		{
+			jbi_dr_preamble = count;
+		}
+	}
+
+	if (status == JBIC_SUCCESS)
+	{
+		for (i = 0; i < count; ++i)
+		{
+			j = i + start_index;
+
+			if (preamble_data == NULL)
+			{
+				jbi_dr_preamble_data[i >> 3] |= (1 << (i & 7));
+			}
+			else
+			{
+				if (preamble_data[j >> 3] & (1 << (j & 7)))
+				{
+					jbi_dr_preamble_data[i >> 3] |= (1 << (i & 7));
+				}
+				else
+				{
+					jbi_dr_preamble_data[i >> 3] &=
+						~(unsigned int) (1 << (i & 7));
+				}
+			}
+		}
+	}
+
+	return (status);
+}
+
+/****************************************************************************/
+/*																			*/
+
+JBI_RETURN_TYPE jbi_set_ir_preamble
+(
+	unsigned int count,
+	unsigned int start_index,
+	unsigned char *preamble_data
+)
+
+/*																			*/
+/****************************************************************************/
+{
+	JBI_RETURN_TYPE status = JBIC_SUCCESS;
+	unsigned int i;
+	unsigned int j;
+
+	if (jbi_workspace != NULL)
+	{
+		if (count > JBIC_MAX_JTAG_IR_PREAMBLE)
+		{
+			status = JBIC_OUT_OF_MEMORY;
+		}
+		else
+		{
+			jbi_ir_preamble = count;
+		}
+	}
+	else
+	{
+		if (count > jbi_ir_preamble)
+		{
+			jbi_free(jbi_ir_preamble_data);
+			jbi_ir_preamble_data = (unsigned char *) jbi_malloc((count + 7) >> 3);
+
+			if (jbi_ir_preamble_data == NULL)
+			{
+				status = JBIC_OUT_OF_MEMORY;
+			}
+			else
+			{
+				jbi_ir_preamble = count;
+			}
+		}
+		else
+		{
+			jbi_ir_preamble = count;
+		}
+	}
+
+	if (status == JBIC_SUCCESS)
+	{
+		for (i = 0; i < count; ++i)
+		{
+			j = i + start_index;
+
+			if (preamble_data == NULL)
+			{
+				jbi_ir_preamble_data[i >> 3] |= (1 << (i & 7));
+			}
+			else
+			{
+				if (preamble_data[j >> 3] & (1 << (j & 7)))
+				{
+					jbi_ir_preamble_data[i >> 3] |= (1 << (i & 7));
+				}
+				else
+				{
+					jbi_ir_preamble_data[i >> 3] &=
+						~(unsigned int) (1 << (i & 7));
+				}
+			}
+		}
+	}
+
+	return (status);
+}
+
+/****************************************************************************/
+/*																			*/
+
+JBI_RETURN_TYPE jbi_set_dr_postamble
+(
+	unsigned int count,
+	unsigned int start_index,
+	unsigned char *postamble_data
+)
+
+/*																			*/
+/****************************************************************************/
+{
+	JBI_RETURN_TYPE status = JBIC_SUCCESS;
+	unsigned int i;
+	unsigned int j;
+
+	if (jbi_workspace != NULL)
+	{
+		if (count > JBIC_MAX_JTAG_DR_POSTAMBLE)
+		{
+			status = JBIC_OUT_OF_MEMORY;
+		}
+		else
+		{
+			jbi_dr_postamble = count;
+		}
+	}
+	else
+	{
+		if (count > jbi_dr_postamble)
+		{
+			jbi_free(jbi_dr_postamble_data);
+			jbi_dr_postamble_data = (unsigned char *) jbi_malloc((count + 7) >> 3);
+
+			if (jbi_dr_postamble_data == NULL)
+			{
+				status = JBIC_OUT_OF_MEMORY;
+			}
+			else
+			{
+				jbi_dr_postamble = count;
+			}
+		}
+		else
+		{
+			jbi_dr_postamble = count;
+		}
+	}
+
+	if (status == JBIC_SUCCESS)
+	{
+		for (i = 0; i < count; ++i)
+		{
+			j = i + start_index;
+
+			if (postamble_data == NULL)
+			{
+				jbi_dr_postamble_data[i >> 3] |= (1 << (i & 7));
+			}
+			else
+			{
+				if (postamble_data[j >> 3] & (1 << (j & 7)))
+				{
+					jbi_dr_postamble_data[i >> 3] |= (1 << (i & 7));
+				}
+				else
+				{
+					jbi_dr_postamble_data[i >> 3] &=
+						~(unsigned int) (1 << (i & 7));
+				}
+			}
+		}
+	}
+
+	return (status);
+}
+
+/****************************************************************************/
+/*																			*/
+
+JBI_RETURN_TYPE jbi_set_ir_postamble
+(
+	unsigned int count,
+	unsigned int start_index,
+	unsigned char *postamble_data
+)
+
+/*																			*/
+/****************************************************************************/
+{
+	JBI_RETURN_TYPE status = JBIC_SUCCESS;
+	unsigned int i;
+	unsigned int j;
+
+	if (jbi_workspace != NULL)
+	{
+		if (count > JBIC_MAX_JTAG_IR_POSTAMBLE)
+		{
+			status = JBIC_OUT_OF_MEMORY;
+		}
+		else
+		{
+			jbi_ir_postamble = count;
+		}
+	}
+	else
+	{
+		if (count > jbi_ir_postamble)
+		{
+			jbi_free(jbi_ir_postamble_data);
+			jbi_ir_postamble_data = (unsigned char *) jbi_malloc((count + 7) >> 3);
+
+			if (jbi_ir_postamble_data == NULL)
+			{
+				status = JBIC_OUT_OF_MEMORY;
+			}
+			else
+			{
+				jbi_ir_postamble = count;
+			}
+		}
+		else
+		{
+			jbi_ir_postamble = count;
+		}
+	}
+
+	if (status == JBIC_SUCCESS)
+	{
+		for (i = 0; i < count; ++i)
+		{
+			j = i + start_index;
+
+			if (postamble_data == NULL)
+			{
+				jbi_ir_postamble_data[i >> 3] |= (1 << (i & 7));
+			}
+			else
+			{
+				if (postamble_data[j >> 3] & (1 << (j & 7)))
+				{
+					jbi_ir_postamble_data[i >> 3] |= (1 << (i & 7));
+				}
+				else
+				{
+					jbi_ir_postamble_data[i >> 3] &=
+						~(unsigned int) (1 << (i & 7));
+				}
+			}
+		}
+	}
+
+	return (status);
+}
+
+/****************************************************************************/
+/*																			*/
+
+void jbi_jtag_reset_idle(void)
+
+/*																			*/
+/****************************************************************************/
+{
+	int i;
+
+	/*
+	*	Go to Test Logic Reset (no matter what the starting state may be)
+	*/
+	for (i = 0; i < 5; ++i)
+	{
+		jbi_jtag_io(TMS_HIGH, TDI_LOW, IGNORE_TDO);
+	}
+
+	/*
+	*	Now step to Run Test / Idle
+	*/
+	jbi_jtag_io(TMS_LOW, TDI_LOW, IGNORE_TDO);
+
+	jbi_jtag_state = IDLE;
+}
+
+/****************************************************************************/
+/*																			*/
+
+JBI_RETURN_TYPE jbi_goto_jtag_state
+(
+	JBIE_JTAG_STATE state
+)
+
+/*																			*/
+/****************************************************************************/
+{
+	int tms;
+	int count = 0;
+	JBI_RETURN_TYPE status = JBIC_SUCCESS;
+
+	if (jbi_jtag_state == JBI_ILLEGAL_JTAG_STATE)
+	{
+		/* initialize JTAG chain to known state */
+		jbi_jtag_reset_idle();
+	}
+
+	if (jbi_jtag_state == state)
+	{
+		/*
+		*	We are already in the desired state.  If it is a stable state,
+		*	loop here.  Otherwise do nothing (no clock cycles).
+		*/
+		if ((state == IDLE) ||
+			(state == DRSHIFT) ||
+			(state == DRPAUSE) ||
+			(state == IRSHIFT) ||
+			(state == IRPAUSE))
+		{
+			jbi_jtag_io(TMS_LOW, TDI_LOW, IGNORE_TDO);
+		}
+		else if (state == RESET)
+		{
+			jbi_jtag_io(TMS_HIGH, TDI_LOW, IGNORE_TDO);
+		}
+	}
+	else
+	{
+		while ((jbi_jtag_state != state) && (count < 9))
+		{
+			/*
+			*	Get TMS value to take a step toward desired state
+			*/
+			tms = (jbi_jtag_path_map[jbi_jtag_state] & (1 << state)) ?
+				TMS_HIGH : TMS_LOW;
+
+			/*
+			*	Take a step
+			*/
+			jbi_jtag_io(tms, TDI_LOW, IGNORE_TDO);
+
+			if (tms)
+			{
+				jbi_jtag_state =
+					jbi_jtag_state_transitions[jbi_jtag_state].tms_high;
+			}
+			else
+			{
+				jbi_jtag_state =
+					jbi_jtag_state_transitions[jbi_jtag_state].tms_low;
+			}
+
+			++count;
+		}
+	}
+
+	if (jbi_jtag_state != state)
+	{
+		status = JBIC_INTERNAL_ERROR;
+	}
+
+	return (status);
+}
+
+/****************************************************************************/
+/*																			*/
+
+JBI_RETURN_TYPE jbi_do_wait_cycles
+(
+	long cycles,
+	JBIE_JTAG_STATE wait_state
+)
+
+/*																			*/
+/*	Description:	Causes JTAG hardware to loop in the specified stable	*/
+/*					state for the specified number of TCK clock cycles.		*/
+/*																			*/
+/*	Returns:		JBIC_SUCCESS for success, else appropriate error code	*/
+/*																			*/
+/****************************************************************************/
+{
+	int tms;
+	long count;
+	JBI_RETURN_TYPE status = JBIC_SUCCESS;
+
+	if (jbi_jtag_state != wait_state)
+	{
+		status = jbi_goto_jtag_state(wait_state);
+	}
+
+	if (status == JBIC_SUCCESS)
+	{
+		/*
+		*	Set TMS high to loop in RESET state
+		*	Set TMS low to loop in any other stable state
+		*/
+		tms = (wait_state == RESET) ? TMS_HIGH : TMS_LOW;
+
+		for (count = 0L; count < cycles; count++)
+		{
+			jbi_jtag_io(tms, TDI_LOW, IGNORE_TDO);
+		}
+	}
+
+	return (status);
+}
+
+/****************************************************************************/
+/*																			*/
+
+JBI_RETURN_TYPE jbi_do_wait_microseconds
+(
+	long microseconds,
+	JBIE_JTAG_STATE wait_state
+)
+
+/*																			*/
+/*	Description:	Causes JTAG hardware to sit in the specified stable		*/
+/*					state for the specified duration of real time.  If		*/
+/*					no JTAG operations have been performed yet, then only	*/
+/*					a delay is performed.  This permits the WAIT USECS		*/
+/*					statement to be used in VECTOR programs without causing	*/
+/*					any JTAG operations.									*/
+/*																			*/
+/*	Returns:		JBIC_SUCCESS for success, else appropriate error code	*/
+/*																			*/
+/****************************************************************************/
+{
+	JBI_RETURN_TYPE status = JBIC_SUCCESS;
+
+	if ((jbi_jtag_state != JBI_ILLEGAL_JTAG_STATE) &&
+		(jbi_jtag_state != wait_state))
+	{
+		status = jbi_goto_jtag_state(wait_state);
+	}
+
+	if (status == JBIC_SUCCESS)
+	{
+		/*
+		*	Wait for specified time interval
+		*/
+		jbi_delay(microseconds);
+	}
+
+	return (status);
+}
+
+/****************************************************************************/
+/*																			*/
+
+void jbi_jtag_concatenate_data
+(
+	unsigned char *buffer,
+	unsigned char *preamble_data,
+	unsigned int preamble_count,
+	unsigned char *target_data,
+	unsigned long start_index,
+	unsigned int target_count,
+	unsigned char *postamble_data,
+	unsigned int postamble_count
+)
+
+/*																			*/
+/*	Description:	Copies preamble data, target data, and postamble data	*/
+/*					into one buffer for IR or DR scans.						*/
+/*																			*/
+/*	Returns:		nothing													*/
+/*																			*/
+/****************************************************************************/
+{
+	unsigned long i;
+	unsigned long j;
+	unsigned long k;
+
+	for (i = 0L; i < preamble_count; ++i)
+	{
+		if (preamble_data[i >> 3L] & (1L << (i & 7L)))
+		{
+			buffer[i >> 3L] |= (1L << (i & 7L));
+		}
+		else
+		{
+			buffer[i >> 3L] &= ~(unsigned int) (1L << (i & 7L));
+		}
+	}
+
+	j = start_index;
+	k = preamble_count + target_count;
+	for (; i < k; ++i, ++j)
+	{
+		if (target_data[j >> 3L] & (1L << (j & 7L)))
+		{
+			buffer[i >> 3L] |= (1L << (i & 7L));
+		}
+		else
+		{
+			buffer[i >> 3L] &= ~(unsigned int) (1L << (i & 7L));
+		}
+	}
+
+	j = 0L;
+	k = preamble_count + target_count + postamble_count;
+	for (; i < k; ++i, ++j)
+	{
+		if (postamble_data[j >> 3L] & (1L << (j & 7L)))
+		{
+			buffer[i >> 3L] |= (1L << (i & 7L));
+		}
+		else
+		{
+			buffer[i >> 3L] &= ~(unsigned int) (1L << (i & 7L));
+		}
+	}
+}
+
+int jbi_jtag_drscan
+(
+	int start_state,
+	int count,
+	unsigned char *tdi,
+	unsigned char *tdo
+)
+{
+	int i = 0;
+	int tdo_bit = 0;
+	int status = 1;
+
+	/*
+	*	First go to DRSHIFT state
+	*/
+	switch (start_state)
+	{
+	case 0:						/* IDLE */
+		jbi_jtag_io(1, 0, 0);	/* DRSELECT */
+		jbi_jtag_io(0, 0, 0);	/* DRCAPTURE */
+		jbi_jtag_io(0, 0, 0);	/* DRSHIFT */
+		break;
+
+	case 1:						/* DRPAUSE */
+		jbi_jtag_io(1, 0, 0);	/* DREXIT2 */
+		jbi_jtag_io(1, 0, 0);	/* DRUPDATE */
+		jbi_jtag_io(1, 0, 0);	/* DRSELECT */
+		jbi_jtag_io(0, 0, 0);	/* DRCAPTURE */
+		jbi_jtag_io(0, 0, 0);	/* DRSHIFT */
+		break;
+
+	case 2:						/* IRPAUSE */
+		jbi_jtag_io(1, 0, 0);	/* IREXIT2 */
+		jbi_jtag_io(1, 0, 0);	/* IRUPDATE */
+		jbi_jtag_io(1, 0, 0);	/* DRSELECT */
+		jbi_jtag_io(0, 0, 0);	/* DRCAPTURE */
+		jbi_jtag_io(0, 0, 0);	/* DRSHIFT */
+		break;
+
+	default:
+		status = 0;
+	}
+
+	if (status)
+	{
+		/* loop in the SHIFT-DR state */
+		for (i = 0; i < count; i++)
+		{
+			tdo_bit = jbi_jtag_io(
+				(i == count - 1),
+				tdi[i >> 3] & (1 << (i & 7)),
+				(tdo != NULL));
+
+			if (tdo != NULL)
+			{
+				if (tdo_bit)
+				{
+					tdo[i >> 3] |= (1 << (i & 7));
+				}
+				else
+				{
+					tdo[i >> 3] &= ~(unsigned int) (1 << (i & 7));
+				}
+			}
+		}
+
+		jbi_jtag_io(0, 0, 0);	/* DRPAUSE */
+	}
+
+	return (status);
+}
+
+int jbi_jtag_irscan
+(
+	int start_state,
+	int count,
+	unsigned char *tdi,
+	unsigned char *tdo
+)
+{
+	int i = 0;
+	int tdo_bit = 0;
+	int status = 1;
+
+	/*
+	*	First go to IRSHIFT state
+	*/
+	switch (start_state)
+	{
+	case 0:						/* IDLE */
+		jbi_jtag_io(1, 0, 0);	/* DRSELECT */
+		jbi_jtag_io(1, 0, 0);	/* IRSELECT */
+		jbi_jtag_io(0, 0, 0);	/* IRCAPTURE */
+		jbi_jtag_io(0, 0, 0);	/* IRSHIFT */
+		break;
+
+	case 1:						/* DRPAUSE */
+		jbi_jtag_io(1, 0, 0);	/* DREXIT2 */
+		jbi_jtag_io(1, 0, 0);	/* DRUPDATE */
+		jbi_jtag_io(1, 0, 0);	/* DRSELECT */
+		jbi_jtag_io(1, 0, 0);	/* IRSELECT */
+		jbi_jtag_io(0, 0, 0);	/* IRCAPTURE */
+		jbi_jtag_io(0, 0, 0);	/* IRSHIFT */
+		break;
+
+	case 2:						/* IRPAUSE */
+		jbi_jtag_io(1, 0, 0);	/* IREXIT2 */
+		jbi_jtag_io(1, 0, 0);	/* IRUPDATE */
+		jbi_jtag_io(1, 0, 0);	/* DRSELECT */
+		jbi_jtag_io(1, 0, 0);	/* IRSELECT */
+		jbi_jtag_io(0, 0, 0);	/* IRCAPTURE */
+		jbi_jtag_io(0, 0, 0);	/* IRSHIFT */
+		break;
+
+	default:
+		status = 0;
+	}
+
+	if (status)
+	{
+		/* loop in the SHIFT-IR state */
+		for (i = 0; i < count; i++)
+		{
+			tdo_bit = jbi_jtag_io(
+				(i == count - 1),
+				tdi[i >> 3] & (1 << (i & 7)),
+				(tdo != NULL));
+
+			if (tdo != NULL)
+			{
+				if (tdo_bit)
+				{
+					tdo[i >> 3] |= (1 << (i & 7));
+				}
+				else
+				{
+					tdo[i >> 3] &= ~(unsigned int) (1 << (i & 7));
+				}
+			}
+		}
+
+		jbi_jtag_io(0, 0, 0);	/* IRPAUSE */
+	}
+
+	return (status);
+}
+
+/****************************************************************************/
+/*																			*/
+
+void jbi_jtag_extract_target_data
+(
+	unsigned char *buffer,
+	unsigned char *target_data,
+	unsigned int start_index,
+	unsigned int preamble_count,
+	unsigned int target_count
+)
+
+/*																			*/
+/*	Description:	Copies target data from scan buffer, filtering out		*/
+/*					preamble and postamble data.							*/
+/*																			*/
+/*	Returns:		nothing													*/
+/*																			*/
+/****************************************************************************/
+{
+	unsigned int i;
+	unsigned int j;
+	unsigned int k;
+
+	j = preamble_count;
+	k = start_index + target_count;
+	for (i = start_index; i < k; ++i, ++j)
+	{
+		if (buffer[j >> 3] & (1 << (j & 7)))
+		{
+			target_data[i >> 3] |= (1 << (i & 7));
+		}
+		else
+		{
+			target_data[i >> 3] &= ~(unsigned int) (1 << (i & 7));
+		}
+	}
+}
+
+/****************************************************************************/
+/*																			*/
+
+JBI_RETURN_TYPE jbi_do_irscan
+(
+	unsigned int count,
+	unsigned char *tdi_data,
+	unsigned int start_index
+)
+
+/*																			*/
+/*	Description:	Shifts data into instruction register					*/
+/*																			*/
+/*	Returns:		JBIC_SUCCESS for success, else appropriate error code	*/
+/*																			*/
+/****************************************************************************/
+{
+	int start_code = 0;
+	unsigned int alloc_chars = 0;
+	unsigned int shift_count = jbi_ir_preamble + count + jbi_ir_postamble;
+	JBI_RETURN_TYPE status = JBIC_SUCCESS;
+	JBIE_JTAG_STATE start_state = JBI_ILLEGAL_JTAG_STATE;
+
+	switch (jbi_jtag_state)
+	{
+	case JBI_ILLEGAL_JTAG_STATE:
+	case RESET:
+	case IDLE:
+		start_code = 0;
+		start_state = IDLE;
+		break;
+
+	case DRSELECT:
+	case DRCAPTURE:
+	case DRSHIFT:
+	case DREXIT1:
+	case DRPAUSE:
+	case DREXIT2:
+	case DRUPDATE:
+		start_code = 1;
+		start_state = DRPAUSE;
+		break;
+
+	case IRSELECT:
+	case IRCAPTURE:
+	case IRSHIFT:
+	case IREXIT1:
+	case IRPAUSE:
+	case IREXIT2:
+	case IRUPDATE:
+		start_code = 2;
+		start_state = IRPAUSE;
+		break;
+
+	default:
+		status = JBIC_INTERNAL_ERROR;
+		break;
+	}
+
+	if (status == JBIC_SUCCESS)
+	{
+		if (jbi_jtag_state != start_state)
+		{
+			status = jbi_goto_jtag_state(start_state);
+		}
+	}
+
+	if (status == JBIC_SUCCESS)
+	{
+		if (jbi_workspace != NULL)
+		{
+			if (shift_count > JBIC_MAX_JTAG_IR_LENGTH)
+			{
+				status = JBIC_OUT_OF_MEMORY;
+			}
+		}
+		else if (shift_count > jbi_ir_length)
+		{
+			alloc_chars = (shift_count + 7) >> 3;
+			jbi_free(jbi_ir_buffer);
+			jbi_ir_buffer = (unsigned char *) jbi_malloc(alloc_chars);
+
+			if (jbi_ir_buffer == NULL)
+			{
+				status = JBIC_OUT_OF_MEMORY;
+			}
+			else
+			{
+				jbi_ir_length = alloc_chars * 8;
+			}
+		}
+	}
+
+	if (status == JBIC_SUCCESS)
+	{
+		/*
+		*	Copy preamble data, IR data, and postamble data into a buffer
+		*/
+		jbi_jtag_concatenate_data
+		(
+			jbi_ir_buffer,
+			jbi_ir_preamble_data,
+			jbi_ir_preamble,
+			tdi_data,
+			start_index,
+			count,
+			jbi_ir_postamble_data,
+			jbi_ir_postamble
+		);
+
+		/*
+		*	Do the IRSCAN
+		*/
+		jbi_jtag_irscan
+		(
+			start_code,
+			shift_count,
+			jbi_ir_buffer,
+			NULL
+		);
+
+		/* jbi_jtag_irscan() always ends in IRPAUSE state */
+		jbi_jtag_state = IRPAUSE;
+	}
+
+	if (status == JBIC_SUCCESS)
+	{
+		if (jbi_irstop_state != IRPAUSE)
+		{
+			status = jbi_goto_jtag_state(jbi_irstop_state);
+		}
+	}
+
+	return (status);
+}
+
+/****************************************************************************/
+/*																			*/
+
+JBI_RETURN_TYPE jbi_swap_ir
+(
+	unsigned int count,
+	unsigned char *in_data,
+	unsigned int in_index,
+	unsigned char *out_data,
+	unsigned int out_index
+)
+
+/*																			*/
+/*	Description:	Shifts data into instruction register, capturing output	*/
+/*					data													*/
+/*																			*/
+/*	Returns:		JBIC_SUCCESS for success, else appropriate error code	*/
+/*																			*/
+/****************************************************************************/
+{
+	int start_code = 0;
+	unsigned int alloc_chars = 0;
+	unsigned int shift_count = jbi_ir_preamble + count + jbi_ir_postamble;
+	JBI_RETURN_TYPE status = JBIC_SUCCESS;
+	JBIE_JTAG_STATE start_state = JBI_ILLEGAL_JTAG_STATE;
+
+	switch (jbi_jtag_state)
+	{
+	case JBI_ILLEGAL_JTAG_STATE:
+	case RESET:
+	case IDLE:
+		start_code = 0;
+		start_state = IDLE;
+		break;
+
+	case DRSELECT:
+	case DRCAPTURE:
+	case DRSHIFT:
+	case DREXIT1:
+	case DRPAUSE:
+	case DREXIT2:
+	case DRUPDATE:
+		start_code = 1;
+		start_state = DRPAUSE;
+		break;
+
+	case IRSELECT:
+	case IRCAPTURE:
+	case IRSHIFT:
+	case IREXIT1:
+	case IRPAUSE:
+	case IREXIT2:
+	case IRUPDATE:
+		start_code = 2;
+		start_state = IRPAUSE;
+		break;
+
+	default:
+		status = JBIC_INTERNAL_ERROR;
+		break;
+	}
+
+	if (status == JBIC_SUCCESS)
+	{
+		if (jbi_jtag_state != start_state)
+		{
+			status = jbi_goto_jtag_state(start_state);
+		}
+	}
+
+	if (status == JBIC_SUCCESS)
+	{
+		if (jbi_workspace != NULL)
+		{
+			if (shift_count > JBIC_MAX_JTAG_IR_LENGTH)
+			{
+				status = JBIC_OUT_OF_MEMORY;
+			}
+		}
+		else if (shift_count > jbi_ir_length)
+		{
+			alloc_chars = (shift_count + 7) >> 3;
+			jbi_free(jbi_ir_buffer);
+			jbi_ir_buffer = (unsigned char *) jbi_malloc(alloc_chars);
+
+			if (jbi_ir_buffer == NULL)
+			{
+				status = JBIC_OUT_OF_MEMORY;
+			}
+			else
+			{
+				jbi_ir_length = alloc_chars * 8;
+			}
+		}
+	}
+
+	if (status == JBIC_SUCCESS)
+	{
+		/*
+		*	Copy preamble data, IR data, and postamble data into a buffer
+		*/
+		jbi_jtag_concatenate_data
+		(
+			jbi_ir_buffer,
+			jbi_ir_preamble_data,
+			jbi_ir_preamble,
+			in_data,
+			in_index,
+			count,
+			jbi_ir_postamble_data,
+			jbi_ir_postamble
+		);
+
+		/*
+		*	Do the IRSCAN
+		*/
+		jbi_jtag_irscan
+		(
+			start_code,
+			shift_count,
+			jbi_ir_buffer,
+			jbi_ir_buffer
+		);
+
+		/* jbi_jtag_irscan() always ends in IRPAUSE state */
+		jbi_jtag_state = IRPAUSE;
+	}
+
+	if (status == JBIC_SUCCESS)
+	{
+		if (jbi_irstop_state != IRPAUSE)
+		{
+			status = jbi_goto_jtag_state(jbi_irstop_state);
+		}
+	}
+
+	if (status == JBIC_SUCCESS)
+	{
+		/*
+		*	Now extract the returned data from the buffer
+		*/
+		jbi_jtag_extract_target_data
+		(
+			jbi_ir_buffer,
+			out_data,
+			out_index,
+			jbi_ir_preamble,
+			count
+		);
+	}
+
+	return (status);
+}
+
+/****************************************************************************/
+/*																			*/
+
+JBI_RETURN_TYPE jbi_do_drscan
+(
+	unsigned int count,
+	unsigned char *tdi_data,
+	unsigned long start_index
+)
+
+/*																			*/
+/*	Description:	Shifts data into data register (ignoring output data)	*/
+/*																			*/
+/*	Returns:		JBIC_SUCCESS for success, else appropriate error code	*/
+/*																			*/
+/****************************************************************************/
+{
+	int start_code = 0;
+	unsigned int alloc_chars = 0;
+	unsigned int shift_count = jbi_dr_preamble + count + jbi_dr_postamble;
+	JBI_RETURN_TYPE status = JBIC_SUCCESS;
+	JBIE_JTAG_STATE start_state = JBI_ILLEGAL_JTAG_STATE;
+
+	switch (jbi_jtag_state)
+	{
+	case JBI_ILLEGAL_JTAG_STATE:
+	case RESET:
+	case IDLE:
+		start_code = 0;
+		start_state = IDLE;
+		break;
+
+	case DRSELECT:
+	case DRCAPTURE:
+	case DRSHIFT:
+	case DREXIT1:
+	case DRPAUSE:
+	case DREXIT2:
+	case DRUPDATE:
+		start_code = 1;
+		start_state = DRPAUSE;
+		break;
+
+	case IRSELECT:
+	case IRCAPTURE:
+	case IRSHIFT:
+	case IREXIT1:
+	case IRPAUSE:
+	case IREXIT2:
+	case IRUPDATE:
+		start_code = 2;
+		start_state = IRPAUSE;
+		break;
+
+	default:
+		status = JBIC_INTERNAL_ERROR;
+		break;
+	}
+
+	if (status == JBIC_SUCCESS)
+	{
+		if (jbi_jtag_state != start_state)
+		{
+			status = jbi_goto_jtag_state(start_state);
+		}
+	}
+
+	if (status == JBIC_SUCCESS)
+	{
+		if (jbi_workspace != NULL)
+		{
+			if (shift_count > JBIC_MAX_JTAG_DR_LENGTH)
+			{
+				status = JBIC_OUT_OF_MEMORY;
+			}
+		}
+		else if (shift_count > jbi_dr_length)
+		{
+			alloc_chars = (shift_count + 7) >> 3;
+			jbi_free(jbi_dr_buffer);
+			jbi_dr_buffer = (unsigned char *) jbi_malloc(alloc_chars);
+
+			if (jbi_dr_buffer == NULL)
+			{
+				status = JBIC_OUT_OF_MEMORY;
+			}
+			else
+			{
+				jbi_dr_length = alloc_chars * 8;
+			}
+		}
+	}
+
+	if (status == JBIC_SUCCESS)
+	{
+		/*
+		*	Copy preamble data, DR data, and postamble data into a buffer
+		*/
+		jbi_jtag_concatenate_data
+		(
+			jbi_dr_buffer,
+			jbi_dr_preamble_data,
+			jbi_dr_preamble,
+			tdi_data,
+			start_index,
+			count,
+			jbi_dr_postamble_data,
+			jbi_dr_postamble
+		);
+
+		/*
+		*	Do the DRSCAN
+		*/
+		jbi_jtag_drscan
+		(
+			start_code,
+			shift_count,
+			jbi_dr_buffer,
+			NULL
+		);
+
+		/* jbi_jtag_drscan() always ends in DRPAUSE state */
+		jbi_jtag_state = DRPAUSE;
+	}
+
+	if (status == JBIC_SUCCESS)
+	{
+		if (jbi_drstop_state != DRPAUSE)
+		{
+			status = jbi_goto_jtag_state(jbi_drstop_state);
+		}
+	}
+
+	return (status);
+}
+
+/****************************************************************************/
+/*																			*/
+
+JBI_RETURN_TYPE jbi_swap_dr
+(
+	unsigned int count,
+	unsigned char *in_data,
+	unsigned long in_index,
+	unsigned char *out_data,
+	unsigned int out_index
+)
+
+/*																			*/
+/*	Description:	Shifts data into data register, capturing output data	*/
+/*																			*/
+/*	Returns:		JBIC_SUCCESS for success, else appropriate error code	*/
+/*																			*/
+/****************************************************************************/
+{
+	int start_code = 0;
+	unsigned int alloc_chars = 0;
+	unsigned int shift_count = jbi_dr_preamble + count + jbi_dr_postamble;
+	JBI_RETURN_TYPE status = JBIC_SUCCESS;
+	JBIE_JTAG_STATE start_state = JBI_ILLEGAL_JTAG_STATE;
+
+	switch (jbi_jtag_state)
+	{
+	case JBI_ILLEGAL_JTAG_STATE:
+	case RESET:
+	case IDLE:
+		start_code = 0;
+		start_state = IDLE;
+		break;
+
+	case DRSELECT:
+	case DRCAPTURE:
+	case DRSHIFT:
+	case DREXIT1:
+	case DRPAUSE:
+	case DREXIT2:
+	case DRUPDATE:
+		start_code = 1;
+		start_state = DRPAUSE;
+		break;
+
+	case IRSELECT:
+	case IRCAPTURE:
+	case IRSHIFT:
+	case IREXIT1:
+	case IRPAUSE:
+	case IREXIT2:
+	case IRUPDATE:
+		start_code = 2;
+		start_state = IRPAUSE;
+		break;
+
+	default:
+		status = JBIC_INTERNAL_ERROR;
+		break;
+	}
+
+	if (status == JBIC_SUCCESS)
+	{
+		if (jbi_jtag_state != start_state)
+		{
+			status = jbi_goto_jtag_state(start_state);
+		}
+	}
+
+	if (status == JBIC_SUCCESS)
+	{
+		if (jbi_workspace != NULL)
+		{
+			if (shift_count > JBIC_MAX_JTAG_DR_LENGTH)
+			{
+				status = JBIC_OUT_OF_MEMORY;
+			}
+		}
+		else if (shift_count > jbi_dr_length)
+		{
+			alloc_chars = (shift_count + 7) >> 3;
+			jbi_free(jbi_dr_buffer);
+			jbi_dr_buffer = (unsigned char *) jbi_malloc(alloc_chars);
+
+			if (jbi_dr_buffer == NULL)
+			{
+				status = JBIC_OUT_OF_MEMORY;
+			}
+			else
+			{
+				jbi_dr_length = alloc_chars * 8;
+			}
+		}
+	}
+
+	if (status == JBIC_SUCCESS)
+	{
+		/*
+		*	Copy preamble data, DR data, and postamble data into a buffer
+		*/
+		jbi_jtag_concatenate_data
+		(
+			jbi_dr_buffer,
+			jbi_dr_preamble_data,
+			jbi_dr_preamble,
+			in_data,
+			in_index,
+			count,
+			jbi_dr_postamble_data,
+			jbi_dr_postamble
+		);
+
+		/*
+		*	Do the DRSCAN
+		*/
+		jbi_jtag_drscan
+		(
+			start_code,
+			shift_count,
+			jbi_dr_buffer,
+			jbi_dr_buffer
+		);
+
+		/* jbi_jtag_drscan() always ends in DRPAUSE state */
+		jbi_jtag_state = DRPAUSE;
+	}
+
+	if (status == JBIC_SUCCESS)
+	{
+		if (jbi_drstop_state != DRPAUSE)
+		{
+			status = jbi_goto_jtag_state(jbi_drstop_state);
+		}
+	}
+
+	if (status == JBIC_SUCCESS)
+	{
+		/*
+		*	Now extract the returned data from the buffer
+		*/
+		jbi_jtag_extract_target_data
+		(
+			jbi_dr_buffer,
+			out_data,
+			out_index,
+			jbi_dr_preamble,
+			count
+		);
+	}
+
+	return (status);
+}
+
+/****************************************************************************/
+/*																			*/
+
+void jbi_free_jtag_padding_buffers(int reset_jtag)
+
+/*																			*/
+/*	Description:	Frees memory allocated for JTAG IR and DR buffers		*/
+/*																			*/
+/*	Returns:		nothing													*/
+/*																			*/
+/****************************************************************************/
+{
+	/*
+	*	If the JTAG interface was used, reset it to TLR
+	*/
+	if (reset_jtag && (jbi_jtag_state != JBI_ILLEGAL_JTAG_STATE))
+	{
+		jbi_jtag_reset_idle();
+	}
+
+	if (jbi_workspace == NULL)
+	{
+		if (jbi_dr_preamble_data != NULL)
+		{
+			jbi_free(jbi_dr_preamble_data);
+			jbi_dr_preamble_data = NULL;
+		}
+
+		if (jbi_dr_postamble_data != NULL)
+		{
+			jbi_free(jbi_dr_postamble_data);
+			jbi_dr_postamble_data = NULL;
+		}
+
+		if (jbi_dr_buffer != NULL)
+		{
+			jbi_free(jbi_dr_buffer);
+			jbi_dr_buffer = NULL;
+		}
+
+		if (jbi_ir_preamble_data != NULL)
+		{
+			jbi_free(jbi_ir_preamble_data);
+			jbi_ir_preamble_data = NULL;
+		}
+
+		if (jbi_ir_postamble_data != NULL)
+		{
+			jbi_free(jbi_ir_postamble_data);
+			jbi_ir_postamble_data = NULL;
+		}
+
+		if (jbi_ir_buffer != NULL)
+		{
+			jbi_free(jbi_ir_buffer);
+			jbi_ir_buffer = NULL;
+		}
+	}
+}
+
+#if PORT==DOS
+
+/****************************************************************************/
+/*																			*/
+
+JBI_RETURN_TYPE jbi_do_drscan_multi_page
+(
+	unsigned int variable_id,
+	unsigned long count,
+	unsigned long start_index,
+	int version
+)
+
+/*																			*/
+/*	Description:	Shifts data into data register (ignoring output data)	*/
+/*					Scan data comes from compressed Boolean array.          */
+/*																			*/
+/*	Returns:		JBIC_SUCCESS for success, else appropriate error code	*/
+/*																			*/
+/****************************************************************************/
+{
+	JBI_RETURN_TYPE status = JBIC_SUCCESS;
+	unsigned long shift_count = jbi_dr_preamble + count + jbi_dr_postamble;
+	unsigned long i;
+	unsigned long j;
+	unsigned long k;
+	unsigned int bi;
+
+
+	if (status == JBIC_SUCCESS)
+	{
+		status = jbi_goto_jtag_state(DRSHIFT);
+	}
+
+	if (status == JBIC_SUCCESS)
+	{
+		/*
+		*	Get preamble data, DR data, and postamble data one bit at a time
+		*	and immediately scan it into the JTAG chain
+		*/
+
+		for (i = 0L; i < jbi_dr_preamble; ++i)
+		{
+			jbi_jtag_io((i == shift_count - 1),
+				(int) (jbi_dr_preamble_data[i >> 3L] & (1L << (i & 7L))), 0);
+		}
+
+		j = start_index;
+		k = jbi_dr_preamble + count;
+
+		jbi_uncompress_page(variable_id, (unsigned int) (j >> 16L), version);
+
+		for (; i < k; ++i, ++j)
+		{
+			bi = (unsigned int) (j & 0x0000ffffL);
+
+			/* check for page boundary - load next page if necessary */
+			if (bi == 0)
+			{
+				jbi_uncompress_page(variable_id, (unsigned int) (j >> 16L), version);
+			}
+
+			jbi_jtag_io((i == shift_count - 1),
+				(int) (jbi_aca_out_buffer[bi >> 3] & (1 << (bi & 7))), 0);
+		}
+
+		j = 0L;
+		k = jbi_dr_preamble + count + jbi_dr_postamble;
+		for (; i < k; ++i, ++j)
+		{
+			jbi_jtag_io((i == shift_count - 1),
+				(int) (jbi_dr_postamble_data[j >> 3L] & (1L << (j & 7L))), 0);
+		}
+
+		jbi_jtag_io(0, 0, 0);	/* DRPAUSE */
+
+
+		/* jbi_jtag_drscan() always ends in DRPAUSE state */
+		jbi_jtag_state = DRPAUSE;
+
+		if (jbi_drstop_state != DRPAUSE)
+		{
+			status = jbi_goto_jtag_state(jbi_drstop_state);
+		}
+	}
+
+	return (status);
+}
+
+#endif
diff --git a/drivers/cpld/altera/jbijtag.h b/drivers/cpld/altera/jbijtag.h
new file mode 100644
index 0000000..27299f0
--- /dev/null
+++ b/drivers/cpld/altera/jbijtag.h
@@ -0,0 +1,147 @@
+/****************************************************************************/
+/*																			*/
+/*	Module:			jbijtag.h												*/
+/*																			*/
+/*					Copyright (C) Altera Corporation 1998-2001				*/
+/*																			*/
+/*	Description:	Definitions of JTAG constants, types, and functions		*/
+/*																			*/
+/****************************************************************************/
+
+#ifndef INC_JBIJTAG_H
+#define INC_JBIJTAG_H
+
+/****************************************************************************/
+/*																			*/
+/*	Function Prototypes														*/
+/*																			*/
+/****************************************************************************/
+typedef enum
+{
+	JBI_ILLEGAL_JTAG_STATE = -1,
+	RESET = 0,
+	IDLE = 1,
+	DRSELECT = 2,
+	DRCAPTURE = 3,
+	DRSHIFT = 4,
+	DREXIT1 = 5,
+	DRPAUSE = 6,
+	DREXIT2 = 7,
+	DRUPDATE = 8,
+	IRSELECT = 9,
+	IRCAPTURE = 10,
+	IRSHIFT = 11,
+	IREXIT1 = 12,
+	IRPAUSE = 13,
+	IREXIT2 = 14,
+	IRUPDATE = 15
+
+} JBIE_JTAG_STATE;
+
+
+JBI_RETURN_TYPE jbi_init_jtag
+(
+	void
+);
+
+JBI_RETURN_TYPE jbi_set_drstop_state
+(
+    JBIE_JTAG_STATE state
+);
+
+JBI_RETURN_TYPE jbi_set_irstop_state
+(
+    JBIE_JTAG_STATE state
+);
+
+JBI_RETURN_TYPE jbi_set_dr_preamble
+(
+	unsigned int count,
+	unsigned int start_index,
+	unsigned char *preamble_data
+);
+
+JBI_RETURN_TYPE jbi_set_ir_preamble
+(
+	unsigned int count,
+	unsigned int start_index,
+	unsigned char *preamble_data
+);
+
+JBI_RETURN_TYPE jbi_set_dr_postamble
+(
+	unsigned int count,
+	unsigned int start_index,
+	unsigned char *postamble_data
+);
+
+JBI_RETURN_TYPE jbi_set_ir_postamble
+(
+	unsigned int count,
+	unsigned int start_index,
+	unsigned char *postamble_data
+);
+
+JBI_RETURN_TYPE jbi_goto_jtag_state
+(
+    JBIE_JTAG_STATE state
+);
+
+JBI_RETURN_TYPE jbi_do_wait_cycles
+(
+	long cycles,
+	JBIE_JTAG_STATE wait_state
+);
+
+JBI_RETURN_TYPE jbi_do_wait_microseconds
+(
+	long microseconds,
+	JBIE_JTAG_STATE wait_state
+);
+
+JBI_RETURN_TYPE jbi_do_irscan
+(
+	unsigned int count,
+	unsigned char *tdi_data,
+	unsigned int start_index
+);
+
+JBI_RETURN_TYPE jbi_swap_ir
+(
+	unsigned int count,
+	unsigned char *in_data,
+	unsigned int in_index,
+	unsigned char *out_data,
+	unsigned int out_index
+);
+
+JBI_RETURN_TYPE jbi_do_drscan
+(
+	unsigned int count,
+	unsigned char *tdi_data,
+	unsigned long start_index
+);
+
+JBI_RETURN_TYPE jbi_swap_dr
+(
+	unsigned int count,
+	unsigned char *in_data,
+	unsigned long in_index,
+	unsigned char *out_data,
+	unsigned int out_index
+);
+
+void jbi_free_jtag_padding_buffers
+(
+	int reset_jtag
+);
+
+JBI_RETURN_TYPE jbi_do_drscan_multi_page
+(
+	unsigned int variable_id,
+	unsigned long long_count,
+	unsigned long long_index,
+	int version
+);
+
+#endif /* INC_JBIJTAG_H */
diff --git a/drivers/cpld/altera/jbimain.c b/drivers/cpld/altera/jbimain.c
new file mode 100644
index 0000000..2298925
--- /dev/null
+++ b/drivers/cpld/altera/jbimain.c
@@ -0,0 +1,3290 @@
+/****************************************************************************/
+/*																			*/
+/*	Module:			jbimain.c												*/
+/*																			*/
+/*					Copyright (C) Altera Corporation 1998-2001				*/
+/*																			*/
+/*	Description:	Jam STAPL ByteCode Player (Interpreter)					*/
+/*																			*/
+/*	Revisions:		2.2  fixed /W4 warnings									*/
+/*					2.0  added support for STAPL ByteCode format			*/
+/*																			*/
+/****************************************************************************/
+
+#include "jbiport.h"
+#include "jbiexprt.h"
+#include "jbijtag.h"
+#include "jbicomp.h"
+
+/****************************************************************************/
+/*																			*/
+/*	MACROS																	*/
+/*																			*/
+/****************************************************************************/
+
+#define NULL 0
+
+#define JBI_STACK_SIZE 128
+
+#define JBIC_MESSAGE_LENGTH 1024
+
+/*
+*	This macro checks if enough parameters are available on the stack. The
+*	argument is the number of parameters needed.
+*/
+#define IF_CHECK_STACK(x) \
+	if (stack_ptr < (int) (x)) \
+	{ \
+		status = JBIC_STACK_OVERFLOW; \
+	} \
+	else
+
+/*
+*	This macro checks if a code address is inside the code section
+*/
+#define CHECK_PC \
+	if ((pc < code_section) || (pc >= debug_section)) \
+	{ \
+		status = JBIC_BOUNDS_ERROR; \
+	}
+
+/****************************************************************************/
+/*																			*/
+/*	GLOBAL VARIABLES														*/
+/*																			*/
+/****************************************************************************/
+
+#if PORT==DOS
+/*
+*	jbi_program is a global pointer used by macros GET_BYTE, GET_WORD, and
+*	GET_DWORD to read data from the JBC file
+*/
+PROGRAM_PTR jbi_program;
+#endif
+
+/****************************************************************************/
+/*																			*/
+/*	UTILITY FUNCTIONS														*/
+/*																			*/
+/****************************************************************************/
+
+int jbi_strlen(char *string)
+{
+	int len = 0;
+
+	while (string[len] != '\0') ++len;
+
+	return (len);
+}
+
+long jbi_atol(char *buffer)
+{
+	long result = 0L;
+	int index = 0;
+
+	while ((buffer[index] >= '0') && (buffer[index] <= '9'))
+	{
+		result = (result * 10) + (buffer[index] - '0');
+		++index;
+	}
+
+	return (result);
+}
+
+void jbi_ltoa(char *buffer, long number)
+{
+	int index = 0;
+	int rev_index = 0;
+	char reverse[32];
+
+	if (number < 0L)
+	{
+		buffer[index++] = '-';
+		number = 0 - number;
+	}
+	else if (number == 0)
+	{
+		buffer[index++] = '0';
+	}
+
+	while (number != 0)
+	{
+		reverse[rev_index++] = (char) ((number % 10) + '0');
+		number /= 10;
+	}
+
+	while (rev_index > 0)
+	{
+		buffer[index++] = reverse[--rev_index];
+	}
+
+	buffer[index] = '\0';
+}
+
+char jbi_toupper(char ch)
+{
+	return ((char) (((ch >= 'a') && (ch <= 'z')) ? (ch + 'A' - 'a') : ch));
+}
+
+int jbi_stricmp(char *left, char *right)
+{
+	int result = 0;
+	char l, r;
+
+	do
+	{
+		l = jbi_toupper(*left);
+		r = jbi_toupper(*right);
+		result = l - r;
+		++left;
+		++right;
+	}
+	while ((result == 0) && (l != '\0') && (r != '\0'));
+
+	return (result);
+}
+
+void jbi_strncpy(char *left, char *right, int count)
+{
+	char ch;
+
+	do
+	{
+		*left = *right;
+		ch = *right;
+		++left;
+		++right;
+		--count;
+	}
+	while ((ch != '\0') && (count != 0));
+}
+
+void jbi_make_dword(unsigned char *buf, unsigned long num)
+{
+	buf[0] = (unsigned char) num;
+	buf[1] = (unsigned char) (num >> 8L);
+	buf[2] = (unsigned char) (num >> 16L);
+	buf[3] = (unsigned char) (num >> 24L);
+}
+
+unsigned long jbi_get_dword(unsigned char *buf)
+{
+	return
+		(((unsigned long) buf[0]) |
+		(((unsigned long) buf[1]) << 8L) |
+		(((unsigned long) buf[2]) << 16L) |
+		(((unsigned long) buf[3]) << 24L));
+}
+
+/****************************************************************************/
+/*																			*/
+
+JBI_RETURN_TYPE jbi_execute
+(
+	PROGRAM_PTR program,
+	long program_size,
+	char *workspace,
+	long workspace_size,
+	char *action,
+	char **init_list,
+	int reset_jtag,
+	long *error_address,
+	int *exit_code,
+	int *format_version
+)
+
+/*																			*/
+/*	Description:															*/
+/*																			*/
+/*	Returns:																*/
+/*																			*/
+/****************************************************************************/
+{
+	JBI_RETURN_TYPE status = JBIC_SUCCESS;
+	unsigned long first_word = 0L;
+	unsigned long action_table = 0L;
+	unsigned long proc_table = 0L;
+	unsigned long string_table = 0L;
+	unsigned long symbol_table = 0L;
+	unsigned long data_section = 0L;
+	unsigned long code_section = 0L;
+	unsigned long debug_section = 0L;
+	unsigned long action_count = 0L;
+	unsigned long proc_count = 0L;
+	unsigned long symbol_count = 0L;
+	char message_buffer[JBIC_MESSAGE_LENGTH + 1];
+	long *variables = NULL;
+	long *variable_size = NULL;
+	char *attributes = NULL;
+	unsigned char *proc_attributes = NULL;
+	unsigned long pc;
+	unsigned long opcode_address;
+	unsigned long args[3];
+	unsigned int opcode;
+	unsigned long name_id;
+	long stack[JBI_STACK_SIZE] = {0};
+	unsigned char charbuf[4];
+	long long_temp;
+	unsigned int variable_id;
+	unsigned char *charptr_temp;
+	unsigned char *charptr_temp2;
+	long *longptr_temp;
+	int version = 0;
+	int delta = 0;
+	int stack_ptr = 0;
+	unsigned int arg_count;
+	int done = 0;
+	int bad_opcode = 0;
+	unsigned int count;
+	unsigned int index;
+	unsigned int index2;
+	long long_count;
+	long long_index;
+	long long_index2;
+	unsigned int i;
+	unsigned int j;
+	unsigned long uncompressed_size;
+	unsigned int offset;
+	unsigned long value;
+	int current_proc = 0;
+	char *equal_ptr;
+	int length;
+	int reverse;
+
+#if PORT==DOS
+	char name[33];
+#else
+	char *name;
+#endif
+
+	jbi_workspace = workspace;
+	jbi_workspace_size = workspace_size;
+
+#if PORT==DOS
+	jbi_program = program;
+#endif
+
+	/*
+	*	Read header information
+	*/
+	if (program_size > 52L)
+	{
+		first_word    = GET_DWORD(0);
+		version = (int) (first_word & 1L);
+		*format_version = version + 1;
+		delta = version * 8;
+
+		action_table  = GET_DWORD(4);
+		proc_table    = GET_DWORD(8);
+		string_table  = GET_DWORD(4 + delta);
+		symbol_table  = GET_DWORD(16 + delta);
+		data_section  = GET_DWORD(20 + delta);
+		code_section  = GET_DWORD(24 + delta);
+		debug_section = GET_DWORD(28 + delta);
+		action_count  = GET_DWORD(40 + delta);
+		proc_count    = GET_DWORD(44 + delta);
+		symbol_count  = GET_DWORD(48 + (2 * delta));
+	}
+
+	if ((first_word != 0x4A414D00L) && (first_word != 0x4A414D01L))
+	{
+		done = 1;
+		status = JBIC_IO_ERROR;
+	}
+
+	if ((status == JBIC_SUCCESS) && (symbol_count > 0))
+	{
+		variables = (long *) jbi_malloc(
+			(unsigned int) symbol_count * sizeof(long));
+
+		if (variables == NULL) status = JBIC_OUT_OF_MEMORY;
+
+		if (status == JBIC_SUCCESS)
+		{
+			variable_size = (long *) jbi_malloc(
+				(unsigned int) symbol_count * sizeof(long));
+
+			if (variable_size == NULL) status = JBIC_OUT_OF_MEMORY;
+		}
+
+		if (status == JBIC_SUCCESS)
+		{
+			attributes = (char *) jbi_malloc((unsigned int) symbol_count);
+
+			if (attributes == NULL) status = JBIC_OUT_OF_MEMORY;
+		}
+
+		if ((status == JBIC_SUCCESS) && (version > 0))
+		{
+			proc_attributes = (unsigned char *) jbi_malloc((unsigned int) proc_count);
+
+			if (proc_attributes == NULL) status = JBIC_OUT_OF_MEMORY;
+		}
+
+		if (status == JBIC_SUCCESS)
+		{
+			delta = version * 2;
+
+			for (i = 0; i < (unsigned int) symbol_count; ++i)
+			{
+				offset = (unsigned int) (symbol_table + ((11 + delta) * i));
+
+				value = GET_DWORD(offset + 3 + delta);
+
+				attributes[i] = GET_BYTE(offset);
+
+				/* use bit 7 of attribute byte to indicate that this buffer */
+				/* was dynamically allocated and should be freed later */
+				attributes[i] &= 0x7f;
+
+				variable_size[i] = GET_DWORD(offset + 7 + delta);
+
+				/*
+				*	Attribute bits:
+				*	bit 0:	0 = read-only, 1 = read-write
+				*	bit 1:	0 = not compressed, 1 = compressed
+				*	bit 2:	0 = not initialized, 1 = initialized
+				*	bit 3:	0 = scalar, 1 = array
+				*	bit 4:	0 = Boolean, 1 = integer
+				*	bit 5:	0 = declared variable,
+				*			1 = compiler created temporary variable
+				*/
+
+				if ((attributes[i] & 0x0c) == 0x04)
+				{
+					/* initialized scalar variable */
+					variables[i] = value;
+				}
+				else if ((attributes[i] & 0x1e) == 0x0e)
+				{
+					/* initialized compressed Boolean array */
+#if PORT==DOS
+					/* for DOS port, get the size but do not uncompress */
+					long_index = data_section + value;
+					uncompressed_size =
+						(((unsigned long) GET_BYTE(long_index)) |
+						(((unsigned long) GET_BYTE(long_index + 1L)) << 8L) |
+						(((unsigned long) GET_BYTE(long_index + 2L)) << 16L) |
+						(((unsigned long) GET_BYTE(long_index + 3L)) << 24L));
+					variable_size[i] = uncompressed_size;
+#else
+					uncompressed_size = jbi_get_dword(
+						&program[data_section + value]);
+
+					/* allocate a buffer for the uncompressed data */
+					variables[i] = (long) jbi_malloc(uncompressed_size);
+
+					if (variables[i] == 0L)
+					{
+						status = JBIC_OUT_OF_MEMORY;
+					}
+					else
+					{
+						/* set flag so buffer will be freed later */
+						attributes[i] |= 0x80;
+
+						/* uncompress the data */
+						if (jbi_uncompress(
+							&program[data_section + value],
+							variable_size[i],
+							(unsigned char *) variables[i],
+							uncompressed_size,
+							version)
+							!= uncompressed_size)
+						{
+							/* decompression failed */
+							status = JBIC_IO_ERROR;
+						}
+						else
+						{
+							variable_size[i] = uncompressed_size * 8L;
+						}
+					}
+#endif
+				}
+				else if ((attributes[i] & 0x1e) == 0x0c)
+				{
+					/* initialized Boolean array */
+#if PORT==DOS
+					/* flag attributes so that memory is freed */
+					attributes[i] |= 0x80;
+
+					if (variable_size[i] > 0)
+					{
+						unsigned int size = (unsigned int)
+							((variable_size[i] + 7L) / 8L);
+
+						variables[i] = (long) jbi_malloc(size);
+
+						if (variables[i] == NULL)
+						{
+							status = JBIC_OUT_OF_MEMORY;
+						}
+						else
+						{
+							unsigned char *p = (unsigned char *) variables[i];
+							/* copy array values into buffer */
+							for (j = 0; j < size; ++j)
+							{
+								p[j] = GET_BYTE(data_section + value + j);
+							}
+						}
+					}
+					else
+					{
+						variables[i] = 0;
+					}
+#else
+					variables[i] = value + data_section + (long) program;
+#endif
+				}
+				else if ((attributes[i] & 0x1c) == 0x1c)
+				{
+					/* initialized integer array */
+					variables[i] = value + data_section;
+				}
+				else if ((attributes[i] & 0x0c) == 0x08)
+				{
+					/* uninitialized array */
+
+					/* flag attributes so that memory is freed */
+					attributes[i] |= 0x80;
+
+					if (variable_size[i] > 0)
+					{
+						unsigned int size;
+
+						if (attributes[i] & 0x10)
+						{
+							/* integer array */
+							size = (unsigned int)
+								(variable_size[i] * sizeof(long));
+						}
+						else
+						{
+							/* Boolean array */
+							size = (unsigned int)
+								((variable_size[i] + 7L) / 8L);
+						}
+
+						variables[i] = (long) jbi_malloc(size);
+
+						if (variables[i] == NULL)
+						{
+							status = JBIC_OUT_OF_MEMORY;
+						}
+						else
+						{
+							/* zero out memory */
+							for (j = 0; j < size; ++j)
+							{
+								((unsigned char *)(variables[i]))[j] = 0;
+							}
+						}
+					}
+					else
+					{
+						variables[i] = 0;
+					}
+				}
+				else
+				{
+					variables[i] = 0;
+				}
+			}
+		}
+	}
+
+	/*
+	*	Initialize variables listed in init_list
+	*/
+	if ((status == JBIC_SUCCESS) && (init_list != NULL) && (version == 0))
+	{
+		delta = version * 2;
+		count = 0;
+		while (init_list[count] != NULL)
+		{
+			equal_ptr = init_list[count];
+			length = 0;
+			while ((*equal_ptr != '=') && (*equal_ptr != '\0'))
+			{
+				++equal_ptr;
+				++length;
+			}
+			if (*equal_ptr == '=')
+			{
+				++equal_ptr;
+				value = jbi_atol(equal_ptr);
+				jbi_strncpy(message_buffer, init_list[count], length);
+				message_buffer[length] = '\0';
+				for (i = 0; i < (unsigned int) symbol_count; ++i)
+				{
+					offset = (unsigned int) (symbol_table + ((11 + delta) * i));
+					name_id = (version == 0) ? GET_WORD(offset + 1) :
+						GET_DWORD(offset + 1);
+#if PORT==DOS
+					for (j = 0; j < 32; ++j)
+					{
+						name[j] = GET_BYTE(string_table + name_id + j);
+					}
+					name[32] = '\0';
+#else
+					name = (char *) &program[string_table + name_id];
+#endif
+
+					if (jbi_stricmp(message_buffer, name) == 0)
+					{
+						variables[i] = value;
+					}
+				}
+			}
+
+			++count;
+		}
+	}
+
+	if (status != JBIC_SUCCESS) done = 1;
+
+	jbi_init_jtag();
+
+	pc = code_section;
+	message_buffer[0] = '\0';
+
+	/*
+	*	For JBC version 2, we will execute the procedures corresponding to
+	*	the selected ACTION
+	*/
+	if (version > 0)
+	{
+		if (action == NULL)
+		{
+			status = JBIC_ACTION_NOT_FOUND;
+			done = 1;
+		}
+		else
+		{
+			int action_found = 0;
+
+			for (i = 0; (i < action_count) && !action_found; ++i)
+			{
+				name_id = GET_DWORD(action_table + (12 * i));
+
+#if PORT==DOS
+				for (j = 0; j < 32; ++j)
+				{
+					name[j] = GET_BYTE(string_table + name_id + j);
+				}
+				name[32] = '\0';
+#else
+				name = (char *) &program[string_table + name_id];
+#endif
+
+				if (jbi_stricmp(action, name) == 0)
+				{
+					action_found = 1;
+					current_proc = (int) GET_DWORD(action_table + (12 * i) + 8);
+				}
+			}
+
+			if (!action_found)
+			{
+				status = JBIC_ACTION_NOT_FOUND;
+				done = 1;
+			}
+		}
+
+		if (status == JBIC_SUCCESS)
+		{
+			int first_time = 1;
+			i = current_proc;
+			while ((i != 0) || first_time)
+			{
+				first_time = 0;
+				/* check procedure attribute byte */
+				proc_attributes[i] = (unsigned char)
+					(GET_BYTE(proc_table + (13 * i) + 8) & 0x03);
+
+				if (proc_attributes[i] != 0)
+				{
+					/*
+					*	BIT0 - OPTIONAL
+					*	BIT1 - RECOMMENDED
+					*	BIT6 - FORCED OFF
+					*	BIT7 - FORCED ON
+					*/
+					if (init_list != NULL)
+					{
+						name_id = GET_DWORD(proc_table + (13 * i));
+#if PORT==DOS
+						for (j = 0; j < 32; ++j)
+						{
+							name[j] = GET_BYTE(string_table + name_id + j);
+						}
+						name[32] = '\0';
+#else
+						name = (char *) &program[string_table + name_id];
+#endif
+						count = 0;
+						while (init_list[count] != NULL)
+						{
+							equal_ptr = init_list[count];
+							length = 0;
+							while ((*equal_ptr != '=') && (*equal_ptr != '\0'))
+							{
+								++equal_ptr;
+								++length;
+							}
+							if (*equal_ptr == '=')
+							{
+								++equal_ptr;
+								jbi_strncpy(message_buffer, init_list[count], length);
+								message_buffer[length] = '\0';
+
+								if (jbi_stricmp(message_buffer, name) == 0)
+								{
+									if (jbi_atol(equal_ptr) == 0)
+									{
+										proc_attributes[i] |= 0x40;
+									}
+									else
+									{
+										proc_attributes[i] |= 0x80;
+									}
+								}
+							}
+
+							++count;
+						}
+					}
+				}
+
+				i = (unsigned int) GET_DWORD(proc_table + (13 * i) + 4);
+			}
+
+			/*
+			*	Set current_proc to the first procedure to be executed
+			*/
+			i = current_proc;
+			while ((i != 0) &&
+				((proc_attributes[i] == 1) ||
+				((proc_attributes[i] & 0xc0) == 0x40)))
+			{
+				i = (unsigned int) GET_DWORD(proc_table + (13 * i) + 4);
+			}
+
+			if ((i != 0) || ((i == 0) && (current_proc == 0) &&
+				((proc_attributes[0] != 1) &&
+				((proc_attributes[0] & 0xc0) != 0x40))))
+			{
+				current_proc = i;
+				pc = code_section + GET_DWORD(proc_table + (13 * i) + 9);
+				CHECK_PC;
+			}
+			else
+			{
+				/* there are no procedures to execute! */
+				done = 1;
+			}
+		}
+	}
+
+	message_buffer[0] = '\0';
+
+	while (!done)
+	{
+		opcode = (unsigned int) (GET_BYTE(pc) & 0xff);
+		opcode_address = pc;
+		++pc;
+
+		arg_count = (opcode >> 6) & 3;
+		for (i = 0; i < arg_count; ++i)
+		{
+			args[i] = GET_DWORD(pc);
+			pc += 4;
+		}
+
+		switch (opcode)
+		{
+		case 0x00: /* NOP  */
+			/* do nothing */
+			break;
+
+		case 0x01: /* DUP  */
+			IF_CHECK_STACK(1)
+			{
+				stack[stack_ptr] = stack[stack_ptr - 1];
+				++stack_ptr;
+			}
+			break;
+
+		case 0x02: /* SWP  */
+			IF_CHECK_STACK(2)
+			{
+				long_temp = stack[stack_ptr - 2];
+				stack[stack_ptr - 2] = stack[stack_ptr - 1];
+				stack[stack_ptr - 1] = long_temp;
+			}
+			break;
+
+		case 0x03: /* ADD  */
+			IF_CHECK_STACK(2)
+			{
+				--stack_ptr;
+				stack[stack_ptr - 1] += stack[stack_ptr];
+			}
+			break;
+
+		case 0x04: /* SUB  */
+			IF_CHECK_STACK(2)
+			{
+				--stack_ptr;
+				stack[stack_ptr - 1] -= stack[stack_ptr];
+			}
+			break;
+
+		case 0x05: /* MULT */
+			IF_CHECK_STACK(2)
+			{
+				--stack_ptr;
+				stack[stack_ptr - 1] *= stack[stack_ptr];
+			}
+			break;
+
+		case 0x06: /* DIV  */
+			IF_CHECK_STACK(2)
+			{
+				--stack_ptr;
+				stack[stack_ptr - 1] /= stack[stack_ptr];
+			}
+			break;
+
+		case 0x07: /* MOD  */
+			IF_CHECK_STACK(2)
+			{
+				--stack_ptr;
+				stack[stack_ptr - 1] %= stack[stack_ptr];
+			}
+			break;
+
+		case 0x08: /* SHL  */
+			IF_CHECK_STACK(2)
+			{
+				--stack_ptr;
+				stack[stack_ptr - 1] <<= stack[stack_ptr];
+			}
+			break;
+
+		case 0x09: /* SHR  */
+			IF_CHECK_STACK(2)
+			{
+				--stack_ptr;
+				stack[stack_ptr - 1] >>= stack[stack_ptr];
+			}
+			break;
+
+		case 0x0A: /* NOT  */
+			IF_CHECK_STACK(1)
+			{
+				stack[stack_ptr - 1] ^= (-1L);
+			}
+			break;
+
+		case 0x0B: /* AND  */
+			IF_CHECK_STACK(2)
+			{
+				--stack_ptr;
+				stack[stack_ptr - 1] &= stack[stack_ptr];
+			}
+			break;
+
+		case 0x0C: /* OR   */
+			IF_CHECK_STACK(2)
+			{
+				--stack_ptr;
+				stack[stack_ptr - 1] |= stack[stack_ptr];
+			}
+			break;
+
+		case 0x0D: /* XOR  */
+			IF_CHECK_STACK(2)
+			{
+				--stack_ptr;
+				stack[stack_ptr - 1] ^= stack[stack_ptr];
+			}
+			break;
+
+		case 0x0E: /* INV */
+			IF_CHECK_STACK(1)
+			{
+				stack[stack_ptr - 1] = stack[stack_ptr - 1] ? 0L : 1L;
+			}
+			break;
+
+		case 0x0F: /* GT   */
+			IF_CHECK_STACK(2)
+			{
+				--stack_ptr;
+				stack[stack_ptr - 1] =
+					(stack[stack_ptr - 1] > stack[stack_ptr]) ? 1L : 0L;
+			}
+			break;
+
+		case 0x10: /* LT   */
+			IF_CHECK_STACK(2)
+			{
+				--stack_ptr;
+				stack[stack_ptr - 1] =
+					(stack[stack_ptr - 1] < stack[stack_ptr]) ? 1L : 0L;
+			}
+			break;
+
+		case 0x11: /* RET  */
+			if ((version > 0) && (stack_ptr == 0))
+			{
+				/*
+				*	We completed one of the main procedures of an ACTION.
+				*	Find the next procedure to be executed and jump to it.
+				*	If there are no more procedures, then EXIT.
+				*/
+				i = (unsigned int) GET_DWORD(proc_table + (13 * current_proc) + 4);
+				while ((i != 0) &&
+					((proc_attributes[i] == 1) ||
+					((proc_attributes[i] & 0xc0) == 0x40)))
+				{
+					i = (unsigned int) GET_DWORD(proc_table + (13 * i) + 4);
+				}
+
+				if (i == 0)
+				{
+					/* there are no procedures to execute! */
+					done = 1;
+					*exit_code = 0;	/* success */
+				}
+				else
+				{
+					current_proc = i;
+					pc = code_section + GET_DWORD(proc_table + (13 * i) + 9);
+					CHECK_PC;
+				}
+			}
+			else IF_CHECK_STACK(1)
+			{
+				pc = stack[--stack_ptr] + code_section;
+				CHECK_PC;
+				if (pc == code_section)
+				{
+					status = JBIC_BOUNDS_ERROR;
+				}
+			}
+			break;
+
+		case 0x12: /* CMPS */
+			/*
+			*	Array short compare
+			*	...stack 0 is source 1 value
+			*	...stack 1 is source 2 value
+			*	...stack 2 is mask value
+			*	...stack 3 is count
+			*/
+			IF_CHECK_STACK(4)
+			{
+				long a = stack[--stack_ptr];
+				long b = stack[--stack_ptr];
+				long_temp = stack[--stack_ptr];
+				count = (unsigned int) stack[stack_ptr - 1];
+
+				if ((count < 1) || (count > 32))
+				{
+					status = JBIC_BOUNDS_ERROR;
+				}
+				else
+				{
+					long_temp &= ((-1L) >> (32 - count));
+
+					stack[stack_ptr - 1] =
+						((a & long_temp) == (b & long_temp)) ? 1L : 0L;
+				}
+			}
+			break;
+
+		case 0x13: /* PINT */
+			/*
+			*	PRINT add integer
+			*	...stack 0 is integer value
+			*/
+			IF_CHECK_STACK(1)
+			{
+				jbi_ltoa(&message_buffer[jbi_strlen(message_buffer)],
+					stack[--stack_ptr]);
+			}
+			break;
+
+		case 0x14: /* PRNT */
+			/*
+			*	PRINT finish
+			*/
+			jbi_message(message_buffer);
+			message_buffer[0] = '\0';
+			break;
+
+		case 0x15: /* DSS  */
+			/*
+			*	DRSCAN short
+			*	...stack 0 is scan data
+			*	...stack 1 is count
+			*/
+			IF_CHECK_STACK(2)
+			{
+				long_temp = stack[--stack_ptr];
+				count = (unsigned int) stack[--stack_ptr];
+				jbi_make_dword(charbuf, long_temp);
+				status = jbi_do_drscan(count, charbuf, 0);
+			}
+			break;
+
+		case 0x16: /* DSSC */
+			/*
+			*	DRSCAN short with capture
+			*	...stack 0 is scan data
+			*	...stack 1 is count
+			*/
+			IF_CHECK_STACK(2)
+			{
+				long_temp = stack[--stack_ptr];
+				count = (unsigned int) stack[stack_ptr - 1];
+				jbi_make_dword(charbuf, long_temp);
+				status = jbi_swap_dr(count, charbuf, 0, charbuf, 0);
+				stack[stack_ptr - 1] = jbi_get_dword(charbuf);
+			}
+			break;
+
+		case 0x17: /* ISS  */
+			/*
+			*	IRSCAN short
+			*	...stack 0 is scan data
+			*	...stack 1 is count
+			*/
+			IF_CHECK_STACK(2)
+			{
+				long_temp = stack[--stack_ptr];
+				count = (unsigned int) stack[--stack_ptr];
+				jbi_make_dword(charbuf, long_temp);
+				status = jbi_do_irscan(count, charbuf, 0);
+			}
+			break;
+
+		case 0x18: /* ISSC */
+			/*
+			*	IRSCAN short with capture
+			*	...stack 0 is scan data
+			*	...stack 1 is count
+			*/
+			IF_CHECK_STACK(2)
+			{
+				long_temp = stack[--stack_ptr];
+				count = (unsigned int) stack[stack_ptr - 1];
+				jbi_make_dword(charbuf, long_temp);
+				status = jbi_swap_ir(count, charbuf, 0, charbuf, 0);
+				stack[stack_ptr - 1] = jbi_get_dword(charbuf);
+			}
+			break;
+
+		case 0x19: /* VSS  */
+			/*
+			*	VECTOR short
+			*	...stack 0 is scan data
+			*	...stack 1 is count
+			*/
+			bad_opcode = 1;
+			break;
+
+		case 0x1A: /* VSSC */
+			/*
+			*	VECTOR short with capture
+			*	...stack 0 is scan data
+			*	...stack 1 is count
+			*/
+			bad_opcode = 1;
+			break;
+
+		case 0x1B: /* VMPF */
+			/*
+			*	VMAP finish
+			*/
+			bad_opcode = 1;
+			break;
+
+		case 0x1C: /* DPR  */
+			IF_CHECK_STACK(1)
+			{
+				count = (unsigned int) stack[--stack_ptr];
+				status = jbi_set_dr_preamble(count, 0, NULL);
+			}
+			break;
+
+		case 0x1D: /* DPRL */
+			/*
+			*	DRPRE with literal data
+			*	...stack 0 is count
+			*	...stack 1 is literal data
+			*/
+			IF_CHECK_STACK(2)
+			{
+				count = (unsigned int) stack[--stack_ptr];
+				long_temp = stack[--stack_ptr];
+				jbi_make_dword(charbuf, long_temp);
+				status = jbi_set_dr_preamble(count, 0, charbuf);
+			}
+			break;
+
+		case 0x1E: /* DPO  */
+			/*
+			*	DRPOST
+			*	...stack 0 is count
+			*/
+			IF_CHECK_STACK(1)
+			{
+				count = (unsigned int) stack[--stack_ptr];
+				status = jbi_set_dr_postamble(count, 0, NULL);
+			}
+			break;
+
+		case 0x1F: /* DPOL */
+			/*
+			*	DRPOST with literal data
+			*	...stack 0 is count
+			*	...stack 1 is literal data
+			*/
+			IF_CHECK_STACK(2)
+			{
+				count = (unsigned int) stack[--stack_ptr];
+				long_temp = stack[--stack_ptr];
+				jbi_make_dword(charbuf, long_temp);
+				status = jbi_set_dr_postamble(count, 0, charbuf);
+			}
+			break;
+
+		case 0x20: /* IPR  */
+			IF_CHECK_STACK(1)
+			{
+				count = (unsigned int) stack[--stack_ptr];
+				status = jbi_set_ir_preamble(count, 0, NULL);
+			}
+			break;
+
+		case 0x21: /* IPRL */
+			/*
+			*	IRPRE with literal data
+			*	...stack 0 is count
+			*	...stack 1 is literal data
+			*/
+			IF_CHECK_STACK(2)
+			{
+				count = (unsigned int) stack[--stack_ptr];
+				long_temp = stack[--stack_ptr];
+				jbi_make_dword(charbuf, long_temp);
+				status = jbi_set_ir_preamble(count, 0, charbuf);
+			}
+			break;
+
+		case 0x22: /* IPO  */
+			/*
+			*	IRPOST
+			*	...stack 0 is count
+			*/
+			IF_CHECK_STACK(1)
+			{
+				count = (unsigned int) stack[--stack_ptr];
+				status = jbi_set_ir_postamble(count, 0, NULL);
+			}
+			break;
+
+		case 0x23: /* IPOL */
+			/*
+			*	IRPOST with literal data
+			*	...stack 0 is count
+			*	...stack 1 is literal data
+			*/
+			IF_CHECK_STACK(2)
+			{
+				count = (unsigned int) stack[--stack_ptr];
+				long_temp = stack[--stack_ptr];
+				jbi_make_dword(charbuf, long_temp);
+				status = jbi_set_ir_postamble(count, 0, charbuf);
+			}
+			break;
+
+		case 0x24: /* PCHR */
+			IF_CHECK_STACK(1)
+			{
+				unsigned char ch;
+				count = jbi_strlen(message_buffer);
+				ch = (char) stack[--stack_ptr];
+				if ((ch < 1) || (ch > 127))
+				{
+					/* character code out of range */
+					/* instead of flagging an error, force the value to 127 */
+					ch = 127;
+				}
+				message_buffer[count] = ch;
+				message_buffer[count + 1] = '\0';
+			}
+			break;
+
+		case 0x25: /* EXIT */
+			IF_CHECK_STACK(1)
+			{
+				*exit_code = (int) stack[--stack_ptr];
+			}
+			done = 1;
+			break;
+
+		case 0x26: /* EQU  */
+			IF_CHECK_STACK(2)
+			{
+				--stack_ptr;
+				stack[stack_ptr - 1] =
+					(stack[stack_ptr - 1] == stack[stack_ptr]) ? 1L : 0L;
+			}
+			break;
+
+		case 0x27: /* POPT  */
+			IF_CHECK_STACK(1)
+			{
+				--stack_ptr;
+			}
+			break;
+
+		case 0x28: /* TRST  */
+			bad_opcode = 1;
+			break;
+
+		case 0x29: /* FRQ   */
+			bad_opcode = 1;
+			break;
+
+		case 0x2A: /* FRQU  */
+			bad_opcode = 1;
+			break;
+
+		case 0x2B: /* PD32  */
+			bad_opcode = 1;
+			break;
+
+		case 0x2C: /* ABS   */
+			IF_CHECK_STACK(1)
+			{
+				if (stack[stack_ptr - 1] < 0)
+				{
+					stack[stack_ptr - 1] = 0 - stack[stack_ptr - 1];
+				}
+			}
+			break;
+
+		case 0x2D: /* BCH0  */
+			/*
+			*	Batch operation 0
+			*	SWP
+			*	SWPN 7
+			*	SWP
+			*	SWPN 6
+			*	DUPN 8
+			*	SWPN 2
+			*	SWP
+			*	DUPN 6
+			*	DUPN 6
+			*/
+
+			/* SWP  */
+			IF_CHECK_STACK(2)
+			{
+				long_temp = stack[stack_ptr - 2];
+				stack[stack_ptr - 2] = stack[stack_ptr - 1];
+				stack[stack_ptr - 1] = long_temp;
+			}
+
+			/* SWPN 7 */
+			index = 7 + 1;
+			IF_CHECK_STACK(index)
+			{
+				long_temp = stack[stack_ptr - index];
+				stack[stack_ptr - index] = stack[stack_ptr - 1];
+				stack[stack_ptr - 1] = long_temp;
+			}
+
+			/* SWP  */
+			IF_CHECK_STACK(2)
+			{
+				long_temp = stack[stack_ptr - 2];
+				stack[stack_ptr - 2] = stack[stack_ptr - 1];
+				stack[stack_ptr - 1] = long_temp;
+			}
+
+			/* SWPN 6 */
+			index = 6 + 1;
+			IF_CHECK_STACK(index)
+			{
+				long_temp = stack[stack_ptr - index];
+				stack[stack_ptr - index] = stack[stack_ptr - 1];
+				stack[stack_ptr - 1] = long_temp;
+			}
+
+			/* DUPN 8 */
+			index = 8 + 1;
+			IF_CHECK_STACK(index)
+			{
+				stack[stack_ptr] = stack[stack_ptr - index];
+				++stack_ptr;
+			}
+
+			/* SWPN 2 */
+			index = 2 + 1;
+			IF_CHECK_STACK(index)
+			{
+				long_temp = stack[stack_ptr - index];
+				stack[stack_ptr - index] = stack[stack_ptr - 1];
+				stack[stack_ptr - 1] = long_temp;
+			}
+
+			/* SWP  */
+			IF_CHECK_STACK(2)
+			{
+				long_temp = stack[stack_ptr - 2];
+				stack[stack_ptr - 2] = stack[stack_ptr - 1];
+				stack[stack_ptr - 1] = long_temp;
+			}
+
+			/* DUPN 6 */
+			index = 6 + 1;
+			IF_CHECK_STACK(index)
+			{
+				stack[stack_ptr] = stack[stack_ptr - index];
+				++stack_ptr;
+			}
+
+			/* DUPN 6 */
+			index = 6 + 1;
+			IF_CHECK_STACK(index)
+			{
+				stack[stack_ptr] = stack[stack_ptr - index];
+				++stack_ptr;
+			}
+			break;
+
+		case 0x2E: /* BCH1  */
+			/*
+			*	Batch operation 1
+			*	SWPN 8
+			*	SWP
+			*	SWPN 9
+			*	SWPN 3
+			*	SWP
+			*	SWPN 2
+			*	SWP
+			*	SWPN 7
+			*	SWP
+			*	SWPN 6
+			*	DUPN 5
+			*	DUPN 5
+			*/
+			bad_opcode = 1;
+			break;
+
+		case 0x2F: /* PSH0  */
+			stack[stack_ptr++] = 0;
+			break;
+
+		case 0x40: /* PSHL */
+			stack[stack_ptr++] = (long) args[0];
+			break;
+
+		case 0x41: /* PSHV */
+			stack[stack_ptr++] = variables[args[0]];
+			break;
+
+		case 0x42: /* JMP  */
+			pc = args[0] + code_section;
+			CHECK_PC;
+			break;
+
+		case 0x43: /* CALL */
+			stack[stack_ptr++] = pc;
+			pc = args[0] + code_section;
+			CHECK_PC;
+			break;
+
+		case 0x44: /* NEXT */
+			/*
+			*	Process FOR / NEXT loop
+			*	...argument 0 is variable ID
+			*	...stack 0 is step value
+			*	...stack 1 is end value
+			*	...stack 2 is top address
+			*/
+			IF_CHECK_STACK(3)
+			{
+				long step = stack[stack_ptr - 1];
+				long end = stack[stack_ptr - 2];
+				long top = stack[stack_ptr - 3];
+				long iterator = variables[args[0]];
+				int break_out = 0;
+
+				if (step < 0)
+				{
+					if (iterator <= end) break_out = 1;
+				}
+				else
+				{
+					if (iterator >= end) break_out = 1;
+				}
+
+				if (break_out)
+				{
+					stack_ptr -= 3;
+				}
+				else
+				{
+					variables[args[0]] = iterator + step;
+					pc = top + code_section;
+					CHECK_PC;
+				}
+			}
+			break;
+
+		case 0x45: /* PSTR */
+			/*
+			*	PRINT add string
+			*	...argument 0 is string ID
+			*/
+#if PORT==DOS
+			long_index = string_table + args[0];
+			index2 = jbi_strlen(message_buffer);
+
+			do
+			{
+				i = GET_BYTE(long_index);
+				message_buffer[index2] = (char) i;
+				++long_index;
+				++index2;
+			}
+			while ((i != '\0') && (index2 < JBIC_MESSAGE_LENGTH));
+#else
+			count = jbi_strlen(message_buffer);
+			jbi_strncpy(&message_buffer[count],
+				(char *) &program[string_table + args[0]],
+				JBIC_MESSAGE_LENGTH - count);
+#endif
+			message_buffer[JBIC_MESSAGE_LENGTH] = '\0';
+			break;
+
+		case 0x46: /* VMAP */
+			/*
+			*	VMAP add signal name
+			*	...argument 0 is string ID
+			*/
+			bad_opcode = 1;
+			break;
+
+		case 0x47: /* SINT */
+			/*
+			*	STATE intermediate state
+			*	...argument 0 is state code
+			*/
+			status = jbi_goto_jtag_state((int) args[0]);
+			break;
+
+		case 0x48: /* ST   */
+			/*
+			*	STATE final state
+			*	...argument 0 is state code
+			*/
+			status = jbi_goto_jtag_state((int) args[0]);
+			break;
+
+		case 0x49: /* ISTP */
+			/*
+			*	IRSTOP state
+			*	...argument 0 is state code
+			*/
+			status = jbi_set_irstop_state((int) args[0]);
+			break;
+
+		case 0x4A: /* DSTP */
+			/*
+			*	DRSTOP state
+			*	...argument 0 is state code
+			*/
+			status = jbi_set_drstop_state((int) args[0]);
+			break;
+
+		case 0x4B: /* SWPN */
+			/*
+			*	Exchange top with Nth stack value
+			*	...argument 0 is 0-based stack entry to swap with top element
+			*/
+			index = ((int) args[0]) + 1;
+			IF_CHECK_STACK(index)
+			{
+				long_temp = stack[stack_ptr - index];
+				stack[stack_ptr - index] = stack[stack_ptr - 1];
+				stack[stack_ptr - 1] = long_temp;
+			}
+			break;
+
+		case 0x4C: /* DUPN */
+			/*
+			*	Duplicate Nth stack value
+			*	...argument 0 is 0-based stack entry to duplicate
+			*/
+			index = ((int) args[0]) + 1;
+			IF_CHECK_STACK(index)
+			{
+				stack[stack_ptr] = stack[stack_ptr - index];
+				++stack_ptr;
+			}
+			break;
+
+		case 0x4D: /* POPV */
+			/*
+			*	Pop stack into scalar variable
+			*	...argument 0 is variable ID
+			*	...stack 0 is value
+			*/
+			IF_CHECK_STACK(1)
+			{
+				variables[args[0]] = stack[--stack_ptr];
+			}
+			break;
+
+		case 0x4E: /* POPE */
+			/*
+			*	Pop stack into integer array element
+			*	...argument 0 is variable ID
+			*	...stack 0 is array index
+			*	...stack 1 is value
+			*/
+			IF_CHECK_STACK(2)
+			{
+				variable_id = (unsigned int) args[0];
+
+				/*
+				*	If variable is read-only, convert to writable array
+				*/
+				if ((version > 0) &&
+					((attributes[variable_id] & 0x9c) == 0x1c))
+				{
+					/*
+					*	Allocate a writable buffer for this array
+					*/
+					count = (unsigned int) variable_size[variable_id];
+					long_temp = variables[variable_id];
+					longptr_temp = (long *) jbi_malloc(count * sizeof(long));
+					variables[variable_id] = (long) longptr_temp;
+
+					if (variables[variable_id] == NULL)
+					{
+						status = JBIC_OUT_OF_MEMORY;
+						break;
+					}
+					else
+					{
+						/* copy previous contents into buffer */
+						for (i = 0; i < count; ++i)
+						{
+							longptr_temp[i] = GET_DWORD(long_temp);
+							long_temp += 4L;
+						}
+
+						/* set bit 7 - buffer was dynamically allocated */
+						attributes[variable_id] |= 0x80;
+
+						/* clear bit 2 - variable is writable */
+						attributes[variable_id] &= ~0x04;
+						attributes[variable_id] |= 0x01;
+					}
+				}
+
+#if PORT==DOS
+				/* for 16-bit version, allow writing in allocated buffers */
+				if ((version > 0) &&
+					((attributes[variable_id] & 0x9c) == 0x9c))
+				{
+					attributes[variable_id] &= ~0x04;
+					attributes[variable_id] |= 0x01;
+				}
+#endif
+
+				/* check that variable is a writable integer array */
+				if ((attributes[variable_id] & 0x1c) != 0x18)
+				{
+					status = JBIC_BOUNDS_ERROR;
+				}
+				else
+				{
+					longptr_temp = (long *) variables[variable_id];
+
+					/* pop the array index */
+					index = (unsigned int) stack[--stack_ptr];
+
+					/* pop the value and store it into the array */
+					longptr_temp[index] = stack[--stack_ptr];
+				}
+			}
+			break;
+
+		case 0x4F: /* POPA */
+			/*
+			*	Pop stack into Boolean array
+			*	...argument 0 is variable ID
+			*	...stack 0 is count
+			*	...stack 1 is array index
+			*	...stack 2 is value
+			*/
+			IF_CHECK_STACK(3)
+			{
+				variable_id = (unsigned int) args[0];
+
+				/*
+				*	If variable is read-only, convert to writable array
+				*/
+				if ((version > 0) &&
+					((attributes[variable_id] & 0x9c) == 0x0c))
+				{
+					/*
+					*	Allocate a writable buffer for this array
+					*/
+					long_temp = (variable_size[variable_id] + 7L) >> 3L;
+					charptr_temp2 = (unsigned char *) variables[variable_id];
+					charptr_temp = jbi_malloc((unsigned int) long_temp);
+					variables[variable_id] = (long) charptr_temp;
+
+					if (variables[variable_id] == NULL)
+					{
+						status = JBIC_OUT_OF_MEMORY;
+					}
+					else
+					{
+						/* zero the buffer */
+						for (long_index = 0L;
+							long_index < long_temp;
+							++long_index)
+						{
+							charptr_temp[long_index] = 0;
+						}
+
+						/* copy previous contents into buffer */
+						for (long_index = 0L;
+							long_index < variable_size[variable_id];
+							++long_index)
+						{
+#if PORT==DOS
+							if ((attributes[variable_id] & 0x02) &&
+								((long_index & 0x0000FFFF) == 0L))
+							{
+								/* initialized compressed Boolean array */
+								jbi_uncompress_page(variable_id,
+									(int) (long_index >> 16), version);
+								charptr_temp = jbi_aca_out_buffer;
+								long_index2 = long_index & 0xFFFF;
+							}
+#else
+							long_index2 = long_index;
+#endif
+
+							if (charptr_temp2[long_index2 >> 3] &
+								(1 << (long_index2 & 7)))
+							{
+								charptr_temp[long_index >> 3] |=
+									(1 << (long_index & 7));
+							}
+						}
+
+						/* set bit 7 - buffer was dynamically allocated */
+						attributes[variable_id] |= 0x80;
+
+						/* clear bit 2 - variable is writable */
+						attributes[variable_id] &= ~0x04;
+						attributes[variable_id] |= 0x01;
+					}
+				}
+
+#if PORT==DOS
+				/* for 16-bit version, allow writing in allocated buffers */
+				if ((version > 0) &&
+					((attributes[variable_id] & 0x9c) == 0x8c))
+				{
+					attributes[variable_id] &= ~0x04;
+					attributes[variable_id] |= 0x01;
+				}
+#endif
+
+				/* check that variable is a writable Boolean array */
+				if ((attributes[variable_id] & 0x1c) != 0x08)
+				{
+					status = JBIC_BOUNDS_ERROR;
+				}
+				else
+				{
+					charptr_temp = (unsigned char *) variables[variable_id];
+
+					/* pop the count (number of bits to copy) */
+					long_count = stack[--stack_ptr];
+
+					/* pop the array index */
+					long_index = stack[--stack_ptr];
+
+					reverse = 0;
+
+					if (version > 0)
+					{
+						/* stack 0 = array right index */
+						/* stack 1 = array left index */
+
+						if (long_index > long_count)
+						{
+							reverse = 1;
+							long_temp = long_count;
+							long_count = 1 + long_index - long_count;
+							long_index = long_temp;
+
+							/* reverse POPA is not supported */
+							status = JBIC_BOUNDS_ERROR;
+							break;
+						}
+						else
+						{
+							long_count = 1 + long_count - long_index;
+						}
+					}
+
+					/* pop the data */
+					long_temp = stack[--stack_ptr];
+
+					if (long_count < 1)
+					{
+						status = JBIC_BOUNDS_ERROR;
+					}
+					else
+					{
+						for (i = 0; i < (unsigned int) long_count; ++i)
+						{
+							if (long_temp & (1L << (long) i))
+							{
+								charptr_temp[long_index >> 3L] |=
+									(1L << (long_index & 7L));
+							}
+							else
+							{
+								charptr_temp[long_index >> 3L] &=
+									~ (unsigned int) (1L << (long_index & 7L));
+							}
+							++long_index;
+						}
+					}
+				}
+			}
+			break;
+
+		case 0x50: /* JMPZ */
+			/*
+			*	Pop stack and branch if zero
+			*	...argument 0 is address
+			*	...stack 0 is condition value
+			*/
+			IF_CHECK_STACK(1)
+			{
+				if (stack[--stack_ptr] == 0)
+				{
+					pc = args[0] + code_section;
+					CHECK_PC;
+				}
+			}
+			break;
+
+		case 0x51: /* DS   */
+		case 0x52: /* IS   */
+			/*
+			*	DRSCAN
+			*	IRSCAN
+			*	...argument 0 is scan data variable ID
+			*	...stack 0 is array index
+			*	...stack 1 is count
+			*/
+			IF_CHECK_STACK(2)
+			{
+				long_index = stack[--stack_ptr];
+				long_count = stack[--stack_ptr];
+
+				reverse = 0;
+
+				if (version > 0)
+				{
+					/* stack 0 = array right index */
+					/* stack 1 = array left index */
+					/* stack 2 = count */
+					long_temp = long_count;
+					long_count = stack[--stack_ptr];
+
+					if (long_index > long_temp)
+					{
+						reverse = 1;
+						long_index = long_temp;
+					}
+				}
+
+#if PORT==DOS
+				if (((long_index & 0xFFFF0000) == 0) &&
+					((long_count & 0xFFFF0000) == 0))
+				{
+					variable_id = (unsigned int) args[0];
+					if ((attributes[variable_id] & 0x1e) == 0x0e)
+					{
+						/* initialized compressed Boolean array */
+						jbi_uncompress_page(variable_id,
+							(int) (long_index >> 16), version);
+						long_index &= 0x0000ffff;
+						charptr_temp = jbi_aca_out_buffer;
+					}
+					else
+					{
+						charptr_temp = (unsigned char *) variables[variable_id];
+					}
+
+					if (reverse)
+					{
+						/* allocate a buffer and reverse the data order */
+						charptr_temp2 = charptr_temp;
+						charptr_temp = jbi_malloc((unsigned int)
+							((long_count >> 3L) + 1L));
+
+						if (charptr_temp == NULL)
+						{
+							status = JBIC_OUT_OF_MEMORY;
+							break;
+						}
+						else
+						{
+							long_temp = long_index + long_count - 1;
+							long_index2 = 0;
+							while (long_index2 < long_count)
+							{
+								if (charptr_temp2[long_temp >> 3] &
+									(1 << (long_temp & 7)))
+								{
+									charptr_temp[long_index2 >> 3] |=
+										(1 << (long_index2 & 7));
+								}
+								else
+								{
+									charptr_temp[long_index2 >> 3] &=
+										~(1 << (long_index2 & 7));
+								}
+
+								--long_temp;
+								++long_index2;
+							}
+						}
+					}
+
+					if (opcode == 0x51)	/* DS */
+					{
+						status = jbi_do_drscan((unsigned int) long_count,
+							charptr_temp, (unsigned long) long_index);
+					}
+					else	/* IS */
+					{
+						status = jbi_do_irscan((unsigned int) long_count,
+							charptr_temp, (unsigned int) long_index);
+					}
+
+					if (reverse) jbi_free(charptr_temp);
+				}
+				else if ((opcode == 0x51) && !reverse)
+				{
+					status = jbi_do_drscan_multi_page(
+						(unsigned int) args[0],
+						(unsigned long) long_count,
+						(unsigned long) long_index, version);
+				}
+				else
+				{
+					/* reverse multi-page scans are not supported */
+					/* multi-page IR scans are not supported */
+					status = JBIC_BOUNDS_ERROR;
+				}
+#else
+				charptr_temp = (unsigned char *) variables[args[0]];
+
+				if (reverse)
+				{
+					/* allocate a buffer and reverse the data order */
+					charptr_temp2 = charptr_temp;
+					charptr_temp = jbi_malloc((long_count >> 3) + 1);
+					if (charptr_temp == NULL)
+					{
+						status = JBIC_OUT_OF_MEMORY;
+						break;
+					}
+					else
+					{
+						long_temp = long_index + long_count - 1;
+						long_index2 = 0;
+						while (long_index2 < long_count)
+						{
+							if (charptr_temp2[long_temp >> 3] &
+								(1 << (long_temp & 7)))
+							{
+								charptr_temp[long_index2 >> 3] |=
+									(1 << (long_index2 & 7));
+							}
+							else
+							{
+								charptr_temp[long_index2 >> 3] &=
+									~(1 << (long_index2 & 7));
+							}
+
+							--long_temp;
+							++long_index2;
+						}
+					}
+				}
+
+				if (opcode == 0x51)	/* DS */
+				{
+					status = jbi_do_drscan((unsigned int) long_count,
+						charptr_temp, (unsigned long) long_index);
+				}
+				else	/* IS */
+				{
+					status = jbi_do_irscan((unsigned int) long_count,
+						charptr_temp, (unsigned int) long_index);
+				}
+#endif
+
+				if (reverse && (charptr_temp != NULL))
+				{
+					jbi_free(charptr_temp);
+				}
+			}
+			break;
+
+		case 0x53: /* DPRA */
+			/*
+			*	DRPRE with array data
+			*	...argument 0 is variable ID
+			*	...stack 0 is array index
+			*	...stack 1 is count
+			*/
+			IF_CHECK_STACK(2)
+			{
+				index = (unsigned int) stack[--stack_ptr];
+				count = (unsigned int) stack[--stack_ptr];
+
+				if (version > 0)
+				{
+					/* stack 0 = array right index */
+					/* stack 1 = array left index */
+					count = 1 + count - index;
+				}
+
+				charptr_temp = (unsigned char *) variables[args[0]];
+				status = jbi_set_dr_preamble(count, index, charptr_temp);
+			}
+			break;
+
+		case 0x54: /* DPOA */
+			/*
+			*	DRPOST with array data
+			*	...argument 0 is variable ID
+			*	...stack 0 is array index
+			*	...stack 1 is count
+			*/
+			IF_CHECK_STACK(2)
+			{
+				index = (unsigned int) stack[--stack_ptr];
+				count = (unsigned int) stack[--stack_ptr];
+
+				if (version > 0)
+				{
+					/* stack 0 = array right index */
+					/* stack 1 = array left index */
+					count = 1 + count - index;
+				}
+
+				charptr_temp = (unsigned char *) variables[args[0]];
+				status = jbi_set_dr_postamble(count, index, charptr_temp);
+			}
+			break;
+
+		case 0x55: /* IPRA */
+			/*
+			*	IRPRE with array data
+			*	...argument 0 is variable ID
+			*	...stack 0 is array index
+			*	...stack 1 is count
+			*/
+			IF_CHECK_STACK(2)
+			{
+				index = (unsigned int) stack[--stack_ptr];
+				count = (unsigned int) stack[--stack_ptr];
+
+				if (version > 0)
+				{
+					/* stack 0 = array right index */
+					/* stack 1 = array left index */
+					count = 1 + count - index;
+				}
+
+				charptr_temp = (unsigned char *) variables[args[0]];
+				status = jbi_set_ir_preamble(count, index, charptr_temp);
+			}
+			break;
+
+		case 0x56: /* IPOA */
+			/*
+			*	IRPOST with array data
+			*	...argument 0 is variable ID
+			*	...stack 0 is array index
+			*	...stack 1 is count
+			*/
+			IF_CHECK_STACK(2)
+			{
+				index = (unsigned int) stack[--stack_ptr];
+				count = (unsigned int) stack[--stack_ptr];
+
+				if (version > 0)
+				{
+					/* stack 0 = array right index */
+					/* stack 1 = array left index */
+					count = 1 + count - index;
+				}
+
+				charptr_temp = (unsigned char *) variables[args[0]];
+				status = jbi_set_ir_postamble(count, index, charptr_temp);
+			}
+			break;
+
+		case 0x57: /* EXPT */
+			/*
+			*	EXPORT
+			*	...argument 0 is string ID
+			*	...stack 0 is integer expression
+			*/
+			IF_CHECK_STACK(1)
+			{
+#if PORT==DOS
+				name_id = args[0];
+				for (j = 0; j < 32; ++j)
+				{
+					name[j] = GET_BYTE(string_table + name_id + j);
+				}
+				name[32] = '\0';
+#else
+				name = (char *) &program[string_table + args[0]];
+#endif
+				long_temp = stack[--stack_ptr];
+				jbi_export_integer(name, long_temp);
+			}
+			break;
+
+		case 0x58: /* PSHE */
+			/*
+			*	Push integer array element
+			*	...argument 0 is variable ID
+			*	...stack 0 is array index
+			*/
+			IF_CHECK_STACK(1)
+			{
+				variable_id = (unsigned int) args[0];
+				index = (unsigned int) stack[stack_ptr - 1];
+
+				/* check variable type */
+				if ((attributes[variable_id] & 0x1f) == 0x19)
+				{
+					/* writable integer array */
+					longptr_temp = (long *) variables[variable_id];
+					stack[stack_ptr - 1] = longptr_temp[index];
+				}
+				else if ((attributes[variable_id] & 0x1f) == 0x1c)
+				{
+					/* read-only integer array */
+					long_temp = variables[variable_id] + (4L * index);
+					stack[stack_ptr - 1] = GET_DWORD(long_temp);
+				}
+				else
+				{
+					status = JBIC_BOUNDS_ERROR;
+				}
+			}
+			break;
+
+		case 0x59: /* PSHA */
+			/*
+			*	Push Boolean array
+			*	...argument 0 is variable ID
+			*	...stack 0 is count
+			*	...stack 1 is array index
+			*/
+			IF_CHECK_STACK(2)
+			{
+				variable_id = (unsigned int) args[0];
+
+				/* check that variable is a Boolean array */
+				if ((attributes[variable_id] & 0x18) != 0x08)
+				{
+					status = JBIC_BOUNDS_ERROR;
+				}
+				else
+				{
+					charptr_temp = (unsigned char *) variables[variable_id];
+
+					/* pop the count (number of bits to copy) */
+					count = (unsigned int) stack[--stack_ptr];
+
+					/* pop the array index */
+					index = (unsigned int) stack[stack_ptr - 1];
+
+					if (version > 0)
+					{
+						/* stack 0 = array right index */
+						/* stack 1 = array left index */
+						count = 1 + count - index;
+					}
+
+					if ((count < 1) || (count > 32))
+					{
+						status = JBIC_BOUNDS_ERROR;
+					}
+					else
+					{
+#if PORT==DOS
+						if ((attributes[variable_id] & 0x1e) == 0x0e)
+						{
+							/* initialized compressed Boolean array */
+							jbi_uncompress_page(variable_id,
+								(int) (stack[stack_ptr - 1] >> 16), version);
+							charptr_temp = jbi_aca_out_buffer;
+						}
+#endif
+						long_temp = 0L;
+
+						for (i = 0; i < count; ++i)
+						{
+							if (charptr_temp[(i + index) >> 3] &
+								(1 << ((i + index) & 7)))
+							{
+								long_temp |= (1L << i);
+							}
+						}
+
+						stack[stack_ptr - 1] = long_temp;
+					}
+				}
+			}
+			break;
+
+		case 0x5A: /* DYNA */
+			/*
+			*	Dynamically change size of array
+			*	...argument 0 is variable ID
+			*	...stack 0 is new size
+			*/
+			IF_CHECK_STACK(1)
+			{
+				variable_id = (unsigned int) args[0];
+				long_temp = stack[--stack_ptr];
+
+				if (long_temp > variable_size[variable_id])
+				{
+					variable_size[variable_id] = long_temp;
+
+					if (attributes[variable_id] & 0x10)
+					{
+						/* allocate integer array */
+						long_temp *= 4;
+					}
+					else
+					{
+						/* allocate Boolean array */
+						long_temp = (long_temp + 7) >> 3;
+					}
+
+					/*
+					*	If the buffer was previously allocated, free it
+					*/
+					if ((attributes[variable_id] & 0x80) &&
+						(variables[variable_id] != NULL))
+					{
+						jbi_free((void *) variables[variable_id]);
+						variables[variable_id] = NULL;
+					}
+
+					/*
+					*	Allocate a new buffer of the requested size
+					*/
+					variables[variable_id] = (long)
+						jbi_malloc((unsigned int) long_temp);
+
+					if (variables[variable_id] == NULL)
+					{
+						status = JBIC_OUT_OF_MEMORY;
+					}
+					else
+					{
+						/*
+						*	Set the attribute bit to indicate that this buffer
+						*	was dynamically allocated and should be freed later
+						*/
+						attributes[variable_id] |= 0x80;
+
+						/* zero out memory */
+						count = (unsigned int)
+							((variable_size[variable_id] + 7L) / 8L);
+						charptr_temp = (unsigned char *)
+							(variables[variable_id]);
+						for (index = 0; index < count; ++index)
+						{
+							charptr_temp[index] = 0;
+						}
+					}
+				}
+			}
+			break;
+
+		case 0x5B: /* EXPR */
+			bad_opcode = 1;
+			break;
+
+		case 0x5C: /* EXPV */
+			/*
+			*	Export Boolean array
+			*	...argument 0 is string ID
+			*	...stack 0 is variable ID
+			*	...stack 1 is array right index
+			*	...stack 2 is array left index
+			*/
+			IF_CHECK_STACK(3)
+			{
+				if (version == 0)
+				{
+					/* EXPV is not supported in JBC 1.0 */
+					bad_opcode = 1;
+					break;
+				}
+#if PORT==DOS
+				name_id = args[0];
+				for (j = 0; j < 32; ++j)
+				{
+					name[j] = GET_BYTE(string_table + name_id + j);
+				}
+				name[32] = '\0';
+#else
+				name = (char *) &program[string_table + args[0]];
+#endif
+				variable_id = (unsigned int) stack[--stack_ptr];
+				long_index = stack[--stack_ptr];	/* right index */
+				long_index2 = stack[--stack_ptr];	/* left index */
+
+				if (long_index > long_index2)
+				{
+					/* reverse indices not supported */
+					status = JBIC_BOUNDS_ERROR;
+					break;
+				}
+
+				long_count = 1 + long_index2 - long_index;
+
+				charptr_temp = (unsigned char *) variables[variable_id];
+				charptr_temp2 = NULL;
+
+#if PORT==DOS
+				if ((attributes[variable_id] & 0x1e) == 0x0e)
+				{
+					/* initialized compressed Boolean array */
+					jbi_uncompress_page(variable_id,
+						(int) (long_index >> 16), version);
+					charptr_temp = jbi_aca_out_buffer;
+					long_index &= 0x0000FFFF;
+				}
+#endif
+
+				if ((long_index & 7L) != 0)
+				{
+					charptr_temp2 = jbi_malloc((unsigned int)
+						((long_count + 7L) / 8L));
+					if (charptr_temp2 == NULL)
+					{
+						status = JBIC_OUT_OF_MEMORY;
+						break;
+					}
+					else
+					{
+						long k = long_index;
+						for (i = 0; i < (unsigned int) long_count; ++i)
+						{
+							if (charptr_temp[k >> 3] & (1 << (k & 7)))
+							{
+								charptr_temp2[i >> 3] |= (1 << (i & 7));
+							}
+							else
+							{
+								charptr_temp2[i >> 3] &= ~(1 << (i & 7));
+							}
+
+							++k;
+						}
+						charptr_temp = charptr_temp2;
+					}
+				}
+				else if (long_index != 0)
+				{
+					charptr_temp = &charptr_temp[long_index >> 3];
+				}
+
+				jbi_export_boolean_array(name, charptr_temp, long_count);
+
+				/* free allocated buffer */
+				if (((long_index & 7L) != 0) && (charptr_temp2 != NULL))
+				{
+					jbi_free(charptr_temp2);
+				}
+			}
+			break;
+
+		case 0x80: /* COPY */
+			/*
+			*	Array copy
+			*	...argument 0 is dest ID
+			*	...argument 1 is source ID
+			*	...stack 0 is count
+			*	...stack 1 is dest index
+			*	...stack 2 is source index
+			*/
+			IF_CHECK_STACK(3)
+			{
+				long copy_count = stack[--stack_ptr];
+				long copy_index = stack[--stack_ptr];
+				long copy_index2 = stack[--stack_ptr];
+				long destleft;
+				long src_count;
+				long dest_count;
+				int src_reverse = 0;
+				int dest_reverse = 0;
+
+				reverse = 0;
+
+				if (version > 0)
+				{
+					/* stack 0 = source right index */
+					/* stack 1 = source left index */
+					/* stack 2 = destination right index */
+					/* stack 3 = destination left index */
+					destleft = stack[--stack_ptr];
+
+					if (copy_count > copy_index)
+					{
+						src_reverse = 1;
+						reverse = 1;
+						src_count = 1 + copy_count - copy_index;
+						/* copy_index = source start index */
+					}
+					else
+					{
+						src_count = 1 + copy_index - copy_count;
+						copy_index = copy_count;	/* source start index */
+					}
+
+					if (copy_index2 > destleft)
+					{
+						dest_reverse = 1;
+						reverse = !reverse;
+						dest_count = 1 + copy_index2 - destleft;
+						copy_index2 = destleft;	/* destination start index */
+					}
+					else
+					{
+						dest_count = 1 + destleft - copy_index2;
+						/* copy_index2 = destination start index */
+					}
+
+					copy_count = (src_count < dest_count) ? src_count : dest_count;
+
+					if ((src_reverse || dest_reverse) &&
+						(src_count != dest_count))
+					{
+						/* If either the source or destination is reversed, */
+						/* we can't tolerate a length mismatch, because we  */
+						/* "left justify" the arrays when copying.  This    */
+						/* won't work correctly with reversed arrays.       */
+						status = JBIC_BOUNDS_ERROR;
+					}
+				}
+
+				count = (unsigned int) copy_count;
+				index = (unsigned int) copy_index;
+				index2 = (unsigned int) copy_index2;
+
+				/*
+				*	If destination is a read-only array, allocate a buffer
+				*	and convert it to a writable array
+				*/
+				variable_id = (unsigned int) args[1];
+				if ((version > 0) && ((attributes[variable_id] & 0x9c) == 0x0c))
+				{
+					/*
+					*	Allocate a writable buffer for this array
+					*/
+					long_temp = (variable_size[variable_id] + 7L) >> 3L;
+					charptr_temp2 = (unsigned char *) variables[variable_id];
+					charptr_temp = jbi_malloc((unsigned int) long_temp);
+					variables[variable_id] = (long) charptr_temp;
+
+					if (variables[variable_id] == NULL)
+					{
+						status = JBIC_OUT_OF_MEMORY;
+						break;
+					}
+					else
+					{
+						/* zero the buffer */
+						for (long_index = 0L;
+							long_index < long_temp;
+							++long_index)
+						{
+							charptr_temp[long_index] = 0;
+						}
+
+						/* copy previous contents into buffer */
+						for (long_index = 0L;
+							long_index < variable_size[variable_id];
+							++long_index)
+						{
+#if PORT==DOS
+							if ((attributes[variable_id] & 0x02) &&
+								((long_index & 0x0000FFFF) == 0L))
+							{
+								/* initialized compressed Boolean array */
+								jbi_uncompress_page(variable_id,
+									(int) (long_index >> 16), version);
+								charptr_temp = jbi_aca_out_buffer;
+								long_index2 = long_index & 0xFFFF;
+							}
+#else
+							long_index2 = long_index;
+#endif
+
+							if (charptr_temp2[long_index2 >> 3] &
+								(1 << (long_index2 & 7)))
+							{
+								charptr_temp[long_index >> 3] |=
+									(1 << (long_index & 7));
+							}
+						}
+
+						/* set bit 7 - buffer was dynamically allocated */
+						attributes[variable_id] |= 0x80;
+
+						/* clear bit 2 - variable is writable */
+						attributes[variable_id] &= ~0x04;
+						attributes[variable_id] |= 0x01;
+					}
+				}
+
+#if PORT==DOS
+				/* for 16-bit version, allow writing in allocated buffers */
+				if ((version > 0) &&
+					((attributes[variable_id] & 0x9c) == 0x8c))
+				{
+					attributes[variable_id] &= ~0x04;
+					attributes[variable_id] |= 0x01;
+				}
+#endif
+
+				charptr_temp = (unsigned char *) variables[args[1]];
+				charptr_temp2 = (unsigned char *) variables[args[0]];
+
+#if PORT==DOS
+				variable_id = (unsigned int) args[0];
+				if ((attributes[variable_id] & 0x1e) == 0x0e)
+				{
+					/* initialized compressed Boolean array */
+					jbi_uncompress_page(variable_id,
+						(int) (copy_index >> 16), version);
+					charptr_temp2 = jbi_aca_out_buffer;
+				}
+#endif
+
+				/* check that destination is a writable Boolean array */
+				if ((attributes[args[1]] & 0x1c) != 0x08)
+				{
+					status = JBIC_BOUNDS_ERROR;
+					break;
+				}
+
+				if (count < 1)
+				{
+					status = JBIC_BOUNDS_ERROR;
+				}
+				else
+				{
+					if (reverse)
+					{
+						index2 += (count - 1);
+					}
+
+					for (i = 0; i < count; ++i)
+					{
+						if (charptr_temp2[index >> 3] & (1 << (index & 7)))
+						{
+							charptr_temp[index2 >> 3] |= (1 << (index2 & 7));
+						}
+						else
+						{
+							charptr_temp[index2 >> 3] &=
+								~(unsigned int) (1 << (index2 & 7));
+						}
+						++index;
+						if (reverse) --index2; else ++index2;
+					}
+				}
+			}
+			break;
+
+		case 0x81: /* REVA */
+			/*
+			*	ARRAY COPY reversing bit order
+			*	...argument 0 is dest ID
+			*	...argument 1 is source ID
+			*	...stack 0 is dest index
+			*	...stack 1 is source index
+			*	...stack 2 is count
+			*/
+			bad_opcode = 1;
+			break;
+
+		case 0x82: /* DSC  */
+		case 0x83: /* ISC  */
+			/*
+			*	DRSCAN with capture
+			*	IRSCAN with capture
+			*	...argument 0 is scan data variable ID
+			*	...argument 1 is capture variable ID
+			*	...stack 0 is capture index
+			*	...stack 1 is scan data index
+			*	...stack 2 is count
+			*/
+			IF_CHECK_STACK(3)
+			{
+				long scan_right, scan_left;
+				long capture_count = 0;
+				long scan_count = 0;
+				long capture_index = stack[--stack_ptr];
+				long scan_index = stack[--stack_ptr];
+				if (version > 0)
+				{
+					/* stack 0 = capture right index */
+					/* stack 1 = capture left index */
+					/* stack 2 = scan right index */
+					/* stack 3 = scan left index */
+					/* stack 4 = count */
+					scan_right = stack[--stack_ptr];
+					scan_left = stack[--stack_ptr];
+					capture_count = 1 + scan_index - capture_index;
+					scan_count = 1 + scan_left - scan_right;
+					scan_index = scan_right;
+				}
+				long_count = stack[--stack_ptr];
+
+				/*
+				*	If capture array is read-only, allocate a buffer
+				*	and convert it to a writable array
+				*/
+				variable_id = (unsigned int) args[1];
+				if ((version > 0) && ((attributes[variable_id] & 0x9c) == 0x0c))
+				{
+					/*
+					*	Allocate a writable buffer for this array
+					*/
+					long_temp = (variable_size[variable_id] + 7L) >> 3L;
+					charptr_temp2 = (unsigned char *) variables[variable_id];
+					charptr_temp = jbi_malloc((unsigned int) long_temp);
+					variables[variable_id] = (long) charptr_temp;
+
+					if (variables[variable_id] == NULL)
+					{
+						status = JBIC_OUT_OF_MEMORY;
+						break;
+					}
+					else
+					{
+						/* zero the buffer */
+						for (long_index = 0L;
+							long_index < long_temp;
+							++long_index)
+						{
+							charptr_temp[long_index] = 0;
+						}
+
+						/* copy previous contents into buffer */
+						for (long_index = 0L;
+							long_index < variable_size[variable_id];
+							++long_index)
+						{
+#if PORT==DOS
+							if ((attributes[variable_id] & 0x02) &&
+								((long_index & 0x0000FFFF) == 0L))
+							{
+								/* initialized compressed Boolean array */
+								jbi_uncompress_page(variable_id,
+									(int) (long_index >> 16), version);
+								charptr_temp = jbi_aca_out_buffer;
+								long_index2 = long_index & 0xFFFF;
+							}
+#else
+							long_index2 = long_index;
+#endif
+
+							if (charptr_temp2[long_index2 >> 3] &
+								(1 << (long_index2 & 7)))
+							{
+								charptr_temp[long_index >> 3] |=
+									(1 << (long_index & 7));
+							}
+						}
+
+						/* set bit 7 - buffer was dynamically allocated */
+						attributes[variable_id] |= 0x80;
+
+						/* clear bit 2 - variable is writable */
+						attributes[variable_id] &= ~0x04;
+						attributes[variable_id] |= 0x01;
+					}
+				}
+
+#if PORT==DOS
+				/* for 16-bit version, allow writing in allocated buffers */
+				if ((version > 0) &&
+					((attributes[variable_id] & 0x9c) == 0x8c))
+				{
+					attributes[variable_id] &= ~0x04;
+					attributes[variable_id] |= 0x01;
+				}
+#endif
+
+				charptr_temp = (unsigned char *) variables[args[0]];
+				charptr_temp2 = (unsigned char *) variables[args[1]];
+
+#if PORT==DOS
+				variable_id = (unsigned int) args[0];
+				if ((attributes[variable_id] & 0x1e) == 0x0e)
+				{
+					/* initialized compressed Boolean array */
+					jbi_uncompress_page(variable_id,
+						(int) (scan_index >> 16), version);
+					scan_index &= 0x0000ffff;
+					charptr_temp = jbi_aca_out_buffer;
+				}
+#endif
+
+				if ((version > 0) &&
+					((long_count > capture_count) || (long_count > scan_count)))
+				{
+					status = JBIC_BOUNDS_ERROR;
+				}
+
+				/* check that capture array is a writable Boolean array */
+				if ((attributes[args[1]] & 0x1c) != 0x08)
+				{
+					status = JBIC_BOUNDS_ERROR;
+				}
+
+				if (status == JBIC_SUCCESS)
+				{
+					if (opcode == 0x82) /* DSC */
+					{
+						status = jbi_swap_dr((unsigned int) long_count,
+							charptr_temp, (unsigned long) scan_index,
+							charptr_temp2, (unsigned int) capture_index);
+					}
+					else /* ISC */
+					{
+						status = jbi_swap_ir((unsigned int) long_count,
+							charptr_temp, (unsigned int) scan_index,
+							charptr_temp2, (unsigned int) capture_index);
+					}
+				}
+			}
+			break;
+
+		case 0x84: /* WAIT */
+			/*
+			*	WAIT
+			*	...argument 0 is wait state
+			*	...argument 1 is end state
+			*	...stack 0 is cycles
+			*	...stack 1 is microseconds
+			*/
+			IF_CHECK_STACK(2)
+			{
+				long_temp = stack[--stack_ptr];
+
+				if (long_temp != 0L)
+				{
+					status = jbi_do_wait_cycles(long_temp, (unsigned int) args[0]);
+				}
+
+				long_temp = stack[--stack_ptr];
+
+				if ((status == JBIC_SUCCESS) && (long_temp != 0L))
+				{
+					status = jbi_do_wait_microseconds(long_temp, (unsigned int) args[0]);
+				}
+
+				if ((status == JBIC_SUCCESS) && (args[1] != args[0]))
+				{
+					status = jbi_goto_jtag_state((unsigned int) args[1]);
+				}
+
+				if (version > 0)
+				{
+					--stack_ptr;	/* throw away MAX cycles */
+					--stack_ptr;	/* throw away MAX microseconds */
+				}
+			}
+			break;
+
+		case 0x85: /* VS   */
+			/*
+			*	VECTOR
+			*	...argument 0 is dir data variable ID
+			*	...argument 1 is scan data variable ID
+			*	...stack 0 is dir array index
+			*	...stack 1 is scan array index
+			*	...stack 2 is count
+			*/
+			bad_opcode = 1;
+			break;
+
+		case 0xC0: /* CMPA */
+			/*
+			*	Array compare
+			*	...argument 0 is source 1 ID
+			*	...argument 1 is source 2 ID
+			*	...argument 2 is mask ID
+			*	...stack 0 is source 1 index
+			*	...stack 1 is source 2 index
+			*	...stack 2 is mask index
+			*	...stack 3 is count
+			*/
+			IF_CHECK_STACK(4)
+			{
+				long a, b;
+				unsigned char *source1 = (unsigned char *) variables[args[0]];
+				unsigned char *source2 = (unsigned char *) variables[args[1]];
+				unsigned char *mask    = (unsigned char *) variables[args[2]];
+				unsigned long index1 = stack[--stack_ptr];
+				unsigned long index2 = stack[--stack_ptr];
+				unsigned long mask_index = stack[--stack_ptr];
+				long_count = stack[--stack_ptr];
+
+				if (version > 0)
+				{
+					/* stack 0 = source 1 right index */
+					/* stack 1 = source 1 left index */
+					/* stack 2 = source 2 right index */
+					/* stack 3 = source 2 left index */
+					/* stack 4 = mask right index */
+					/* stack 5 = mask left index */
+					long mask_right = stack[--stack_ptr];
+					long mask_left = stack[--stack_ptr];
+					a = 1 + index2 - index1; /* source 1 count */
+					b = 1 + long_count - mask_index; /* source 2 count */
+					a = (a < b) ? a : b;
+					b = 1 + mask_left - mask_right; /* mask count */
+					a = (a < b) ? a : b;
+					index2 = mask_index;	/* source 2 start index */
+					mask_index = mask_right;	/* mask start index */
+					long_count = a;
+				}
+
+				long_temp = 1L;
+
+				if (long_count < 1)
+				{
+					status = JBIC_BOUNDS_ERROR;
+				}
+				else
+				{
+#if PORT==DOS
+					variable_id = (unsigned int) args[0];
+					if ((attributes[variable_id] & 0x1e) == 0x0e)
+					{
+						jbi_uncompress_page(variable_id,
+							(int) (index1 >> 16), version);
+						index1 &= 0x0000ffff;
+						source1 = jbi_aca_out_buffer;
+					}
+
+					variable_id = (unsigned int) args[1];
+					if ((attributes[variable_id] & 0x1e) == 0x0e)
+					{
+						jbi_uncompress_page(variable_id,
+							(int) (index2 >> 16), version);
+						index2 &= 0x0000ffff;
+						source2 = jbi_aca_out_buffer;
+					}
+#endif
+					count = (unsigned int) long_count;
+
+					for (i = 0; i < count; ++i)
+					{
+						if (mask[mask_index >> 3] & (1 << (mask_index & 7)))
+						{
+							a = source1[index1 >> 3] & (1 << (index1 & 7))
+								? 1 : 0;
+							b = source2[index2 >> 3] & (1 << (index2 & 7))
+								? 1 : 0;
+
+							if (a != b) long_temp = 0L;	/* failure */
+						}
+						++index1;
+						++index2;
+						++mask_index;
+					}
+				}
+
+				stack[stack_ptr++] = long_temp;
+			}
+			break;
+
+		case 0xC1: /* VSC  */
+			/*
+			*	VECTOR with capture
+			*	...argument 0 is dir data variable ID
+			*	...argument 1 is scan data variable ID
+			*	...argument 2 is capture variable ID
+			*	...stack 0 is capture index
+			*	...stack 1 is scan data index
+			*	...stack 2 is dir data index
+			*	...stack 3 is count
+			*/
+			bad_opcode = 1;
+			break;
+
+		default:
+			/*
+			*	Unrecognized opcode -- ERROR!
+			*/
+			bad_opcode = 1;
+			break;
+		}
+
+		if (bad_opcode)
+		{
+			status = JBIC_ILLEGAL_OPCODE;
+		}
+
+		if ((stack_ptr < 0) || (stack_ptr >= JBI_STACK_SIZE))
+		{
+			status = JBIC_STACK_OVERFLOW;
+		}
+
+		if (status != JBIC_SUCCESS)
+		{
+			done = 1;
+			*error_address = (long) (opcode_address - code_section);
+		}
+	}
+
+	jbi_free_jtag_padding_buffers(reset_jtag);
+
+	/*
+	*	Free all dynamically allocated arrays
+	*/
+	if ((attributes != NULL) && (variables != NULL))
+	{
+		for (i = 0; i < (unsigned int) symbol_count; ++i)
+		{
+			if ((attributes[i] & 0x80) && (variables[i] != NULL))
+			{
+				jbi_free((void *) variables[i]);
+			}
+		}
+	}
+
+	if (variables != NULL) jbi_free(variables);
+
+	if (variable_size != NULL) jbi_free(variable_size);
+
+	if (attributes != NULL) jbi_free(attributes);
+
+	if (proc_attributes != NULL) jbi_free(proc_attributes);
+
+	return (status);
+}
+
+/****************************************************************************/
+/*																			*/
+
+JBI_RETURN_TYPE jbi_get_note
+(
+	PROGRAM_PTR program,
+	long program_size,
+	long *offset,
+	char *key,
+	char *value,
+	int length
+)
+
+/*																			*/
+/*	Description:	Gets key and value of NOTE fields in the JBC file.		*/
+/*					Can be called in two modes:  if offset pointer is NULL,	*/
+/*					then the function searches for note fields which match 	*/
+/*					the key string provided.  If offset is not NULL, then	*/
+/*					the function finds the next note field of any key,		*/
+/*					starting at the offset specified by the offset pointer.	*/
+/*																			*/
+/*	Returns:		JBIC_SUCCESS for success, else appropriate error code	*/
+/*																			*/
+/****************************************************************************/
+{
+	JBI_RETURN_TYPE status = JBIC_UNEXPECTED_END;
+	unsigned long note_strings = 0L;
+	unsigned long note_table = 0L;
+	unsigned long note_count = 0L;
+	unsigned long first_word = 0L;
+	int version = 0;
+	int delta = 0;
+	char *key_ptr;
+	char *value_ptr;
+	int i;
+
+#if PORT==DOS
+	int count = 0;
+	int done = 0;
+	long long_index = 0;
+	char key_buffer[256];
+	char value_buffer[256];
+
+	jbi_program = program;
+#endif
+
+	/*
+	*	Read header information
+	*/
+	if (program_size > 52L)
+	{
+		first_word    = GET_DWORD(0);
+		version = (int) (first_word & 1L);
+		delta = version * 8;
+
+		note_strings  = GET_DWORD(8 + delta);
+		note_table    = GET_DWORD(12 + delta);
+		note_count    = GET_DWORD(44 + (2 * delta));
+	}
+
+	if ((first_word != 0x4A414D00L) && (first_word != 0x4A414D01L))
+	{
+		status = JBIC_IO_ERROR;
+	}
+	else if (note_count > 0L)
+	{
+		if (offset == NULL)
+		{
+			/*
+			*	We will search for the first note with a specific key, and
+			*	return only the value
+			*/
+			for (i = 0; (i < (int) note_count) && (status != JBIC_SUCCESS); ++i)
+			{
+#if PORT==DOS
+				done = 0;
+				count = 0;
+				long_index = note_strings + GET_DWORD(note_table + (8 * i));
+				while ((count < 255) && !done)
+				{
+					key_buffer[count] = GET_BYTE(long_index);
+					if (key_buffer[count] == '\0') done = 1;
+					++long_index;
+					++count;
+				}
+				key_buffer[255] = '\0';
+				key_ptr = key_buffer;
+#else
+				key_ptr = (char *) &program[note_strings +
+					GET_DWORD(note_table + (8 * i))];
+#endif
+				if ((key != NULL) && (jbi_stricmp(key, key_ptr) == 0))
+				{
+					status = JBIC_SUCCESS;
+
+#if PORT==DOS
+					done = 0;
+					count = 0;
+					long_index = note_strings + GET_DWORD(note_table + (8 * i) + 4);
+					while ((count < 255) && !done)
+					{
+						value_buffer[count] = GET_BYTE(long_index);
+						if (value_buffer[count] == '\0') done = 1;
+						++long_index;
+						++count;
+					}
+					value_buffer[255] = '\0';
+					value_ptr = value_buffer;
+#else
+					value_ptr = (char *) &program[note_strings +
+						GET_DWORD(note_table + (8 * i) + 4)];
+#endif
+
+					if (value != NULL)
+					{
+						jbi_strncpy(value, value_ptr, length);
+					}
+				}
+			}
+		}
+		else
+		{
+			/*
+			*	We will search for the next note, regardless of the key, and
+			*	return both the value and the key
+			*/
+
+			i = (int) *offset;
+
+			if ((i >= 0) && (i < (int) note_count))
+			{
+				status = JBIC_SUCCESS;
+
+				if (key != NULL)
+				{
+#if PORT==DOS
+					done = 0;
+					count = 0;
+					long_index = note_strings +
+						GET_DWORD(note_table + (8 * i));
+
+					while ((count < length) && !done)
+					{
+						key[count] = GET_BYTE(long_index);
+						if (key[count] == '\0') done = 1;
+						++long_index;
+						++count;
+					}
+#else
+					jbi_strncpy(key, (char *) &program[note_strings +
+						GET_DWORD(note_table + (8 * i))], length);
+#endif
+				}
+
+				if (value != NULL)
+				{
+#if PORT==DOS
+					done = 0;
+					count = 0;
+					long_index = note_strings +
+						GET_DWORD(note_table + (8 * i) + 4);
+
+					while ((count < length) && !done)
+					{
+						value[count] = GET_BYTE(long_index);
+						if (value[count] == '\0') done = 1;
+						++long_index;
+						++count;
+					}
+#else
+					jbi_strncpy(value, (char *) &program[note_strings +
+						GET_DWORD(note_table + (8 * i) + 4)], length);
+#endif
+				}
+
+				*offset = i + 1;
+			}
+		}
+	}
+
+	return (status);
+}
+
+/****************************************************************************/
+/*																			*/
+
+JBI_RETURN_TYPE jbi_check_crc
+(
+	PROGRAM_PTR program,
+	long program_size,
+	unsigned short *expected_crc,
+	unsigned short *actual_crc
+)
+
+/*																			*/
+/*	Description:	This function reads the entire input file and computes	*/
+/*					the CRC of everything up to the CRC field.				*/
+/*																			*/
+/*	Returns:		JBIC_SUCCESS for success, JBIC_CRC_ERROR for failure	*/
+/*																			*/
+/****************************************************************************/
+{
+	JBI_RETURN_TYPE status = JBIC_SUCCESS;
+	unsigned short local_expected, local_actual, shift_reg = 0xffff;
+	int bit, feedback;
+	unsigned char databyte;
+	unsigned long i;
+	unsigned long crc_section = 0L;
+	unsigned long first_word = 0L;
+	int version = 0;
+	int delta = 0;
+
+#if PORT==DOS
+	jbi_program = program;
+#endif
+
+	if (program_size > 52L)
+	{
+		first_word  = GET_DWORD(0);
+		version = (int) (first_word & 1L);
+		delta = version * 8;
+
+		crc_section = GET_DWORD(32 + delta);
+	}
+
+	if ((first_word != 0x4A414D00L) && (first_word != 0x4A414D01L))
+	{
+		status = JBIC_IO_ERROR;
+	}
+
+	if (crc_section >= (unsigned long) program_size)
+	{
+		status = JBIC_IO_ERROR;
+	}
+
+	if (status == JBIC_SUCCESS)
+	{
+		local_expected = (unsigned short) GET_WORD(crc_section);
+		if (expected_crc != NULL) *expected_crc = local_expected;
+
+		for (i = 0; i < crc_section; ++i)
+		{
+			databyte = GET_BYTE(i);
+			for (bit = 0; bit < 8; bit++)	/* compute for each bit */
+			{
+				feedback = (databyte ^ shift_reg) & 0x01;
+				shift_reg >>= 1;	/* shift the shift register */
+				if (feedback) shift_reg ^= 0x8408;	/* invert selected bits */
+				databyte >>= 1;		/* get the next bit of input_byte */
+			}
+		}
+
+		local_actual = (unsigned short) ~shift_reg;
+		if (actual_crc != NULL) *actual_crc = local_actual;
+
+		if (local_expected != local_actual)
+		{
+			status = JBIC_CRC_ERROR;
+		}
+	}
+
+	return (status);
+}
+
+JBI_RETURN_TYPE jbi_get_file_info
+(
+	PROGRAM_PTR program,
+	long program_size,
+	int *format_version,
+	int *action_count,
+	int *procedure_count
+)
+{
+	JBI_RETURN_TYPE status = JBIC_IO_ERROR;
+	unsigned long first_word = 0;
+	int version = 0;
+
+#if PORT==DOS
+	jbi_program = program;
+#endif
+
+	/*
+	*	Read header information
+	*/
+	if (program_size > 52L)
+	{
+		first_word = GET_DWORD(0);
+
+		if ((first_word == 0x4A414D00L) || (first_word == 0x4A414D01L))
+		{
+			status = JBIC_SUCCESS;
+
+			version = (int) (first_word & 1L);
+			*format_version = version + 1;
+
+			if (version > 0)
+			{
+				*action_count = (int) GET_DWORD(48);
+				*procedure_count = (int) GET_DWORD(52);
+			}
+		}
+
+	}
+
+	return (status);
+}
+
+JBI_RETURN_TYPE jbi_get_action_info
+(
+	PROGRAM_PTR program,
+	long program_size,
+	int index,
+	char **name,
+	char **description,
+	JBI_PROCINFO **procedure_list
+)
+{
+	JBI_RETURN_TYPE status = JBIC_IO_ERROR;
+	JBI_PROCINFO *procptr = NULL;
+	JBI_PROCINFO *tmpptr = NULL;
+	unsigned long first_word = 0L;
+	unsigned long action_table = 0L;
+	unsigned long proc_table = 0L;
+	unsigned long string_table = 0L;
+	unsigned long note_strings = 0L;
+	unsigned long action_count = 0L;
+	unsigned long proc_count = 0L;
+	unsigned long act_name_id = 0L;
+	unsigned long act_desc_id = 0L;
+	unsigned long act_proc_id = 0L;
+	unsigned long act_proc_name = 0L;
+	unsigned char act_proc_attribute = 0;
+
+#if PORT==DOS
+	int i, length;
+	jbi_program = program;
+#endif
+
+	/*
+	*	Read header information
+	*/
+	if (program_size > 52L)
+	{
+		first_word = GET_DWORD(0);
+
+		if (first_word == 0x4A414D01L)
+		{
+			action_table = GET_DWORD(4);
+			proc_table   = GET_DWORD(8);
+			string_table = GET_DWORD(12);
+			note_strings = GET_DWORD(16);
+			action_count = GET_DWORD(48);
+			proc_count   = GET_DWORD(52);
+
+			if (index < (int) action_count)
+			{
+				act_name_id = GET_DWORD(action_table + (12 * index));
+				act_desc_id = GET_DWORD(action_table + (12 * index) + 4);
+				act_proc_id = GET_DWORD(action_table + (12 * index) + 8);
+
+#if PORT==DOS
+				length = 0;
+				while (GET_BYTE(string_table + act_name_id + length) != 0) ++length;
+				*name = jbi_malloc(length + 1);
+				if (*name == NULL)
+				{
+					status = JBIC_OUT_OF_MEMORY;
+				}
+				else
+				{
+					for (i = 0; i < length; ++i)
+					{
+						(*name)[i] = GET_BYTE(string_table + act_name_id + i);
+					}
+					(*name)[length] = '\0';
+				}
+#else
+				*name = (char *) &program[string_table + act_name_id];
+#endif
+
+				if (act_desc_id < (note_strings - string_table))
+				{
+#if PORT==DOS
+					length = 0;
+					while (GET_BYTE(string_table + act_desc_id + length) != 0) ++length;
+					*description = jbi_malloc(length + 1);
+					if (*description == NULL)
+					{
+						status = JBIC_OUT_OF_MEMORY;
+					}
+					else
+					{
+						for (i = 0; i < length; ++i)
+						{
+							(*description)[i] = GET_BYTE(string_table + act_desc_id + i);
+						}
+						(*description)[length] = '\0';
+					}
+#else
+					*description = (char *) &program[string_table + act_desc_id];
+#endif
+				}
+
+				do
+				{
+					act_proc_name = GET_DWORD(proc_table + (13 * act_proc_id));
+					act_proc_attribute = (unsigned char)
+						(GET_BYTE(proc_table + (13 * act_proc_id) + 8) & 0x03);
+
+					procptr = (JBI_PROCINFO *) jbi_malloc(sizeof(JBI_PROCINFO));
+
+					if (procptr == NULL)
+					{
+						status = JBIC_OUT_OF_MEMORY;
+					}
+					else
+					{
+#if PORT==DOS
+						length = 0;
+						while (GET_BYTE(string_table + act_proc_name + length) != 0) ++length;
+						procptr->name = jbi_malloc(length + 1);
+						if (procptr->name == NULL)
+						{
+							status = JBIC_OUT_OF_MEMORY;
+						}
+						else
+						{
+							for (i = 0; i < length; ++i)
+							{
+								procptr->name[i] =
+									GET_BYTE(string_table + act_proc_name + i);
+							}
+							procptr->name[length] = '\0';
+						}
+#else
+						procptr->name = (char *)
+							&program[string_table + act_proc_name];
+#endif
+						procptr->attributes = act_proc_attribute;
+						procptr->next = NULL;
+
+						/* add record to end of linked list */
+						if (*procedure_list == NULL)
+						{
+							*procedure_list = procptr;
+						}
+						else
+						{
+							tmpptr = *procedure_list;
+							while (tmpptr->next != NULL) tmpptr = tmpptr->next;
+							tmpptr->next = procptr;
+						}
+					}
+
+					act_proc_id =
+						GET_DWORD(proc_table + (13 * act_proc_id) + 4);
+				}
+				while ((act_proc_id != 0) && (act_proc_id < proc_count));
+			}
+		}
+
+	}
+
+	return (status);
+}
diff --git a/drivers/cpld/altera/jbiport.h b/drivers/cpld/altera/jbiport.h
new file mode 100644
index 0000000..dc990b6
--- /dev/null
+++ b/drivers/cpld/altera/jbiport.h
@@ -0,0 +1,43 @@
+/****************************************************************************/
+/*                                                                          */
+/*  Module:        jbiport.h                                                */
+/*                                                                          */
+/*                 Copyright (C) Altera Corporation 2000-2001               */
+/*                                                                          */
+/*  Description:   Defines porting macros                                   */
+/*                                                                          */
+/****************************************************************************/
+
+#ifndef INC_JBIPORT_H
+#define INC_JBIPORT_H
+
+/*
+*  PORT defines the target platform: DOS, WINDOWS, UNIX, or EMBEDDED
+*
+*  PORT = DOS      means a 16-bit DOS console-mode application
+*
+*  PORT = WINDOWS  means a 32-bit WIN32 console-mode application for
+*                  Windows 95, 98, 2000, ME or NT.  On NT this will use the
+*                  DeviceIoControl() API to access the Parallel Port.
+*
+*  PORT = UNIX     means any UNIX system.  BitBlaster access is support via
+*                  the standard ANSI system calls open(), read(), write().
+*                  The ByteBlaster is not supported.
+*
+*  PORT = EMBEDDED means all DOS, WINDOWS, and UNIX code is excluded.
+*                  Remaining code supports 16 and 32-bit compilers.
+*                  Additional porting steps may be necessary. See readme
+*                  file for more details.
+*/
+
+#define DOS      2
+#define WINDOWS  3
+#define UNIX     4
+#define EMBEDDED 5
+
+#ifndef PORT
+/* change this line to build a different port */
+#define PORT UNIX
+#endif
+
+#endif /* INC_JBIPORT_H */
diff --git a/drivers/cpld/altera/jbistub.c b/drivers/cpld/altera/jbistub.c
new file mode 100644
index 0000000..de79fb5
--- /dev/null
+++ b/drivers/cpld/altera/jbistub.c
@@ -0,0 +1,2039 @@
+/****************************************************************************/
+/*																			*/
+/*	Module:			jbistub.c												*/
+/*																			*/
+/*					Copyright (C) Altera Corporation 1997-2001				*/
+/*																			*/
+/*	Description:	Jam STAPL ByteCode Player main source file				*/
+/*																			*/
+/*					Supports Altera ByteBlaster hardware download cable		*/
+/*					on Windows 95 and Windows NT operating systems.			*/
+/*					(A device driver is required for Windows NT.)			*/
+/*																			*/
+/*					Also supports BitBlaster hardware download cable on		*/
+/*					Windows 95, Windows NT, and UNIX platforms.				*/
+/*																			*/
+/*	Revisions:		1.1 fixed control port initialization for ByteBlaster	*/
+/*					2.0 added support for STAPL bytecode format, added code	*/
+/*						to get printer port address from Windows registry	*/
+/*					2.1 improved messages, fixed delay-calibration bug in	*/
+/*						16-bit DOS port, added support for "alternative		*/
+/*						cable X", added option to control whether to reset	*/
+/*						the TAP after execution, moved porting macros into	*/
+/*						jbiport.h											*/
+/*					2.2 added support for static memory						*/
+/*						fixed /W4 warnings									*/
+/*																			*/
+/****************************************************************************/
+
+#ifndef NO_ALTERA_STDIO
+#define NO_ALTERA_STDIO
+#endif
+
+#if ( _MSC_VER >= 800 )
+#pragma warning(disable:4115)
+#pragma warning(disable:4201)
+#pragma warning(disable:4214)
+#pragma warning(disable:4514)
+#endif
+
+#include "jbiport.h"
+
+#if PORT == WINDOWS
+#include <windows.h>
+#else
+typedef int BOOL;
+typedef unsigned char BYTE;
+typedef unsigned short WORD;
+typedef unsigned long DWORD;
+#define TRUE 1
+#define FALSE 0
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <io.h>
+#include <fcntl.h>
+#include <process.h>
+#if defined(USE_STATIC_MEMORY)
+	#define N_STATIC_MEMORY_KBYTES ((unsigned int) USE_STATIC_MEMORY)
+	#define N_STATIC_MEMORY_BYTES (N_STATIC_MEMORY_KBYTES * 1024)
+	#define POINTER_ALIGNMENT sizeof(DWORD)
+#else /* USE_STATIC_MEMORY */
+	#include <malloc.h>
+	#define POINTER_ALIGNMENT sizeof(BYTE)
+#endif /* USE_STATIC_MEMORY */
+#include <time.h>
+#include <conio.h>
+#include <ctype.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#if PORT == DOS
+#include <bios.h>
+#endif
+
+#include "jbiexprt.h"
+
+#if PORT == WINDOWS
+#define PGDC_IOCTL_GET_DEVICE_INFO_PP 0x00166A00L
+#define PGDC_IOCTL_READ_PORT_PP       0x00166A04L
+#define PGDC_IOCTL_WRITE_PORT_PP      0x0016AA08L
+#define PGDC_IOCTL_PROCESS_LIST_PP    0x0016AA1CL
+#define PGDC_READ_INFO                0x0a80
+#define PGDC_READ_PORT                0x0a81
+#define PGDC_WRITE_PORT               0x0a82
+#define PGDC_PROCESS_LIST             0x0a87
+#define PGDC_HDLC_NTDRIVER_VERSION    2
+#define PORT_IO_BUFFER_SIZE           256
+#endif
+
+#if PORT == WINDOWS
+#ifdef __BORLANDC__
+/* create dummy inp() and outp() functions for Borland 32-bit compile */
+WORD inp(WORD address) { address = address; return(0); }
+void outp(WORD address, WORD data) { address = address; data = data; }
+#else
+#pragma intrinsic (inp, outp)
+#endif
+#endif
+
+/*
+*	For Borland C compiler (16-bit), set the stack size
+*/
+#if PORT == DOS
+#ifdef __BORLANDC__
+extern unsigned int _stklen = 50000;
+#endif
+#endif
+
+/************************************************************************
+*
+*	Global variables
+*/
+
+/* file buffer for Jam STAPL ByteCode input file */
+#if PORT == DOS
+unsigned char **file_buffer = NULL;
+#else
+unsigned char *file_buffer = NULL;
+#endif
+long file_pointer = 0L;
+long file_length = 0L;
+
+/* delay count for one millisecond delay */
+long one_ms_delay = 0L;
+
+/* serial port interface available on all platforms */
+BOOL jtag_hardware_initialized = FALSE;
+char *serial_port_name = NULL;
+BOOL specified_com_port = FALSE;
+int com_port = -1;
+void initialize_jtag_hardware(void);
+void close_jtag_hardware(void);
+
+#if defined(USE_STATIC_MEMORY)
+	unsigned char static_memory_heap[N_STATIC_MEMORY_BYTES] = { 0 };
+#endif /* USE_STATIC_MEMORY */
+
+#if defined(USE_STATIC_MEMORY) || defined(MEM_TRACKER)
+	unsigned int n_bytes_allocated = 0;
+#endif /* USE_STATIC_MEMORY || MEM_TRACKER */
+
+#if defined(MEM_TRACKER)
+	unsigned int peak_memory_usage = 0;
+	unsigned int peak_allocations = 0;
+	unsigned int n_allocations = 0;
+#if defined(USE_STATIC_MEMORY)
+	unsigned int n_bytes_not_recovered = 0;
+#endif /* USE_STATIC_MEMORY */
+	const DWORD BEGIN_GUARD = 0x01234567;
+	const DWORD END_GUARD = 0x76543210;
+#endif /* MEM_TRACKER */
+
+#if PORT == WINDOWS || PORT == DOS
+/* parallel port interface available on PC only */
+BOOL specified_lpt_port = FALSE;
+BOOL specified_lpt_addr = FALSE;
+int lpt_port = 1;
+int initial_lpt_ctrl = 0;
+WORD lpt_addr = 0x3bc;
+WORD lpt_addr_table[3] = { 0x3bc, 0x378, 0x278 };
+BOOL alternative_cable_l = FALSE;
+BOOL alternative_cable_x = FALSE;
+void write_byteblaster(int port, int data);
+int read_byteblaster(int port);
+#endif
+
+#if PORT==WINDOWS
+#ifndef __BORLANDC__
+WORD lpt_addresses_from_registry[4] = { 0 };
+#endif
+#endif
+
+#if PORT == WINDOWS
+/* variables to manage cached I/O under Windows NT */
+BOOL windows_nt = FALSE;
+int port_io_count = 0;
+HANDLE nt_device_handle = INVALID_HANDLE_VALUE;
+struct PORT_IO_LIST_STRUCT
+{
+	USHORT command;
+	USHORT data;
+} port_io_buffer[PORT_IO_BUFFER_SIZE];
+extern void flush_ports(void);
+BOOL initialize_nt_driver(void);
+#endif
+
+/* function prototypes to allow forward reference */
+extern void delay_loop(long count);
+
+/*
+*	This structure stores information about each available vector signal
+*/
+struct VECTOR_LIST_STRUCT
+{
+	char *signal_name;
+	int  hardware_bit;
+	int  vector_index;
+};
+
+struct VECTOR_LIST_STRUCT vector_list[] =
+{
+	/* add a record here for each vector signal */
+	{ "", 0, -1 }
+};
+
+#define VECTOR_SIGNAL_COUNT ((int)(sizeof(vector_list)/sizeof(vector_list[0])))
+
+BOOL verbose = FALSE;
+
+/************************************************************************
+*
+*	Customized interface functions for Jam STAPL ByteCode Player I/O:
+*
+*	jbi_jtag_io()
+*	jbi_message()
+*	jbi_delay()
+*/
+
+int jbi_jtag_io(int tms, int tdi, int read_tdo)
+{
+	int data = 0;
+	int tdo = 0;
+	int i = 0;
+	int result = 0;
+	char ch_data = 0;
+
+	if (!jtag_hardware_initialized)
+	{
+		initialize_jtag_hardware();
+		jtag_hardware_initialized = TRUE;
+	}
+
+	if (specified_com_port)
+	{
+		ch_data = (char)
+			((tdi ? 0x01 : 0) | (tms ? 0x02 : 0) | 0x60);
+
+		write(com_port, &ch_data, 1);
+
+		if (read_tdo)
+		{
+			ch_data = 0x7e;
+			write(com_port, &ch_data, 1);
+			for (i = 0; (i < 100) && (result != 1); ++i)
+			{
+				result = read(com_port, &ch_data, 1);
+			}
+			if (result == 1)
+			{
+				tdo = ch_data & 0x01;
+			}
+			else
+			{
+				fprintf(stderr, "Error:  BitBlaster not responding\n");
+			}
+		}
+
+		ch_data = (char)
+			((tdi ? 0x01 : 0) | (tms ? 0x02 : 0) | 0x64);
+
+		write(com_port, &ch_data, 1);
+	}
+	else
+	{
+#if PORT == WINDOWS || PORT == DOS
+		data = (alternative_cable_l ? ((tdi ? 0x01 : 0) | (tms ? 0x04 : 0)) :
+		       (alternative_cable_x ? ((tdi ? 0x01 : 0) | (tms ? 0x04 : 0) | 0x10) :
+		       ((tdi ? 0x40 : 0) | (tms ? 0x02 : 0))));
+
+		write_byteblaster(0, data);
+
+		if (read_tdo)
+		{
+			tdo = read_byteblaster(1);
+			tdo = (alternative_cable_l ? ((tdo & 0x40) ? 1 : 0) :
+			      (alternative_cable_x ? ((tdo & 0x10) ? 1 : 0) :
+			      ((tdo & 0x80) ? 0 : 1)));
+		}
+
+		write_byteblaster(0, data | (alternative_cable_l ? 0x02 : (alternative_cable_x ? 0x02: 0x01)));
+
+		write_byteblaster(0, data);
+#else
+		/* parallel port interface not available */
+		tdo = 0;
+#endif
+	}
+
+	return (tdo);
+}
+
+void jbi_message(char *message_text)
+{
+	puts(message_text);
+	fflush(stdout);
+}
+
+void jbi_export_integer(char *key, long value)
+{
+	if (verbose)
+	{
+		printf("Export: key = \"%s\", value = %ld\n", key, value);
+		fflush(stdout);
+	}
+}
+
+#define HEX_LINE_CHARS 72
+#define HEX_LINE_BITS (HEX_LINE_CHARS * 4)
+
+char conv_to_hex(unsigned long value)
+{
+	char c;
+
+	if (value > 9)
+	{
+		c = (char) (value + ('A' - 10));
+	}
+	else
+	{
+		c = (char) (value + '0');
+	}
+
+	return (c);
+}
+
+void jbi_export_boolean_array(char *key, unsigned char *data, long count)
+{
+	char string[HEX_LINE_CHARS + 1];
+	long i, offset;
+	unsigned long size, line, lines, linebits, value, j, k;
+
+	if (verbose)
+	{
+		if (count > HEX_LINE_BITS)
+		{
+			printf("Export: key = \"%s\", %ld bits, value = HEX\n", key, count);
+			lines = (count + (HEX_LINE_BITS - 1)) / HEX_LINE_BITS;
+
+			for (line = 0; line < lines; ++line)
+			{
+				if (line < (lines - 1))
+				{
+					linebits = HEX_LINE_BITS;
+					size = HEX_LINE_CHARS;
+					offset = count - ((line + 1) * HEX_LINE_BITS);
+				}
+				else
+				{
+					linebits = count - ((lines - 1) * HEX_LINE_BITS);
+					size = (linebits + 3) / 4;
+					offset = 0L;
+				}
+
+				string[size] = '\0';
+				j = size - 1;
+				value = 0;
+
+				for (k = 0; k < linebits; ++k)
+				{
+					i = k + offset;
+					if (data[i >> 3] & (1 << (i & 7))) value |= (1 << (i & 3));
+					if ((i & 3) == 3)
+					{
+						string[j] = conv_to_hex(value);
+						value = 0;
+						--j;
+					}
+				}
+				if ((k & 3) > 0) string[j] = conv_to_hex(value);
+
+				printf("%s\n", string);
+			}
+
+			fflush(stdout);
+		}
+		else
+		{
+			size = (count + 3) / 4;
+			string[size] = '\0';
+			j = size - 1;
+			value = 0;
+
+			for (i = 0; i < count; ++i)
+			{
+				if (data[i >> 3] & (1 << (i & 7))) value |= (1 << (i & 3));
+				if ((i & 3) == 3)
+				{
+					string[j] = conv_to_hex(value);
+					value = 0;
+					--j;
+				}
+			}
+			if ((i & 3) > 0) string[j] = conv_to_hex(value);
+
+			printf("Export: key = \"%s\", %ld bits, value = HEX %s\n",
+				key, count, string);
+			fflush(stdout);
+		}
+	}
+}
+
+void jbi_delay(long microseconds)
+{
+#if PORT == WINDOWS
+	/* if Windows NT, flush I/O cache buffer before delay loop */
+	if (windows_nt && (port_io_count > 0)) flush_ports();
+#endif
+
+	delay_loop(microseconds *
+		((one_ms_delay / 1000L) + ((one_ms_delay % 1000L) ? 1 : 0)));
+}
+
+int jbi_vector_map
+(
+	int signal_count,
+	char **signals
+)
+{
+	int signal, vector, ch_index, diff;
+	int matched_count = 0;
+	char l, r;
+
+	for (vector = 0; (vector < VECTOR_SIGNAL_COUNT); ++vector)
+	{
+		vector_list[vector].vector_index = -1;
+	}
+
+	for (signal = 0; signal < signal_count; ++signal)
+	{
+		diff = 1;
+		for (vector = 0; (diff != 0) && (vector < VECTOR_SIGNAL_COUNT);
+			++vector)
+		{
+			if (vector_list[vector].vector_index == -1)
+			{
+				ch_index = 0;
+				do
+				{
+					l = signals[signal][ch_index];
+					r = vector_list[vector].signal_name[ch_index];
+					diff = (((l >= 'a') && (l <= 'z')) ? (l - ('a' - 'A')) : l)
+						- (((r >= 'a') && (r <= 'z')) ? (r - ('a' - 'A')) : r);
+					++ch_index;
+				}
+				while ((diff == 0) && (l != '\0') && (r != '\0'));
+
+				if (diff == 0)
+				{
+					vector_list[vector].vector_index = signal;
+					++matched_count;
+				}
+			}
+		}
+	}
+
+	return (matched_count);
+}
+
+int jbi_vector_io
+(
+	int signal_count,
+	long *dir_vect,
+	long *data_vect,
+	long *capture_vect
+)
+{
+	int signal, vector, bit;
+	int matched_count = 0;
+	int data = 0;
+	int mask = 0;
+	int dir = 0;
+	int i = 0;
+	int result = 0;
+	char ch_data = 0;
+
+	if (!jtag_hardware_initialized)
+	{
+		initialize_jtag_hardware();
+		jtag_hardware_initialized = TRUE;
+	}
+
+	/*
+	*	Collect information about output signals
+	*/
+	for (vector = 0; vector < VECTOR_SIGNAL_COUNT; ++vector)
+	{
+		signal = vector_list[vector].vector_index;
+
+		if ((signal >= 0) && (signal < signal_count))
+		{
+			bit = (1 << vector_list[vector].hardware_bit);
+
+			mask |= bit;
+			if (data_vect[signal >> 5] & (1L << (signal & 0x1f))) data |= bit;
+			if (dir_vect[signal >> 5] & (1L << (signal & 0x1f))) dir |= bit;
+
+			++matched_count;
+		}
+	}
+
+	/*
+	*	Write outputs to hardware interface, if any
+	*/
+	if (dir != 0)
+	{
+		if (specified_com_port)
+		{
+			ch_data = (char) (((data >> 6) & 0x01) | (data & 0x02) |
+					  ((data << 2) & 0x04) | ((data << 3) & 0x08) | 0x60);
+			write(com_port, &ch_data, 1);
+		}
+		else
+		{
+#if PORT == WINDOWS || PORT == DOS
+
+			write_byteblaster(0, data);
+
+#endif
+		}
+	}
+
+	/*
+	*	Read the input signals and save information in capture_vect[]
+	*/
+	if ((dir != mask) && (capture_vect != NULL))
+	{
+		if (specified_com_port)
+		{
+			ch_data = 0x7e;
+			write(com_port, &ch_data, 1);
+			for (i = 0; (i < 100) && (result != 1); ++i)
+			{
+				result = read(com_port, &ch_data, 1);
+			}
+			if (result == 1)
+			{
+				data = ((ch_data << 7) & 0x80) | ((ch_data << 3) & 0x10);
+			}
+			else
+			{
+				fprintf(stderr, "Error:  BitBlaster not responding\n");
+			}
+		}
+		else
+		{
+#if PORT == WINDOWS || PORT == DOS
+
+			data = read_byteblaster(1) ^ 0x80; /* parallel port inverts bit 7 */
+
+#endif
+		}
+
+		for (vector = 0; vector < VECTOR_SIGNAL_COUNT; ++vector)
+		{
+			signal = vector_list[vector].vector_index;
+
+			if ((signal >= 0) && (signal < signal_count))
+			{
+				bit = (1 << vector_list[vector].hardware_bit);
+
+				if ((dir & bit) == 0)	/* if it is an input signal... */
+				{
+					if (data & bit)
+					{
+						capture_vect[signal >> 5] |= (1L << (signal & 0x1f));
+					}
+					else
+					{
+						capture_vect[signal >> 5] &= ~(unsigned long)
+							(1L << (signal & 0x1f));
+					}
+				}
+			}
+		}
+	}
+
+	return (matched_count);
+}
+
+void *jbi_malloc(unsigned int size)
+{
+	unsigned int n_bytes_to_allocate =
+#if defined(USE_STATIC_MEMORY) || defined(MEM_TRACKER)
+		sizeof(unsigned int) +
+#endif /* USE_STATIC_MEMORY || MEM_TRACKER */
+#if defined(MEM_TRACKER)
+		(2 * sizeof(DWORD)) +
+#endif /* MEM_TRACKER */
+		(POINTER_ALIGNMENT * ((size + POINTER_ALIGNMENT - 1) / POINTER_ALIGNMENT));
+
+	unsigned char *ptr = 0;
+
+
+#if defined(MEM_TRACKER)
+	if ((n_bytes_allocated + n_bytes_to_allocate) > peak_memory_usage)
+	{
+		peak_memory_usage = n_bytes_allocated + n_bytes_to_allocate;
+	}
+	if ((n_allocations + 1) > peak_allocations)
+	{
+		peak_allocations = n_allocations + 1;
+	}
+#endif /* MEM_TRACKER */
+
+#if defined(USE_STATIC_MEMORY)
+	if ((n_bytes_allocated + n_bytes_to_allocate) <= N_STATIC_MEMORY_BYTES)
+	{
+		ptr = (&(static_memory_heap[n_bytes_allocated]));
+	}
+#else /* USE_STATIC_MEMORY */
+	ptr = (unsigned char *) malloc(n_bytes_to_allocate);
+#endif /* USE_STATIC_MEMORY */
+
+#if defined(USE_STATIC_MEMORY) || defined(MEM_TRACKER)
+	if (ptr != 0)
+	{
+		unsigned int i = 0;
+
+#if defined(MEM_TRACKER)
+		for (i = 0; i < sizeof(DWORD); ++i)
+		{
+			*ptr = (unsigned char) (BEGIN_GUARD >> (8 * i));
+			++ptr;
+		}
+#endif /* MEM_TRACKER */
+
+		for (i = 0; i < sizeof(unsigned int); ++i)
+		{
+			*ptr = (unsigned char) (size >> (8 * i));
+			++ptr;
+		}
+
+#if defined(MEM_TRACKER)
+		for (i = 0; i < sizeof(DWORD); ++i)
+		{
+			*(ptr + size + i) = (unsigned char) (END_GUARD >> (8 * i));
+			/* don't increment ptr */
+		}
+
+		++n_allocations;
+#endif /* MEM_TRACKER */
+
+		n_bytes_allocated += n_bytes_to_allocate;
+	}
+#endif /* USE_STATIC_MEMORY || MEM_TRACKER */
+
+	return ptr;
+}
+
+void jbi_free(void *ptr)
+{
+	if
+	(
+#if defined(MEM_TRACKER)
+		(n_allocations > 0) &&
+#endif /* MEM_TRACKER */
+		(ptr != 0)
+	)
+	{
+		unsigned char *tmp_ptr = (unsigned char *) ptr;
+
+#if defined(USE_STATIC_MEMORY) || defined(MEM_TRACKER)
+		unsigned int n_bytes_to_free = 0;
+		unsigned int i = 0;
+		unsigned int size = 0;
+#endif /* USE_STATIC_MEMORY || MEM_TRACKER */
+#if defined(MEM_TRACKER)
+		DWORD begin_guard = 0;
+		DWORD end_guard = 0;
+
+
+		tmp_ptr -= sizeof(DWORD);
+#endif /* MEM_TRACKER */
+#if defined(USE_STATIC_MEMORY) || defined(MEM_TRACKER)
+		tmp_ptr -= sizeof(unsigned int);
+#endif /* USE_STATIC_MEMORY || MEM_TRACKER */
+		ptr = tmp_ptr;
+
+#if defined(MEM_TRACKER)
+		for (i = 0; i < sizeof(DWORD); ++i)
+		{
+			begin_guard |= (((DWORD)(*tmp_ptr)) << (8 * i));
+			++tmp_ptr;
+		}
+#endif /* MEM_TRACKER */
+
+#if defined(USE_STATIC_MEMORY) || defined(MEM_TRACKER)
+		for (i = 0; i < sizeof(unsigned int); ++i)
+		{
+			size |= (((unsigned int)(*tmp_ptr)) << (8 * i));
+			++tmp_ptr;
+		}
+#endif /* USE_STATIC_MEMORY || MEM_TRACKER */
+
+#if defined(MEM_TRACKER)
+		tmp_ptr += size;
+
+		for (i = 0; i < sizeof(DWORD); ++i)
+		{
+			end_guard |= (((DWORD)(*tmp_ptr)) << (8 * i));
+			++tmp_ptr;
+		}
+
+		if ((begin_guard != BEGIN_GUARD) || (end_guard != END_GUARD))
+		{
+			fprintf(stderr, "Error: memory corruption detected for allocation #%d... bad %s guard\n",
+				n_allocations, (begin_guard != BEGIN_GUARD) ? "begin" : "end");
+		}
+
+		--n_allocations;
+#endif /* MEM_TRACKER */
+
+#if defined(USE_STATIC_MEMORY) || defined(MEM_TRACKER)
+		n_bytes_to_free =
+#if defined(MEM_TRACKER)
+		(2 * sizeof(DWORD)) +
+#endif /* MEM_TRACKER */
+		sizeof(unsigned int) +
+		(POINTER_ALIGNMENT * ((size + POINTER_ALIGNMENT - 1) / POINTER_ALIGNMENT));
+#endif /* USE_STATIC_MEMORY || MEM_TRACKER */
+
+#if defined(USE_STATIC_MEMORY)
+		if ((((unsigned long) ptr - (unsigned long) static_memory_heap) + n_bytes_to_free) == (unsigned long) n_bytes_allocated)
+		{
+			n_bytes_allocated -= n_bytes_to_free;
+		}
+#if defined(MEM_TRACKER)
+		else
+		{
+			n_bytes_not_recovered += n_bytes_to_free;
+		}
+#endif /* MEM_TRACKER */
+#else /* USE_STATIC_MEMORY */
+#if defined(MEM_TRACKER)
+		n_bytes_allocated -= n_bytes_to_free;
+#endif /* MEM_TRACKER */
+		free(ptr);
+#endif /* USE_STATIC_MEMORY */
+	}
+#if defined(MEM_TRACKER)
+	else
+	{
+		if (ptr != 0)
+		{
+			fprintf(stderr, "Error: attempt to free unallocated memory\n");
+		}
+	}
+#endif /* MEM_TRACKER */
+}
+
+/************************************************************************
+*
+*	get_tick_count() -- Get system tick count in milliseconds
+*
+*	for DOS, use BIOS function _bios_timeofday()
+*	for WINDOWS use GetTickCount() function
+*	for UNIX use clock() system function
+*/
+DWORD get_tick_count(void)
+{
+	DWORD tick_count = 0L;
+
+#if PORT == WINDOWS
+	tick_count = GetTickCount();
+#elif PORT == DOS
+	_bios_timeofday(_TIME_GETCLOCK, (long *)&tick_count);
+	tick_count *= 55L;	/* convert to milliseconds */
+#else
+	/* assume clock() function returns microseconds */
+	tick_count = (DWORD) (clock() / 1000L);
+#endif
+
+	return (tick_count);
+}
+
+#define DELAY_SAMPLES 10
+#define DELAY_CHECK_LOOPS 10000
+
+void calibrate_delay(void)
+{
+	int sample = 0;
+	int count = 0;
+	DWORD tick_count1 = 0L;
+	DWORD tick_count2 = 0L;
+
+	one_ms_delay = 0L;
+
+#if PORT == WINDOWS || PORT == DOS
+	for (sample = 0; sample < DELAY_SAMPLES; ++sample)
+	{
+		count = 0;
+		tick_count1 = get_tick_count();
+		while ((tick_count2 = get_tick_count()) == tick_count1) {};
+		do { delay_loop(DELAY_CHECK_LOOPS); count++; } while
+			((tick_count1 = get_tick_count()) == tick_count2);
+		one_ms_delay += ((DELAY_CHECK_LOOPS * (DWORD)count) /
+			(tick_count1 - tick_count2));
+	}
+
+	one_ms_delay /= DELAY_SAMPLES;
+#else
+	/* This is system-dependent!  Update this number for target system */
+	one_ms_delay = 1000L;
+#endif
+}
+
+char *error_text[] =
+{
+/* JBIC_SUCCESS            0 */ "success",
+/* JBIC_OUT_OF_MEMORY      1 */ "out of memory",
+/* JBIC_IO_ERROR           2 */ "file access error",
+/* JAMC_SYNTAX_ERROR       3 */ "syntax error",
+/* JBIC_UNEXPECTED_END     4 */ "unexpected end of file",
+/* JBIC_UNDEFINED_SYMBOL   5 */ "undefined symbol",
+/* JAMC_REDEFINED_SYMBOL   6 */ "redefined symbol",
+/* JBIC_INTEGER_OVERFLOW   7 */ "integer overflow",
+/* JBIC_DIVIDE_BY_ZERO     8 */ "divide by zero",
+/* JBIC_CRC_ERROR          9 */ "CRC mismatch",
+/* JBIC_INTERNAL_ERROR    10 */ "internal error",
+/* JBIC_BOUNDS_ERROR      11 */ "bounds error",
+/* JAMC_TYPE_MISMATCH     12 */ "type mismatch",
+/* JAMC_ASSIGN_TO_CONST   13 */ "assignment to constant",
+/* JAMC_NEXT_UNEXPECTED   14 */ "NEXT unexpected",
+/* JAMC_POP_UNEXPECTED    15 */ "POP unexpected",
+/* JAMC_RETURN_UNEXPECTED 16 */ "RETURN unexpected",
+/* JAMC_ILLEGAL_SYMBOL    17 */ "illegal symbol name",
+/* JBIC_VECTOR_MAP_FAILED 18 */ "vector signal name not found",
+/* JBIC_USER_ABORT        19 */ "execution cancelled",
+/* JBIC_STACK_OVERFLOW    20 */ "stack overflow",
+/* JBIC_ILLEGAL_OPCODE    21 */ "illegal instruction code",
+/* JAMC_PHASE_ERROR       22 */ "phase error",
+/* JAMC_SCOPE_ERROR       23 */ "scope error",
+/* JBIC_ACTION_NOT_FOUND  24 */ "action not found",
+};
+
+#define MAX_ERROR_CODE (int)((sizeof(error_text)/sizeof(error_text[0]))+1)
+
+/************************************************************************/
+
+int main(int argc, char **argv)
+{
+	BOOL help = FALSE;
+	BOOL error = FALSE;
+	char *filename = NULL;
+	long offset = 0L;
+	long error_address = 0L;
+	JBI_RETURN_TYPE crc_result = JBIC_SUCCESS;
+	JBI_RETURN_TYPE exec_result = JBIC_SUCCESS;
+	unsigned short expected_crc = 0;
+	unsigned short actual_crc = 0;
+	char key[33] = {0};
+	char value[257] = {0};
+	int exit_status = 0;
+	int arg = 0;
+	int exit_code = 0;
+	int format_version = 0;
+	time_t start_time = 0;
+	time_t end_time = 0;
+	int time_delta = 0;
+	char *workspace = NULL;
+	char *action = NULL;
+	char *init_list[10];
+	int init_count = 0;
+	FILE *fp = NULL;
+	struct stat sbuf;
+	long workspace_size = 0;
+	char *exit_string = NULL;
+	int reset_jtag = 1;
+	int execute_program = 1;
+	int action_count = 0;
+	int procedure_count = 0;
+	int index = 0;
+	char *action_name = NULL;
+	char *description = NULL;
+	JBI_PROCINFO *procedure_list = NULL;
+	JBI_PROCINFO *procptr = NULL;
+
+	verbose = FALSE;
+
+	init_list[0] = NULL;
+
+	/* print out the version string and copyright message */
+	fprintf(stderr, "Jam STAPL ByteCode Player Version 2.2\nCopyright (C) 1998-2001 Altera Corporation\n\n");
+
+	for (arg = 1; arg < argc; arg++)
+	{
+#if PORT == UNIX
+		if (argv[arg][0] == '-')
+#else
+		if ((argv[arg][0] == '-') || (argv[arg][0] == '/'))
+#endif
+		{
+			switch(toupper(argv[arg][1]))
+			{
+			case 'A':				/* set action name */
+				if (action == NULL)
+				{
+					action = &argv[arg][2];
+				}
+				else
+				{
+					error = TRUE;
+				}
+				break;
+
+#if PORT == WINDOWS || PORT == DOS
+			case 'C':				/* Use alternative ISP download cable */
+				if(toupper(argv[arg][2]) == 'L')
+					alternative_cable_l = TRUE;
+				else if(toupper(argv[arg][2]) == 'X')
+					alternative_cable_x = TRUE;
+				break;
+#endif
+
+			case 'D':				/* initialization list */
+				if (argv[arg][2] == '"')
+				{
+					init_list[init_count] = &argv[arg][3];
+				}
+				else
+				{
+					init_list[init_count] = &argv[arg][2];
+				}
+				init_list[++init_count] = NULL;
+				break;
+
+#if PORT == WINDOWS || PORT == DOS
+			case 'P':				/* set LPT port address */
+				specified_lpt_port = TRUE;
+				if (sscanf(&argv[arg][2], "%d", &lpt_port) != 1) error = TRUE;
+				if ((lpt_port < 1) || (lpt_port > 3)) error = TRUE;
+				if (error)
+				{
+					if (sscanf(&argv[arg][2], "%x", &lpt_port) == 1)
+					{
+						if ((lpt_port == 0x3bc) ||
+							(lpt_port == 0x378) ||
+							(lpt_port == 0x278))
+						{
+							error = FALSE;
+							specified_lpt_addr = TRUE;
+							lpt_addr = (WORD) lpt_port;
+							lpt_port = 1;
+						}
+					}
+				}
+				break;
+#endif
+
+			case 'R':		/* don't reset the JTAG chain after use */
+				reset_jtag = 0;
+				break;
+
+			case 'S':				/* set serial port address */
+				serial_port_name = &argv[arg][2];
+				specified_com_port = TRUE;
+				break;
+
+			case 'M':				/* set memory size */
+				if (sscanf(&argv[arg][2], "%ld", &workspace_size) != 1)
+					error = TRUE;
+				if (workspace_size == 0) error = TRUE;
+				break;
+
+			case 'H':				/* help */
+				help = TRUE;
+				break;
+
+			case 'V':				/* verbose */
+				verbose = TRUE;
+				break;
+
+			case 'I':				/* show info only, do not execute */
+				verbose = TRUE;
+				execute_program = 0;
+				break;
+
+			default:
+				error = TRUE;
+				break;
+			}
+		}
+		else
+		{
+			/* it's a filename */
+			if (filename == NULL)
+			{
+				filename = argv[arg];
+			}
+			else
+			{
+				/* error -- we already found a filename */
+				error = TRUE;
+			}
+		}
+
+		if (error)
+		{
+			fprintf(stderr, "Illegal argument: \"%s\"\n", argv[arg]);
+			help = TRUE;
+			error = FALSE;
+		}
+	}
+
+#if PORT == WINDOWS || PORT == DOS
+	if (specified_lpt_port && specified_com_port)
+	{
+		fprintf(stderr, "Error:  -s and -p options may not be used together\n\n");
+		help = TRUE;
+	}
+#endif
+
+	if (help || (filename == NULL))
+	{
+		fprintf(stderr, "Usage:  jbi [options] <filename>\n");
+		fprintf(stderr, "\nAvailable options:\n");
+		fprintf(stderr, "    -h          : show help message\n");
+		fprintf(stderr, "    -v          : show verbose messages\n");
+		fprintf(stderr, "    -i          : show file info only - does not execute any action\n");
+		fprintf(stderr, "    -a<action>  : specify an action name (Jam STAPL)\n");
+		fprintf(stderr, "    -d<var=val> : initialize variable to specified value (Jam 1.1)\n");
+		fprintf(stderr, "    -d<proc=1>  : enable optional procedure (Jam STAPL)\n");
+		fprintf(stderr, "    -d<proc=0>  : disable recommended procedure (Jam STAPL)\n");
+#if PORT == WINDOWS || PORT == DOS
+		fprintf(stderr, "    -p<port>    : parallel port number or address (for ByteBlaster)\n");
+		fprintf(stderr, "    -c<cable>   : alternative download cable compatibility: -cl or -cx\n");
+#endif
+		fprintf(stderr, "    -s<port>    : serial port name (for BitBlaster)\n");
+		fprintf(stderr, "    -r          : don't reset JTAG TAP after use\n");
+		exit_status = 1;
+	}
+	else if ((workspace_size > 0) &&
+		((workspace = (char *) jbi_malloc((size_t) workspace_size)) == NULL))
+	{
+		fprintf(stderr, "Error: can't allocate memory (%d Kbytes)\n",
+			(int) (workspace_size / 1024L));
+		exit_status = 1;
+	}
+	else if (access(filename, 0) != 0)
+	{
+		fprintf(stderr, "Error: can't access file \"%s\"\n", filename);
+		exit_status = 1;
+	}
+	else
+	{
+		/* get length of file */
+		if (stat(filename, &sbuf) == 0) file_length = sbuf.st_size;
+
+		if ((fp = fopen(filename, "rb")) == NULL)
+		{
+			fprintf(stderr, "Error: can't open file \"%s\"\n", filename);
+			exit_status = 1;
+		}
+		else
+		{
+			/*
+			*	Read entire file into a buffer
+			*/
+#if PORT == DOS
+			int pages = 1 + (int) (file_length >> 14L);
+			int page;
+			file_buffer = (unsigned char **) jbi_malloc(
+				(size_t) (pages * sizeof(char *)));
+
+			for (page = 0; page < pages; ++page)
+			{
+				/* allocate enough 16K blocks to store the file */
+				file_buffer[page] = (unsigned char *) jbi_malloc (0x4000);
+				if (file_buffer[page] == NULL)
+				{
+					/* flag error and break out of loop */
+					file_buffer = NULL;
+					page = pages;
+				}
+			}
+#else
+			file_buffer = (unsigned char *) jbi_malloc((size_t) file_length);
+#endif
+
+			if (file_buffer == NULL)
+			{
+				fprintf(stderr, "Error: can't allocate memory (%d Kbytes)\n",
+					(int) (file_length / 1024L));
+				exit_status = 1;
+			}
+			else
+			{
+#if PORT == DOS
+				int pages = 1 + (int) (file_length >> 14L);
+				int page;
+				size_t page_size = 0x4000;
+				for (page = 0; (page < pages) && (exit_status == 0); ++page)
+				{
+					if (page == (pages - 1))
+					{
+						/* last page may not be full 16K bytes */
+						page_size = (size_t) (file_length & 0x3fffL);
+					}
+					if (fread(file_buffer[page], 1, page_size, fp) != page_size)
+					{
+						fprintf(stderr, "Error reading file \"%s\"\n", filename);
+						exit_status = 1;
+					}
+				}
+#else
+				if (fread(file_buffer, 1, (size_t) file_length, fp) !=
+					(size_t) file_length)
+				{
+					fprintf(stderr, "Error reading file \"%s\"\n", filename);
+					exit_status = 1;
+				}
+#endif
+			}
+
+			fclose(fp);
+		}
+
+		if (exit_status == 0)
+		{
+			/*
+			*	Get Operating System type
+			*/
+#if PORT == WINDOWS
+			windows_nt = !(GetVersion() & 0x80000000);
+#endif
+
+			/*
+			*	Calibrate the delay loop function
+			*/
+			calibrate_delay();
+
+			/*
+			*	Check CRC
+			*/
+			crc_result = jbi_check_crc(file_buffer, file_length,
+				&expected_crc, &actual_crc);
+
+			if (verbose || (crc_result == JBIC_CRC_ERROR))
+			{
+				switch (crc_result)
+				{
+				case JBIC_SUCCESS:
+					printf("CRC matched: CRC value = %04X\n", actual_crc);
+					break;
+
+				case JBIC_CRC_ERROR:
+					printf("CRC mismatch: expected %04X, actual %04X\n",
+						expected_crc, actual_crc);
+					break;
+
+				case JBIC_UNEXPECTED_END:
+					printf("Expected CRC not found, actual CRC value = %04X\n",
+						actual_crc);
+					break;
+
+				case JBIC_IO_ERROR:
+					printf("Error: File format is not recognized.\n");
+					exit(1);
+					break;
+
+				default:
+					printf("CRC function returned error code %d\n", crc_result);
+					break;
+				}
+			}
+
+			if (verbose)
+			{
+				/*
+				*	Display file format version
+				*/
+				jbi_get_file_info(file_buffer, file_length,
+					&format_version, &action_count, &procedure_count);
+
+				printf("File format is %s ByteCode format\n",
+					(format_version == 2) ? "Jam STAPL" : "pre-standardized Jam 1.1");
+
+				/*
+				*	Dump out NOTE fields
+				*/
+				while (jbi_get_note(file_buffer, file_length,
+					&offset, key, value, 256) == 0)
+				{
+					printf("NOTE \"%s\" = \"%s\"\n", key, value);
+				}
+
+				/*
+				*	Dump the action table
+				*/
+				if ((format_version == 2) && (action_count > 0))
+				{
+					printf("\nActions available in this file:\n");
+
+					for (index = 0; index < action_count; ++index)
+					{
+						jbi_get_action_info(file_buffer, file_length,
+							index, &action_name, &description, &procedure_list);
+
+						if (description == NULL)
+						{
+							printf("%s\n", action_name);
+						}
+						else
+						{
+							printf("%s \"%s\"\n", action_name, description);
+						}
+
+#if PORT == DOS
+						if (action_name != NULL) jbi_free(action_name);
+						if (description != NULL) jbi_free(description);
+#endif
+
+						procptr = procedure_list;
+						while (procptr != NULL)
+						{
+							if (procptr->attributes != 0)
+							{
+								printf("    %s (%s)\n", procptr->name,
+									(procptr->attributes == 1) ?
+									"optional" : "recommended");
+							}
+
+#if PORT == DOS
+							if (procptr->name != NULL) jbi_free(procptr->name);
+#endif
+
+							procedure_list = procptr->next;
+							jbi_free(procptr);
+							procptr = procedure_list;
+						}
+					}
+
+					/* add a blank line before execution messages */
+					if (execute_program) printf("\n");
+				}
+			}
+
+			if (execute_program)
+			{
+				/*
+				*	Execute the Jam STAPL ByteCode program
+				*/
+				time(&start_time);
+				exec_result = jbi_execute(file_buffer, file_length, workspace,
+					workspace_size, action, init_list, reset_jtag,
+					&error_address, &exit_code, &format_version);
+				time(&end_time);
+
+				if (exec_result == JBIC_SUCCESS)
+				{
+					if (format_version == 2)
+					{
+						switch (exit_code)
+						{
+						case  0: exit_string = "Success"; break;
+						case  1: exit_string = "Checking chain failure"; break;
+						case  2: exit_string = "Reading IDCODE failure"; break;
+						case  3: exit_string = "Reading USERCODE failure"; break;
+						case  4: exit_string = "Reading UESCODE failure"; break;
+						case  5: exit_string = "Entering ISP failure"; break;
+						case  6: exit_string = "Unrecognized device"; break;
+						case  7: exit_string = "Device revision is not supported"; break;
+						case  8: exit_string = "Erase failure"; break;
+						case  9: exit_string = "Device is not blank"; break;
+						case 10: exit_string = "Device programming failure"; break;
+						case 11: exit_string = "Device verify failure"; break;
+						case 12: exit_string = "Read failure"; break;
+						case 13: exit_string = "Calculating checksum failure"; break;
+						case 14: exit_string = "Setting security bit failure"; break;
+						case 15: exit_string = "Querying security bit failure"; break;
+						case 16: exit_string = "Exiting ISP failure"; break;
+						case 17: exit_string = "Performing system test failure"; break;
+						default: exit_string = "Unknown exit code"; break;
+						}
+					}
+					else
+					{
+						switch (exit_code)
+						{
+						case 0: exit_string = "Success"; break;
+						case 1: exit_string = "Illegal initialization values"; break;
+						case 2: exit_string = "Unrecognized device"; break;
+						case 3: exit_string = "Device revision is not supported"; break;
+						case 4: exit_string = "Device programming failure"; break;
+						case 5: exit_string = "Device is not blank"; break;
+						case 6: exit_string = "Device verify failure"; break;
+						case 7: exit_string = "SRAM configuration failure"; break;
+						default: exit_string = "Unknown exit code"; break;
+						}
+					}
+
+					printf("Exit code = %d... %s\n", exit_code, exit_string);
+				}
+				else if ((format_version == 2) &&
+					(exec_result == JBIC_ACTION_NOT_FOUND))
+				{
+					if ((action == NULL) || (*action == '\0'))
+					{
+						printf("Error: no action specified for Jam STAPL file.\nProgram terminated.\n");
+					}
+					else
+					{
+						printf("Error: action \"%s\" is not supported for this Jam STAPL file.\nProgram terminated.\n", action);
+					}
+				}
+				else if (exec_result < MAX_ERROR_CODE)
+				{
+					printf("Error at address %ld: %s.\nProgram terminated.\n",
+						error_address, error_text[exec_result]);
+				}
+				else
+				{
+					printf("Unknown error code %ld\n", exec_result);
+				}
+
+				/*
+				*	Print out elapsed time
+				*/
+				if (verbose)
+				{
+					time_delta = (int) (end_time - start_time);
+					printf("Elapsed time = %02u:%02u:%02u\n",
+						time_delta / 3600,			/* hours */
+						(time_delta % 3600) / 60,	/* minutes */
+						time_delta % 60);			/* seconds */
+				}
+			}
+		}
+	}
+
+	if (jtag_hardware_initialized) close_jtag_hardware();
+
+	if (workspace != NULL) jbi_free(workspace);
+	if (file_buffer != NULL) jbi_free(file_buffer);
+
+#if defined(MEM_TRACKER)
+	if (verbose)
+	{
+#if defined(USE_STATIC_MEMORY)
+		fprintf(stdout, "Memory Usage Info: static memory size = %ud (%dKB)\n", N_STATIC_MEMORY_BYTES, N_STATIC_MEMORY_KBYTES);
+#endif /* USE_STATIC_MEMORY */
+		fprintf(stdout, "Memory Usage Info: peak memory usage = %ud (%dKB)\n", peak_memory_usage, (peak_memory_usage + 1023) / 1024);
+		fprintf(stdout, "Memory Usage Info: peak allocations = %d\n", peak_allocations);
+#if defined(USE_STATIC_MEMORY)
+		if ((n_bytes_allocated - n_bytes_not_recovered) != 0)
+		{
+			fprintf(stdout, "Memory Usage Info: bytes still allocated = %d (%dKB)\n", (n_bytes_allocated - n_bytes_not_recovered), ((n_bytes_allocated - n_bytes_not_recovered) + 1023) / 1024);
+		}
+#else /* USE_STATIC_MEMORY */
+		if (n_bytes_allocated != 0)
+		{
+			fprintf(stdout, "Memory Usage Info: bytes still allocated = %d (%dKB)\n", n_bytes_allocated, (n_bytes_allocated + 1023) / 1024);
+		}
+#endif /* USE_STATIC_MEMORY */
+		if (n_allocations != 0)
+		{
+			fprintf(stdout, "Memory Usage Info: allocations not freed = %d\n", n_allocations);
+		}
+	}
+#endif /* MEM_TRACKER */
+
+	return (exit_status);
+}
+
+#if PORT==WINDOWS
+#ifndef __BORLANDC__
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+*
+*	SEARCH_DYN_DATA
+*
+*	Searches recursively in Windows 95/98 Registry for parallel port info
+*	under HKEY_DYN_DATA registry key.  Called by search_local_machine().
+*/
+void search_dyn_data
+(
+	char *dd_path,
+	char *hardware_key,
+	int lpt
+)
+{
+	DWORD index;
+	DWORD size;
+	DWORD type;
+	LONG result;
+	HKEY key;
+	int length;
+	WORD address;
+	char buffer[1024];
+	FILETIME last_write = {0};
+	WORD *word_ptr;
+	int i;
+
+	length = strlen(dd_path);
+
+	if (RegOpenKeyEx(
+		HKEY_DYN_DATA,
+		dd_path,
+		0L,
+		KEY_READ,
+		&key)
+		== ERROR_SUCCESS)
+	{
+		size = 1023;
+
+		if (RegQueryValueEx(
+			key,
+			"HardWareKey",
+			NULL,
+			&type,
+			(unsigned char *) buffer,
+			&size)
+			== ERROR_SUCCESS)
+		{
+			if ((type == REG_SZ) && (stricmp(buffer, hardware_key) == 0))
+			{
+				size = 1023;
+
+				if (RegQueryValueEx(
+					key,
+					"Allocation",
+					NULL,
+					&type,
+					(unsigned char *) buffer,
+					&size)
+					== ERROR_SUCCESS)
+				{
+					/*
+					*	By "inspection", I have found five cases: size 32, 48,
+					*	56, 60, and 80 bytes.  The port address seems to be
+					*	located at different offsets in the buffer for these
+					*	five cases, as shown below.  If a valid port address
+					*	is not found, or the size is not one of these known
+					*	sizes, then I search through the entire buffer and
+					*	look for a value which is a valid port address.
+					*/
+
+					word_ptr = (WORD *) buffer;
+
+					if ((type == REG_BINARY) && (size == 32))
+					{
+						address = word_ptr[10];
+					}
+					else if ((type == REG_BINARY) && (size == 48))
+					{
+						address = word_ptr[18];
+					}
+					else if ((type == REG_BINARY) && (size == 56))
+					{
+						address = word_ptr[22];
+					}
+					else if ((type == REG_BINARY) && (size == 60))
+					{
+						address = word_ptr[24];
+					}
+					else if ((type == REG_BINARY) && (size == 80))
+					{
+						address = word_ptr[24];
+					}
+					else address = 0;
+
+					/* if not found, search through entire buffer */
+					i = 0;
+					while ((i < (int) (size / 2)) &&
+						(address != 0x278) &&
+						(address != 0x27C) &&
+						(address != 0x378) &&
+						(address != 0x37C) &&
+						(address != 0x3B8) &&
+						(address != 0x3BC))
+					{
+						if ((word_ptr[i] == 0x278) ||
+							(word_ptr[i] == 0x27C) ||
+							(word_ptr[i] == 0x378) ||
+							(word_ptr[i] == 0x37C) ||
+							(word_ptr[i] == 0x3B8) ||
+							(word_ptr[i] == 0x3BC))
+						{
+							address = word_ptr[i];
+						}
+						++i;
+					}
+
+					if ((address == 0x278) ||
+						(address == 0x27C) ||
+						(address == 0x378) ||
+						(address == 0x37C) ||
+						(address == 0x3B8) ||
+						(address == 0x3BC))
+					{
+						lpt_addresses_from_registry[lpt] = address;
+					}
+				}
+			}
+		}
+
+		index = 0;
+
+		do
+		{
+			size = 1023;
+
+			result = RegEnumKeyEx(
+				key,
+				index++,
+				buffer,
+				&size,
+				NULL,
+				NULL,
+				NULL,
+				&last_write);
+
+			if (result == ERROR_SUCCESS)
+			{
+				dd_path[length] = '\\';
+				dd_path[length + 1] = '\0';
+				strcpy(&dd_path[length + 1], buffer);
+
+				search_dyn_data(dd_path, hardware_key, lpt);
+
+				dd_path[length] = '\0';
+			}
+		}
+		while (result == ERROR_SUCCESS);
+
+		RegCloseKey(key);
+	}
+}
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+*
+*	SEARCH_LOCAL_MACHINE
+*
+*	Searches recursively in Windows 95/98 Registry for parallel port info
+*	under HKEY_LOCAL_MACHINE\Enum.  When parallel port is found, calls
+*	search_dyn_data() to get the port address.
+*/
+void search_local_machine
+(
+	char *lm_path,
+	char *dd_path
+)
+{
+	DWORD index;
+	DWORD size;
+	DWORD type;
+	LONG result;
+	HKEY key;
+	int length;
+	char buffer[1024];
+	FILETIME last_write = {0};
+
+	length = strlen(lm_path);
+
+	if (RegOpenKeyEx(
+		HKEY_LOCAL_MACHINE,
+		lm_path,
+		0L,
+		KEY_READ,
+		&key)
+		== ERROR_SUCCESS)
+	{
+		size = 1023;
+
+		if (RegQueryValueEx(
+			key,
+			"PortName",
+			NULL,
+			&type,
+			(unsigned char *) buffer,
+			&size)
+			== ERROR_SUCCESS)
+		{
+			if ((type == REG_SZ) &&
+				(size == 5) &&
+				(buffer[0] == 'L') &&
+				(buffer[1] == 'P') &&
+				(buffer[2] == 'T') &&
+				(buffer[3] >= '1') &&
+				(buffer[3] <= '4') &&
+				(buffer[4] == '\0'))
+			{
+				/* we found the entry in HKEY_LOCAL_MACHINE, now we need to */
+				/* find the corresponding entry under HKEY_DYN_DATA.  */
+				/* add 5 to lm_path to skip over "Enum" and backslash */
+				search_dyn_data(dd_path, &lm_path[5], (buffer[3] - '1'));
+			}
+		}
+
+		index = 0;
+
+		do
+		{
+			size = 1023;
+
+			result = RegEnumKeyEx(
+				key,
+				index++,
+				buffer,
+				&size,
+				NULL,
+				NULL,
+				NULL,
+				&last_write);
+
+			if (result == ERROR_SUCCESS)
+			{
+				lm_path[length] = '\\';
+				lm_path[length + 1] = '\0';
+				strcpy(&lm_path[length + 1], buffer);
+
+				search_local_machine(lm_path, dd_path);
+
+				lm_path[length] = '\0';
+			}
+		}
+		while (result == ERROR_SUCCESS);
+
+		RegCloseKey(key);
+	}
+}
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+*
+*	GET_LPT_ADDRESSES_FROM_REGISTRY
+*
+*	Searches Win95/98 registry recursively to get I/O port addresses for
+*	parallel ports.
+*/
+void get_lpt_addresses_from_registry()
+{
+	char lm_path[1024];
+	char dd_path[1024];
+
+	strcpy(lm_path, "Enum");
+	strcpy(dd_path, "Config Manager");
+	search_local_machine(lm_path, dd_path);
+}
+#endif
+#endif
+
+void initialize_jtag_hardware()
+{
+	if (specified_com_port)
+	{
+		com_port = open(serial_port_name, O_RDWR);
+		if (com_port == -1)
+		{
+			fprintf(stderr, "Error: can't open serial port \"%s\"\n",
+				serial_port_name);
+		}
+		else
+		{
+			int i = 0, result = 0;
+			char data = 0;
+
+			data = 0x7e;
+			write(com_port, &data, 1);
+
+			for (i = 0; (i < 100) && (result != 1); ++i)
+			{
+				result = read(com_port, &data, 1);
+			}
+
+			if (result == 1)
+			{
+				data = 0x70; write(com_port, &data, 1); /* TDO echo off */
+				data = 0x72; write(com_port, &data, 1); /* auto LEDs off */
+				data = 0x74; write(com_port, &data, 1); /* ERROR LED off */
+				data = 0x76; write(com_port, &data, 1); /* DONE LED off */
+				data = 0x60; write(com_port, &data, 1); /* signals low */
+			}
+			else
+			{
+				fprintf(stderr, "Error: BitBlaster is not responding on %s\n",
+					serial_port_name);
+				close(com_port);
+				com_port = -1;
+			}
+		}
+	}
+	else
+	{
+#if PORT == WINDOWS || PORT == DOS
+
+#if PORT == WINDOWS
+		if (windows_nt)
+		{
+			initialize_nt_driver();
+		}
+		else
+		{
+#ifdef __BORLANDC__
+			fprintf(stderr, "Error: parallel port access is not available\n");
+#else
+			if (!specified_lpt_addr)
+			{
+				get_lpt_addresses_from_registry();
+
+				lpt_addr = 0;
+
+				if (specified_lpt_port)
+				{
+					lpt_addr = lpt_addresses_from_registry[lpt_port - 1];
+				}
+
+				if (lpt_addr == 0)
+				{
+					if (lpt_addresses_from_registry[3] != 0)
+						lpt_addr = lpt_addresses_from_registry[3];
+					if (lpt_addresses_from_registry[2] != 0)
+						lpt_addr = lpt_addresses_from_registry[2];
+					if (lpt_addresses_from_registry[1] != 0)
+						lpt_addr = lpt_addresses_from_registry[1];
+					if (lpt_addresses_from_registry[0] != 0)
+						lpt_addr = lpt_addresses_from_registry[0];
+				}
+
+				if (lpt_addr == 0)
+				{
+					if (specified_lpt_port)
+					{
+						lpt_addr = lpt_addr_table[lpt_port - 1];
+					}
+					else
+					{
+						lpt_addr = lpt_addr_table[0];
+					}
+				}
+			}
+			initial_lpt_ctrl = windows_nt ? 0x0c : read_byteblaster(2);
+#endif
+		}
+#endif
+
+#if PORT == DOS
+		/*
+		*	Read word at specific memory address to get the LPT port address
+		*/
+		WORD *bios_address = (WORD *) 0x00400008;
+
+		if (!specified_lpt_addr)
+		{
+			lpt_addr = bios_address[lpt_port - 1];
+
+			if ((lpt_addr != 0x278) &&
+				(lpt_addr != 0x27c) &&
+				(lpt_addr != 0x378) &&
+				(lpt_addr != 0x37c) &&
+				(lpt_addr != 0x3b8) &&
+				(lpt_addr != 0x3bc))
+			{
+				lpt_addr = lpt_addr_table[lpt_port - 1];
+			}
+		}
+		initial_lpt_ctrl = read_byteblaster(2);
+#endif
+
+		/* set AUTO-FEED low to enable ByteBlaster (value to port inverted) */
+		/* set DIRECTION low for data output from parallel port */
+		write_byteblaster(2, (initial_lpt_ctrl | 0x02) & 0xDF);
+#endif
+	}
+}
+
+void close_jtag_hardware()
+{
+	if (specified_com_port)
+	{
+		if (com_port != -1) close(com_port);
+	}
+	else
+	{
+#if PORT == WINDOWS || PORT == DOS
+		/* set AUTO-FEED high to disable ByteBlaster */
+		write_byteblaster(2, initial_lpt_ctrl & 0xfd);
+
+#if PORT == WINDOWS
+		if (windows_nt && (nt_device_handle != INVALID_HANDLE_VALUE))
+		{
+			if (port_io_count > 0) flush_ports();
+
+			CloseHandle(nt_device_handle);
+		}
+#endif
+#endif
+	}
+}
+
+#if PORT == WINDOWS
+/**************************************************************************/
+/*                                                                        */
+
+BOOL initialize_nt_driver()
+
+/*                                                                        */
+/*  Uses CreateFile() to open a connection to the Windows NT device       */
+/*  driver.                                                               */
+/*                                                                        */
+/**************************************************************************/
+{
+	BOOL status = FALSE;
+
+	ULONG buffer[1];
+	ULONG returned_length = 0;
+	char nt_lpt_str[] = { '\\', '\\', '.', '\\',
+		'A', 'L', 'T', 'L', 'P', 'T', '1', '\0' };
+
+
+	nt_lpt_str[10] = (char) ('1' + (lpt_port - 1));
+
+	nt_device_handle = CreateFile(
+		nt_lpt_str,
+		GENERIC_READ | GENERIC_WRITE,
+		0,
+		NULL,
+		OPEN_EXISTING,
+		FILE_ATTRIBUTE_NORMAL,
+		NULL);
+
+	if (nt_device_handle == INVALID_HANDLE_VALUE)
+	{
+		fprintf(stderr,
+			"I/O error:  cannot open device %s\nCheck port number and device driver installation",
+			nt_lpt_str);
+	}
+	else
+	{
+		if (DeviceIoControl(
+			nt_device_handle,			/* Handle to device */
+			PGDC_IOCTL_GET_DEVICE_INFO_PP,	/* IO Control code */
+			(ULONG *)NULL,					/* Buffer to driver. */
+			0,								/* Length of buffer in bytes. */
+			&buffer,						/* Buffer from driver. */
+			sizeof(ULONG),					/* Length of buffer in bytes. */
+			&returned_length,				/* Bytes placed in data_buffer. */
+			NULL))							/* Wait for operation to complete */
+		{
+			if (returned_length == sizeof(ULONG))
+			{
+				if (buffer[0] == PGDC_HDLC_NTDRIVER_VERSION)
+				{
+					status = TRUE;
+				}
+				else
+				{
+					fprintf(stderr,
+						"I/O error:  device driver %s is not compatible\n(Driver version is %lu, expected version %lu.\n",
+						nt_lpt_str,
+						(unsigned long) buffer[0],
+						(unsigned long) PGDC_HDLC_NTDRIVER_VERSION);
+				}
+			}
+			else
+			{
+				fprintf(stderr, "I/O error:  device driver %s is not compatible.\n",
+					nt_lpt_str);
+			}
+		}
+
+		if (!status)
+		{
+			CloseHandle(nt_device_handle);
+			nt_device_handle = INVALID_HANDLE_VALUE;
+		}
+	}
+
+	if (!status)
+	{
+		/* error message already given */
+		exit(1);
+	}
+
+	return (status);
+}
+#endif
+
+#if PORT == WINDOWS || PORT == DOS
+/**************************************************************************/
+/*                                                                        */
+
+void write_byteblaster
+(
+	int port,
+	int data
+)
+
+/*                                                                        */
+/**************************************************************************/
+{
+#if PORT == WINDOWS
+	BOOL status = FALSE;
+
+	int returned_length = 0;
+	int buffer[2];
+
+
+	if (windows_nt)
+	{
+		/*
+		*	On Windows NT, access hardware through device driver
+		*/
+		if (port == 0)
+		{
+			port_io_buffer[port_io_count].data = (USHORT) data;
+			port_io_buffer[port_io_count].command = PGDC_WRITE_PORT;
+			++port_io_count;
+
+			if (port_io_count >= PORT_IO_BUFFER_SIZE) flush_ports();
+		}
+		else
+		{
+			if (port_io_count > 0) flush_ports();
+
+			buffer[0] = port;
+			buffer[1] = data;
+
+			status = DeviceIoControl(
+				nt_device_handle,			/* Handle to device */
+				PGDC_IOCTL_WRITE_PORT_PP,	/* IO Control code for write */
+				(ULONG *)&buffer,			/* Buffer to driver. */
+				2 * sizeof(int),			/* Length of buffer in bytes. */
+				(ULONG *)NULL,				/* Buffer from driver.  Not used. */
+				0,							/* Length of buffer in bytes. */
+				(ULONG *)&returned_length,	/* Bytes returned.  Should be zero. */
+				NULL);						/* Wait for operation to complete */
+
+			if ((!status) || (returned_length != 0))
+			{
+				fprintf(stderr, "I/O error:  Cannot access ByteBlaster hardware\n");
+				CloseHandle(nt_device_handle);
+				exit(1);
+			}
+		}
+	}
+	else
+#endif
+	{
+		/*
+		*	On Windows 95, access hardware directly
+		*/
+		outp((WORD)(port + lpt_addr), (WORD)data);
+	}
+}
+
+/**************************************************************************/
+/*                                                                        */
+
+int read_byteblaster
+(
+	int port
+)
+
+/*                                                                        */
+/**************************************************************************/
+{
+	int data = 0;
+
+#if PORT == WINDOWS
+
+	BOOL status = FALSE;
+
+	int returned_length = 0;
+
+
+	if (windows_nt)
+	{
+		/* flush output cache buffer before reading from device */
+		if (port_io_count > 0) flush_ports();
+
+		/*
+		*	On Windows NT, access hardware through device driver
+		*/
+		status = DeviceIoControl(
+			nt_device_handle,			/* Handle to device */
+			PGDC_IOCTL_READ_PORT_PP,	/* IO Control code for Read */
+			(ULONG *)&port,				/* Buffer to driver. */
+			sizeof(int),				/* Length of buffer in bytes. */
+			(ULONG *)&data,				/* Buffer from driver. */
+			sizeof(int),				/* Length of buffer in bytes. */
+			(ULONG *)&returned_length,	/* Bytes placed in data_buffer. */
+			NULL);						/* Wait for operation to complete */
+
+		if ((!status) || (returned_length != sizeof(int)))
+		{
+			fprintf(stderr, "I/O error:  Cannot access ByteBlaster hardware\n");
+			CloseHandle(nt_device_handle);
+			exit(1);
+		}
+	}
+	else
+#endif
+	{
+		/*
+		*	On Windows 95, access hardware directly
+		*/
+		data = inp((WORD)(port + lpt_addr));
+	}
+
+	return (data & 0xff);
+}
+
+#if PORT == WINDOWS
+void flush_ports(void)
+{
+	ULONG n_writes = 0L;
+	BOOL status;
+
+	status = DeviceIoControl(
+		nt_device_handle,			/* handle to device */
+		PGDC_IOCTL_PROCESS_LIST_PP,	/* IO control code */
+		(LPVOID)port_io_buffer,		/* IN buffer (list buffer) */
+		port_io_count * sizeof(struct PORT_IO_LIST_STRUCT),/* length of IN buffer in bytes */
+		(LPVOID)port_io_buffer,	/* OUT buffer (list buffer) */
+		port_io_count * sizeof(struct PORT_IO_LIST_STRUCT),/* length of OUT buffer in bytes */
+		&n_writes,					/* number of writes performed */
+		0);							/* wait for operation to complete */
+
+	if ((!status) || ((port_io_count * sizeof(struct PORT_IO_LIST_STRUCT)) != n_writes))
+	{
+		fprintf(stderr, "I/O error:  Cannot access ByteBlaster hardware\n");
+		CloseHandle(nt_device_handle);
+		exit(1);
+	}
+
+	port_io_count = 0;
+}
+#endif /* PORT == WINDOWS */
+#endif /* PORT == WINDOWS || PORT == DOS */
+
+#if !defined (DEBUG)
+#pragma optimize ("ceglt", off)
+#endif
+
+void delay_loop(long count)
+{
+	while (count != 0L) count--;
+}
diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c
index f54b408..8032693 100644
--- a/drivers/usb/host/ehci-fsl.c
+++ b/drivers/usb/host/ehci-fsl.c
@@ -104,6 +104,9 @@ int ehci_hcd_init(int index, struct ehci_hccr **hccr, struct ehci_hcor **hcor)
 		out_le32(&(*hcor)->or_portsc[0], PORT_PTS_ULPI);
 	}
 
+	/*Fix 2nd usb start hang problem*/
+	setbits_be32(&ehci->control, USB_EN);
+
 	out_be32(&ehci->prictrl, 0x0000000c);
 	out_be32(&ehci->age_cnt_limit, 0x00000040);
 	out_be32(&ehci->sictrl, 0x00000001);
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 7f98a63..c65faf0 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -30,6 +30,13 @@
 
 #include "ehci.h"
 
+#ifdef  USB_HOST_DEBUG
+#define USB_EHCI_DEBUG   1
+#define debug(fmt, args...)        debug_cond(USB_EHCI_DEBUG, fmt, ##args)
+#else
+#define USB_EHCI_DEBUG   0
+#endif
+
 #ifndef CONFIG_USB_MAX_CONTROLLER_COUNT
 #define CONFIG_USB_MAX_CONTROLLER_COUNT 1
 #endif
@@ -862,7 +869,6 @@ int usb_lowlevel_init(int index, void **controller)
 	if (ehci_hcd_init(index, &ehcic[index].hccr, &ehcic[index].hcor))
 		return -1;
 
-	/* EHCI spec section 4.1 */
 	if (ehci_reset(index))
 		return -1;
 
diff --git a/include/common.h b/include/common.h
index a29f6a6..4ad17ea 100644
--- a/include/common.h
+++ b/include/common.h
@@ -308,7 +308,6 @@ int	checkdram     (void);
 int	last_stage_init(void);
 extern ulong monitor_flash_len;
 int mac_read_from_eeprom(void);
-int populate_serial_number(void);
 extern u8 _binary_dt_dtb_start[];	/* embedded device tree blob */
 int set_cpu_clk_info(void);
 
diff --git a/include/configs/AS4600_54T.h b/include/configs/AS4600_54T.h
new file mode 100644
index 0000000..25d995c
--- /dev/null
+++ b/include/configs/AS4600_54T.h
@@ -0,0 +1,430 @@
+/*
+ * Curt Brune <curt@cumulusnetworks.com>
+ * Vidya Ravipati <vidya@cumulusnetworks.com>
+ *
+ * Portions Copyright 2007-2009 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Accton AS4600_54T network switch board configuration file
+ */
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "configs/common_config.h"
+#include "version.h"
+
+/* High Level Configuration Options */
+#define CONFIG_BOOKE		1	/* BOOKE */
+#define CONFIG_E500		1	/* BOOKE e500 family */
+#define CONFIG_MPC85xx		1	/* MPC8540/60/55/41/48 */
+#define CONFIG_P2020		1	/* P2020 specific */
+#define CONFIG_AS4600_54T	1	/* AS4600_54T board specific */
+#define CONFIG_BOARDNAME		"AS4600_54T"
+#define CONFIG_MP		1	/* support multiple processors */
+
+#define CONFIG_FSL_ELBC		1	/* Has Enhanced localbus controller */
+#define CONFIG_PCI		1	/* enable any pci type devices */
+#define CONFIG_PCIE1		1	/* PCIE controller 1 */
+#undef  CONFIG_PCIE2			/* PCIE controller 2 */
+#undef	CONFIG_PCIE3			/* PCIE controller 3 */
+#define CONFIG_FSL_PCI_INIT	1	/* Use common FSL init code */
+#define CONFIG_FSL_PCIE_RESET	1	/* need PCIe reset errata */
+#define CONFIG_SYS_PCI_64BIT	1	/* enable 64-bit PCI resources */
+
+#define CONFIG_FSL_LAW		1	/* Use common FSL init code */
+
+#define CONFIG_TSEC_ENET		/* tsec ethernet support */
+
+#ifndef __ASSEMBLY__
+extern unsigned long get_clock_freq(void);
+#endif
+
+#define CONFIG_SYS_CLK_FREQ	100000000
+#define CONFIG_DDR_CLK_FREQ	100000000
+
+/*
+ * These can be toggled for performance analysis, otherwise use default.
+ */
+#define CONFIG_L2_CACHE			/* toggle L2 cache */
+#define CONFIG_BTB			/* toggle branch predition */
+
+/*
+ * Only possible on E500 Version 2 or newer cores.
+ */
+#define CONFIG_ENABLE_36BIT_PHYS	1
+
+#define CONFIG_SYS_MEMTEST_START	0x00000000	/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x7fffffff
+/* do not reset board on panic */
+#define CONFIG_PANIC_HANG		1
+
+/*
+ * Base addresses -- Note these are effective addresses where the
+ * actual resources get mapped (not physical addresses)
+ */
+#define CONFIG_SYS_CCSRBAR		0xff700000	/* relocated CCSRBAR */
+#define CONFIG_SYS_CCSRBAR_PHYS_LOW CONFIG_SYS_CCSRBAR
+
+/* DDR DRAM Setup */
+#define CONFIG_FSL_DDR3			1
+#undef	CONFIG_FSL_DDR_INTERACTIVE
+
+/* ECC will be enabled based on perf_mode environment variable */
+#define	CONFIG_DDR_ECC
+#define CONFIG_ECC_INIT_VIA_DDRCONTROLLER
+#define CONFIG_MEM_INIT_VALUE		0xdeadbeef
+
+#define CONFIG_SYS_DDR_SDRAM_BASE	0x00000000    /* DDR is system memory*/
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
+
+#define CONFIG_NUM_DDR_CONTROLLERS	1
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+#define CONFIG_CHIP_SELECTS_PER_CTRL	(1 * CONFIG_DIMM_SLOTS_PER_CTLR)
+
+#define CONFIG_SYS_SDRAM_SIZE		2048		/* DDR is 2GB */
+
+#undef CONFIG_CLOCKS_IN_MHZ
+
+
+/*
+ * Local Bus Definitions
+ */
+
+/*
+ * FLASH on the Local Bus - CS0
+ * One bank, 8M, with 8-bit data width
+ * Boot from BR0/OR0 bank at 0xef80_0000
+ *
+ * BR0:
+ *    Base address 0 = 0xef80_0000 = BR0[0:16] = 1110 1111 1000 0000 0
+ *    Port Size = 8 bits = BRx[19:20] = 01
+ *    Use GPCM = BRx[24:26] = 000
+ *    Valid = BRx[31] = 1
+ *
+ * 0	4    8	   12   16   20	   24   28
+ * 1110 1111 1100 0000 0000 1000 0000 0001 = ef800801	 BR0
+ *
+ * OR0:
+ *    Addr Mask = 8M = ORx[0:16] = 1111 1111 1000 0000 0
+ *    Reserved ORx[17:18] = 00
+ *    BCTLD = LBCTL not asserted = ORx[19] = 0
+ *    CSNT = ORx[20] = 1
+ *    ACS = half cycle delay = ORx[21:22] = 11
+ *    XACS = no extra setup = ORx[23] = 1
+ *    SCY = 2 = ORx[24:27] = 1111
+ *    SETA = cycle terminated internaly = ORx[28] = 0
+ *    TRLX = use relaxed timing = ORx[29] = 1
+ *    EHTR = use relaxed timing = ORx[30] = 1
+ *    EAD = use external address latch delay = OR[31] = 1
+ *
+ * 0	4    8	   12   16   20	   24   28
+ * 1111 1000 0000 0000 0000 1111 1111 0111 = ff800FF7    OR0
+ */
+
+#define CONFIG_SYS_FLASH_BASE		0xef800000	/* start of FLASH 8M */
+#define	CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
+#define CONFIG_SYS_FLASH_TLB_SIZE	BOOKE_PAGESZ_16M
+
+#define CONFIG_FLASH_BR_PRELIM \
+	(BR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | BR_PS_8 | BR_V)
+#define CONFIG_FLASH_OR_PRELIM		0xff800ff7	/* slow */
+
+#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE}
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* number of banks */
+/* sectors per device  sectors) */
+#define CONFIG_SYS_MAX_FLASH_SECT	128
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_FLASH_SHOW_PROGRESS	45
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+#define CONFIG_SYS_FLASH_ERASE_TOUT	30000	/* Flash Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+/* Flash Full Buffer Write Timeout (ms) */
+#define CONFIG_SYS_FLASH_BUFFER_WRITE_TOUT	500
+#define CONFIG_CMD_LOADS	/* loads */
+
+#ifndef CONFIG_SYS_TEXT_BASE
+#define CONFIG_SYS_TEXT_BASE    0xeff80000
+#endif
+
+#ifndef CONFIG_RESET_VECTOR_ADDRESS
+#define CONFIG_RESET_VECTOR_ADDRESS 0xeffffffc
+#endif
+
+#ifndef CONFIG_SYS_MONITOR_BASE
+#define CONFIG_SYS_MONITOR_BASE CONFIG_SYS_TEXT_BASE    /* start of monitor */
+#endif
+
+#define	CONFIG_BOARD_EARLY_INIT_R	1	/* Call board_pre_init_r */
+#define	CONFIG_BOARD_EARLY_INIT_F	1	/* Call board_pre_init_f */
+#define CONFIG_LAST_STAGE_INIT		1	/* Last minute info/fixups */
+/* FDT fixups before handing to the kernel */
+#define CONFIG_FDT_BOARD_FIXUPS		1
+
+#define CONFIG_SYS_INIT_RAM_LOCK	1
+#define CONFIG_SYS_INIT_RAM_ADDR	0xffd00000	/* Initial L1 address */
+/* Initial L1 address */
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS   CONFIG_SYS_INIT_RAM_ADDR
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH 0
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW CONFIG_SYS_INIT_RAM_ADDR_PHYS
+/* End of used area in RAM */
+#define CONFIG_SYS_INIT_RAM_SIZE	0x00004000
+
+/* num bytes initial data */
+#define CONFIG_SYS_GBL_DATA_SIZE	1024
+#define CONFIG_SYS_GBL_DATA_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - CONFIG_SYS_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
+
+/* Reserve 512 kB for Mon */
+#define CONFIG_SYS_MONITOR_LEN		(512 * 1024)
+/* Reserved for malloc */
+#define CONFIG_SYS_MALLOC_LEN		(256 * 1024)
+
+/* Nor Base Address */
+#define CONFIG_SYS_BR0_PRELIM		CONFIG_FLASH_BR_PRELIM
+/* Nor Options */
+#define CONFIG_SYS_OR0_PRELIM		CONFIG_FLASH_OR_PRELIM
+
+/* Serial Port */
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	1
+#define CONFIG_SYS_NS16550_CLK		get_bus_freq(0)
+
+#define CONFIG_SYS_NS16550_COM1	(CONFIG_SYS_CCSRBAR+0x4500)
+#define CONFIG_SYS_NS16550_COM2	(CONFIG_SYS_CCSRBAR+0x4600)
+
+/* I2C  */
+#define CONFIG_FSL_I2C		/* Use FSL common I2C driver */
+#define CONFIG_HARD_I2C		/* I2C with hardware support*/
+#undef	CONFIG_SOFT_I2C		/* I2C bit-banged */
+/* I2C speed and slave address */
+#define CONFIG_SYS_I2C_SPEED		400000
+#define CONFIG_SYS_I2C_OFFSET		0x3000
+#define CONFIG_SYS_I2C2_OFFSET		0x3100
+
+#define CONFIG_I2C_MULTI_BUS
+#define	CONFIG_SYS_MAX_I2C_BUS		2
+#define	CONFIG_I2C_CMD_TREE
+
+/*
+ * CPLD on the Local Bus - CS1
+ *
+ * BR1:
+ *    Base address = 0xEA00_0000 = BRx[0:16] = 1110 1010 0000 0000 0
+ *    Port Size = 8 bits = BRx[19:20] = 01
+ *    Use GPCM = BRx[24:26] = 000
+ *    Valid = BRx[31] = 1
+ *
+ * 0    4    8    12   16   20   24   28
+ * 1110 1010 0000 0000 0000 1000 0000 0001 = EA000801    BR1
+ *
+ * OR1:
+ *    Addr Mask = 32K = ORx[0:16] = 1111 1111 1111 1111 1
+ *    Reserved ORx[17:18] = 00
+ *    BCTLD = LBCTL not asserted = ORx[19] = 0
+ *    CSNT = ORx[20] = 1
+ *    ACS = half cycle delay = ORx[21:22] = 11
+ *    XACS = no extra setup = ORx[23] = 1
+ *    SCY = 6 = ORx[24:27] = 1111
+ *    SETA = cycle terminated internaly = ORx[28] = 0
+ *    TRLX = use relaxed timing = ORx[29] = 1
+ *    EHTR = use relaxed timing = ORx[30] = 1
+ *    EAD = use external address latch delay = OR[31] = 1
+ *
+ * 0    4    8    12   16   20   24   28
+ * 1111 1111 1111 1111 1000 1111 1111 0111 = ffff8ff7    OR1
+ */
+
+#define CONFIG_SYS_CPLD_BASE	0xea000000
+
+#define CONFIG_CPLD_BR_PRELIM \
+	(BR_PHYS_ADDR(CONFIG_SYS_CPLD_BASE) | BR_PS_8 | BR_V)
+/*
+ * use bus timing parms from original boot code
+ */
+#define CONFIG_CPLD_OR_PRELIM	0xffff8ff7 /* slow */
+
+#define CONFIG_SYS_BR1_PRELIM		CONFIG_CPLD_BR_PRELIM
+#define CONFIG_SYS_OR1_PRELIM		CONFIG_CPLD_OR_PRELIM
+
+/*
+ * General PCI
+ * Memory space is mapped 1-1, but I/O space must start from 0.
+ */
+
+/*
+ * Keep these sizes in sync with the LAWs
+ */
+
+#ifdef CONFIG_PCIE1
+#define CONFIG_SYS_PCIE1_MEM_VIRT	0xa0000000
+#define CONFIG_SYS_PCIE1_MEM_BUS	0xa0000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0xa0000000
+#define CONFIG_SYS_PCIE1_MEM_SIZE	0x20000000	/* 512M */
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xffc20000
+#define CONFIG_SYS_PCIE1_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xffc20000
+#define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	/* 64K */
+#endif
+
+#if defined(CONFIG_PCI) || defined(CONFIG_PCI1)
+#define CONFIG_PCI_PNP			/* do pci plug-and-play */
+#define CONFIG_PCI_SCAN_SHOW		/* show pci devices on startup */
+#endif	/* CONFIG_PCI */
+
+
+/*
+ * Networking
+ */
+
+#if defined(CONFIG_TSEC_ENET)
+
+#define CONFIG_MII		1	/* MII PHY management */
+/* TODO: Don't allow unregistered phys */
+#undef CONFIG_MII_DEFAULT_TSEC
+#undef CONFIG_TSEC1
+#undef CONFIG_TSEC3
+
+#define CONFIG_TSEC2			/* Ethernet  */
+#define	CONFIG_TSEC2_NAME	"eth0"
+
+#define TSEC2_PHY_ADDR		1
+#define TSEC2_PHYIDX		0
+#define TSEC2_FLAGS		(TSEC_GIGABIT | TSEC_SGMII)
+
+#define CONFIG_ETHPRIME		"eth0"
+
+#define CONFIG_PHY_GIGE		1	/* Include GbE speed/duplex detection */
+#endif	/* CONFIG_TSEC_ENET */
+
+/*
+ * In-band SGMII auto-negotiation between TBI and BCM54616S PHY fails, force
+ * 1000mbps SGMII link
+ */
+#define CONFIG_TSEC_TBICR_SETTINGS (  \
+		TBICR_PHY_RESET	    | \
+		TBICR_FULL_DUPLEX   | \
+		TBICR_SPEED1_SET      \
+		)
+
+/*
+ * Environment
+ */
+#define CONFIG_ENV_IS_IN_FLASH	1
+#define CONFIG_ENV_ADDR		0xeff60000
+#define CONFIG_ENV_SECT_SIZE	0x00010000	/* 64K (one sector) */
+#ifdef CONFIG_ENV_SIZE
+#undef CONFIG_ENV_SIZE
+#endif
+#define CONFIG_ENV_SIZE         CONFIG_ENV_SECT_SIZE    /* re-define env size */
+
+/*
+ * Board hardware information, stored in flash.
+ */
+#define CONFIG_CMD_SYS_EEPROM
+#define CONFIG_SYS_EEPROM_LOAD_ENV_MAC
+#define CONFIG_SYS_EEPROM_MAX_NUM_ETH_PORTS	1
+
+#define CONFIG_SYS_EEPROM_USE_COMMON_FLASH_IO   /* sys_eeprom read/write function */
+#define CONFIG_SYS_FLASH_HWINFO_ADDR		0xeff70000
+/* 64K(one sector) for HWINFO */
+#define CONFIG_SYS_FLASH_HWINFO_SECT_SIZE	0x00010000
+
+/*
+ * Enable USB support
+ */
+#define CONFIG_CMD_USB		1	/* USB Support			      */
+#define CONFIG_USB_EHCI         1	/* USB EHCI host controller	      */
+#define CONFIG_USB_EHCI_FSL     1	/* Freescale USB EHCI host controller */
+#define CONFIG_USB_STORAGE      1	/* support for USB storage devices    */
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+
+#undef	CONFIG_WATCHDOG		/* watchdog disabled */
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LOAD_ADDR	0x2000000	/* default load address */
+#define CONFIG_SYS_PROMPT	"LOADER=> "		/* Monitor Command Prompt */
+/* enable platform specific init */
+#define CONFIG_MISC_INIT_R      1
+#define CONFIG_SYS_LOADS_BAUD_CHANGE	1	/* allow baudrate change */
+
+#if defined(CONFIG_CMD_KGDB)
+/* speed to run kgdb serial port */
+#define CONFIG_KGDB_BAUDRATE	CONFIG_BAUDRATE
+#define CONFIG_KGDB_SER_INDEX	1	/* which serial port to use */
+#endif
+
+/*
+ * Environment Configuration
+ */
+
+#if defined(CONFIG_TSEC_ENET)
+#define CONFIG_HAS_ETH0
+#endif
+
+#define CONFIG_HOSTNAME		as4600_54t-unknown
+#define CONFIG_IPADDR	    192.168.1.10
+#define CONFIG_SERVERIP	    192.168.1.99
+#define CONFIG_GATEWAYIP    192.168.1.10
+#define CONFIG_NETMASK	    255.255.255.0
+
+/*default location for tftp and bootm*/
+#define CONFIG_LOADADDR		CONFIG_SYS_LOAD_ADDR
+
+#define CONFIG_BOOTARGS     "root=/dev/ram rw console=ttyS0,115200 quiet"
+
+#ifdef CONFIG_VERSION_VARIABLE
+	#define VER_VARIABLE "ver=" U_BOOT_VERSION " (" U_BOOT_DATE " - " U_BOOT_TIME ")" CONFIG_IDENT_STRING
+#else
+	#define VER_VARIABLE "\0"
+#endif
+/*
+** Platform environment variables needed by the common env
+** infrastructure.
+**
+*/
+#define CONFIG_PLATFORM_ENV	\
+	"consoledev=ttyS0\0"	\
+	"onie_start=0xefB60000\0"	\
+	"onie_sz.b=0x00400000\0"
+
+#define	CONFIG_EXTRA_ENV_SETTINGS	\
+	CONFIG_PLATFORM_ENV		\
+	CONFIG_ONIE_COMMON_UBOOT_ENV 	\
+	VER_VARIABLE
+
+/* ICOS Fastpath app image file support */
+#define CONFIG_FASTPATH
+
+#ifdef CONFIG_FASTPATH
+#define CONFIG_FDT_INDEX        4
+#endif
+
+#define CONFIG_CMD_REGINFO      /* register information of TLB and LAW */
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/onie_common_config.h b/include/configs/onie_common_config.h
index b47ca7a..44696f6 100644
--- a/include/configs/onie_common_config.h
+++ b/include/configs/onie_common_config.h
@@ -31,11 +31,14 @@
 /* Set the 'serial#' environment variable at boot time. */
 #define CONFIG_POPULATE_SERIAL_NUMBER
 
+/* Store the size of the U-Boot environment in the device tree */
+#define CONFIG_FDT_ENV_SIZE
+
 /*
  * onie_bootcmd load command, kicked off by CONFIG_BOOTCOMMAND.
  *
- * oniestart -- platform specific address of onie image in NOR flash
- * oniesz.b  -- size in bytes of the platform specific onie image in NOR flash
+ * onie_start -- platform specific address of onie image in NOR flash
+ * onie_sz.b  -- size in bytes of the platform specific onie image in NOR flash
  */
 #define CONFIG_ONIE_BOOT_CMD \
 	"nos_bootcmd=echo\0"						\
diff --git a/include/environment.h b/include/environment.h
index 82e1c0d..e64b43d 100644
--- a/include/environment.h
+++ b/include/environment.h
@@ -193,10 +193,6 @@ int set_default_vars(int nvars, char * const vars[]);
 /* Import from binary representation into hash table */
 int env_import(const char *buf, int check);
 
-#ifdef CONFIG_ENV_WRITE_DEFAULT_IF_CRC_BAD
-void env_write_default_if_crc_bad(void);
-#endif
-
 #endif /* DO_DEPS_ONLY */
 
 #endif /* _ENVIRONMENT_H_ */
diff --git a/include/sys_eeprom.h b/include/sys_eeprom.h
index 524f14c..5b5e2a3 100644
--- a/include/sys_eeprom.h
+++ b/include/sys_eeprom.h
@@ -2,7 +2,20 @@
  * See file CREDITS for list of people who contributed to this
  * project.
  *
- * SPDX-License-Identifier:	GPL-2.0+
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
  */
 
 #ifndef __SYS_EEPROM_H_
